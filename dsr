#!/usr/bin/env bash
# dsr - Doodlestein Self-Releaser
#
# Fallback release infrastructure for when GitHub Actions is throttled.
#
# Usage:
#   dsr <command> [options]
#
# Commands:
#   check     Detect throttled GitHub Actions runs
#   watch     Continuous monitoring daemon
#   build     Build artifacts locally
#   release   Upload artifacts to GitHub
#   fallback  Full pipeline: check -> build -> release
#   repos     Manage repository registry
#   config    View/modify configuration
#   doctor    System diagnostics
#
# Global Options:
#   --json, -j          Machine-readable JSON output
#   --non-interactive   Disable prompts (CI mode)
#   --dry-run, -n       Show planned actions without executing
#   --verbose, -v       Enable verbose logging
#   --quiet, -q         Suppress non-error output
#   --help, -h          Show help
#   --version           Show version

set -uo pipefail

# Version
DSR_VERSION="0.1.0"

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source modules (logging first, others may depend on it)
source "$SCRIPT_DIR/src/logging.sh"
source "$SCRIPT_DIR/src/config.sh"
source "$SCRIPT_DIR/src/signing.sh"
source "$SCRIPT_DIR/src/github.sh"
source "$SCRIPT_DIR/src/host_health.sh"

# Global flags
JSON_MODE=false
# shellcheck disable=SC2034  # Reserved for future use
DRY_RUN=false
VERBOSE=false
QUIET=false
# shellcheck disable=SC2034  # Reserved for future use
NON_INTERACTIVE=false

# Note: Colors and log functions are now provided by src/logging.sh
# The logging module provides: log_error, log_warn, log_info, log_debug, log_ok, log_timed

# Show help
show_help() {
    cat << 'EOF'
dsr - Doodlestein Self-Releaser

Fallback release infrastructure for when GitHub Actions is throttled.

USAGE:
    dsr <command> [options]

COMMANDS:
    check       Detect throttled GitHub Actions runs
    watch       Continuous monitoring daemon
    build       Build artifacts locally
    release     Upload artifacts to GitHub
    fallback    Full pipeline: check -> build -> release
    repos       Manage repository registry
    health      Check health of build hosts
    config      View/modify configuration
    doctor      System diagnostics
    signing     Manage minisign keys and signing

GLOBAL OPTIONS:
    -j, --json          Machine-readable JSON output
    -y, --non-interactive   Disable prompts (CI mode)
    -n, --dry-run       Show planned actions without executing
    -v, --verbose       Enable verbose logging
    -q, --quiet         Suppress non-error output
    -h, --help          Show this help
        --version       Show version

EXAMPLES:
    dsr config init              Initialize configuration
    dsr config show              Show current configuration
    dsr check --repos ntm,bv     Check if repos are throttled
    dsr build --repo ntm         Build ntm locally
    dsr doctor                   Check system dependencies

For more information, see docs/CLI_CONTRACT.md
EOF
}

# Show version
show_version() {
    if $JSON_MODE; then
        echo "{\"tool\": \"dsr\", \"version\": \"$DSR_VERSION\"}"
    else
        echo "dsr version $DSR_VERSION"
    fi
}

# JSON envelope helper
# Usage: json_envelope <command> <status> <exit_code> [details_json]
json_envelope() {
    local cmd="$1"
    local vstatus="$2"  # renamed to avoid potential conflict
    local exit_code="$3"
    local details="${4:-"{}"}"
    local run_id
    run_id=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "unknown")
    local started_at
    started_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat << EOF
{
  "command": "$cmd",
  "status": "$vstatus",
  "exit_code": $exit_code,
  "run_id": "$run_id",
  "started_at": "$started_at",
  "duration_ms": 0,
  "tool": "dsr",
  "version": "$DSR_VERSION",
  "details": $details
}
EOF
}

# ============================================================================
# CONFIG SUBCOMMAND
# ============================================================================

cmd_config() {
    local subcmd="${1:-show}"
    shift 2>/dev/null || true

    case "$subcmd" in
        init)
            cmd_config_init "$@"
            ;;
        show)
            cmd_config_show "$@"
            ;;
        get)
            cmd_config_get "$@"
            ;;
        set)
            cmd_config_set "$@"
            ;;
        validate)
            cmd_config_validate "$@"
            ;;
        edit)
            cmd_config_edit "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr config - View and modify configuration

USAGE:
    dsr config <subcommand> [options]

SUBCOMMANDS:
    init        Initialize configuration directories and files
    show        Show current configuration
    get <key>   Get a specific config value
    set <k>=<v> Set a config value
    validate    Validate configuration files
    edit        Open config in $EDITOR

OPTIONS:
    --json      Output in JSON format
    --force     Overwrite existing files (init only)

EXAMPLES:
    dsr config init              Create default config files
    dsr config show              Show all configuration
    dsr config get threshold_seconds
    dsr config set log_level=debug
    dsr config validate
EOF
            ;;
        *)
            log_error "Unknown config subcommand: $subcmd"
            log_info "Run 'dsr config --help' for usage"
            return 4
            ;;
    esac
}

cmd_config_init() {
    local force=false
    [[ "${1:-}" == "--force" ]] && force=true

    if $JSON_MODE; then
        local status
        if $force; then
            config_init --force >/dev/null 2>&1
            status=$?
        else
            config_init >/dev/null 2>&1
            status=$?
        fi
        if [[ $status -eq 0 ]]; then
            json_envelope "config init" "success" 0 "{\"config_dir\": \"$DSR_CONFIG_DIR\", \"initialized\": true}"
        else
            json_envelope "config init" "error" $status "{\"error\": \"initialization failed\"}"
        fi
        return $status
    else
        if $force; then
            config_init --force
        else
            config_init
        fi
    fi
}

cmd_config_show() {
    if $JSON_MODE; then
        config_show --json
    else
        config_show "$@"
    fi
}

cmd_config_get() {
    local key="${1:-}"
    if [[ -z "$key" ]]; then
        log_error "Usage: dsr config get <key>"
        return 4
    fi

    config_load
    local value
    value=$(config_get "$key" "")

    if [[ -z "$value" ]]; then
        log_error "Key not found: $key"
        return 4
    fi

    if $JSON_MODE; then
        echo "{\"key\": \"$key\", \"value\": \"$value\"}"
    else
        echo "$value"
    fi
}

cmd_config_set() {
    local input="${1:-}"
    if [[ -z "$input" || ! "$input" =~ = ]]; then
        log_error "Usage: dsr config set KEY=VALUE"
        return 4
    fi

    local key="${input%%=*}"
    local value="${input#*=}"

    config_load
    config_set "$key" "$value" --persist

    if $JSON_MODE; then
        echo "{\"key\": \"$key\", \"value\": \"$value\", \"persisted\": true}"
    fi
}

cmd_config_validate() {
    if $JSON_MODE; then
        config_load
        if config_validate 2>/dev/null; then
            json_envelope "config validate" "success" 0 "{\"valid\": true}"
        else
            json_envelope "config validate" "error" 4 "{\"valid\": false}"
            return 4
        fi
    else
        config_load
        config_validate
    fi
}

cmd_config_edit() {
    local editor="${EDITOR:-vi}"
    if [[ ! -f "$DSR_CONFIG_FILE" ]]; then
        log_error "Config file not found. Run: dsr config init"
        return 4
    fi
    exec "$editor" "$DSR_CONFIG_FILE"
}

# ============================================================================
# DOCTOR SUBCOMMAND
# ============================================================================

cmd_doctor() {
    local quick_mode=false
    local fix_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quick|-q)
                quick_mode=true
                shift
                ;;
            --fix|-f)
                fix_mode=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr doctor - System diagnostics

USAGE:
    dsr doctor [options]

OPTIONS:
    --quick, -q     Quick check (core deps + auth only)
    --fix, -f       Suggest fixes for issues found
    --json          JSON output (global flag)

CHECKS:
    Core (always run):
      - git, gh (auth status), jq, curl

    Build tools:
      - docker, act, ssh to build hosts

    Signing tools (if enabled):
      - minisign, syft

    Network:
      - api.github.com, github.com connectivity

    Config:
      - Configuration file validation

EXIT CODES:
    0  - All checks passed (or only warnings)
    3  - Critical errors found (missing core deps)

EXAMPLES:
    dsr doctor              Full diagnostics
    dsr doctor --quick      Core deps only
    dsr doctor --fix        Show remediation steps
    dsr doctor --json       Machine-readable output
EOF
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    log_info "Running system diagnostics..."
    $quick_mode && log_info "(quick mode - core checks only)"
    echo ""

    local errors=0
    local warnings=0
    local checks=()
    local fixes=()

    # Helper to escape JSON strings
    _json_escape() {
        printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\n/\\n/g'
    }

    # Helper to add a check result
    _add_check() {
        local name="$1"
        local status="$2"
        local details="$3"
        checks+=("{\"name\": \"$name\", \"status\": \"$status\"$details}")
    }

    # ========== CORE DEPENDENCIES ==========
    log_info "Core dependencies:"

    # Check git
    if command -v git &>/dev/null; then
        local git_ver
        git_ver=$(git --version | cut -d' ' -f3)
        _add_check "git" "ok" ", \"version\": \"$(_json_escape "$git_ver")\""
        log_ok "  git: $git_ver"
    else
        _add_check "git" "error" ", \"message\": \"not found\""
        log_error "  git: not found"
        fixes+=("Install git: apt install git OR brew install git")
        ((errors++))
    fi

    # Check gh
    if command -v gh &>/dev/null; then
        local gh_ver
        gh_ver=$(gh --version 2>/dev/null | head -1 | awk '{print $3}')
        if gh auth status &>/dev/null 2>&1; then
            local gh_user
            gh_user=$(gh api user --jq '.login' 2>/dev/null || echo "unknown")
            _add_check "gh" "ok" ", \"version\": \"$gh_ver\", \"authenticated\": true, \"user\": \"$gh_user\""
            log_ok "  gh: $gh_ver (authenticated as $gh_user)"
        else
            _add_check "gh" "error" ", \"version\": \"$gh_ver\", \"authenticated\": false"
            log_error "  gh: not authenticated"
            fixes+=("Authenticate GitHub CLI: gh auth login")
            ((errors++))
        fi
    else
        _add_check "gh" "error" ", \"message\": \"not found\""
        log_error "  gh: not found"
        fixes+=("Install GitHub CLI: brew install gh OR apt install gh")
        ((errors++))
    fi

    # Check jq
    if command -v jq &>/dev/null; then
        local jq_ver
        jq_ver=$(jq --version 2>/dev/null | sed 's/jq-//')
        _add_check "jq" "ok" ", \"version\": \"$jq_ver\""
        log_ok "  jq: $jq_ver"
    else
        _add_check "jq" "error" ", \"message\": \"not found\""
        log_error "  jq: not found"
        fixes+=("Install jq: brew install jq OR apt install jq")
        ((errors++))
    fi

    # Check curl
    if command -v curl &>/dev/null; then
        local curl_ver
        curl_ver=$(curl --version 2>/dev/null | head -1 | awk '{print $2}')
        _add_check "curl" "ok" ", \"version\": \"$curl_ver\""
        log_ok "  curl: $curl_ver"
    else
        _add_check "curl" "error" ", \"message\": \"not found\""
        log_error "  curl: not found"
        fixes+=("Install curl: apt install curl")
        ((errors++))
    fi

    # Check yq (needed for config operations)
    if command -v yq &>/dev/null; then
        local yq_ver
        yq_ver=$(yq --version 2>/dev/null | awk '{print $NF}')
        _add_check "yq" "ok" ", \"version\": \"$yq_ver\""
        log_ok "  yq: $yq_ver"
    else
        _add_check "yq" "warning" ", \"message\": \"not found\""
        log_warn "  yq: not found (needed for config operations)"
        fixes+=("Install yq: brew install yq OR snap install yq")
        ((warnings++))
    fi

    # Quick mode stops here
    if $quick_mode; then
        echo ""
        _doctor_summary "$errors" "$warnings" "$fix_mode"
        [[ $errors -eq 0 ]] && return 0 || return 3
    fi

    # ========== BUILD TOOLS ==========
    echo ""
    log_info "Build tools:"

    # Check docker
    if command -v docker &>/dev/null; then
        if docker info &>/dev/null 2>&1; then
            local docker_ver
            docker_ver=$(docker --version 2>/dev/null | awk '{print $3}' | tr -d ',')
            _add_check "docker" "ok" ", \"version\": \"$docker_ver\", \"running\": true"
            log_ok "  docker: $docker_ver (running)"
        else
            _add_check "docker" "warning" ", \"running\": false"
            log_warn "  docker: installed but not running"
            fixes+=("Start Docker: systemctl start docker OR open Docker Desktop")
            ((warnings++))
        fi
    else
        _add_check "docker" "warning" ", \"message\": \"not found\""
        log_warn "  docker: not found (needed for act)"
        fixes+=("Install Docker: https://docs.docker.com/get-docker/")
        ((warnings++))
    fi

    # Check act
    if command -v act &>/dev/null; then
        local act_ver
        act_ver=$(act --version 2>/dev/null | head -1)
        _add_check "act" "ok" ", \"version\": \"$(_json_escape "$act_ver")\""
        log_ok "  act: $act_ver"
    else
        _add_check "act" "warning" ", \"message\": \"not found\""
        log_warn "  act: not found (needed for local builds)"
        fixes+=("Install act: brew install act OR https://github.com/nektos/act/releases")
        ((warnings++))
    fi

    # Check SSH
    if command -v ssh &>/dev/null; then
        _add_check "ssh" "ok" ""
        log_ok "  ssh: available"
    else
        _add_check "ssh" "warning" ", \"message\": \"not found\""
        log_warn "  ssh: not found (needed for remote builds)"
        ((warnings++))
    fi

    # ========== SSH TO BUILD HOSTS ==========
    echo ""
    log_info "Build hosts:"

    for host in mmini wlap; do
        if timeout 5 ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" "echo ok" &>/dev/null 2>&1; then
            _add_check "ssh-$host" "ok" ""
            log_ok "  $host: reachable"
        else
            _add_check "ssh-$host" "warning" ", \"message\": \"unreachable\""
            log_warn "  $host: unreachable"
            fixes+=("Check SSH config for $host: ssh $host")
            ((warnings++))
        fi
    done

    # ========== SIGNING TOOLS ==========
    echo ""
    log_info "Signing tools:"

    # Check minisign
    if command -v minisign &>/dev/null; then
        local minisign_ver
        minisign_ver=$(minisign -v 2>&1 | head -1 || echo "unknown")
        _add_check "minisign" "ok" ", \"version\": \"$(_json_escape "$minisign_ver")\""
        log_ok "  minisign: available"

        # Check if key exists
        if [[ -f "${SIGNING_PRIVATE_KEY:-$HOME/.config/dsr/secrets/minisign.key}" ]]; then
            _add_check "minisign-key" "ok" ""
            log_ok "  minisign key: configured"
        else
            _add_check "minisign-key" "warning" ", \"message\": \"not configured\""
            log_warn "  minisign key: not configured"
            fixes+=("Generate signing key: dsr signing init")
            ((warnings++))
        fi
    else
        _add_check "minisign" "warning" ", \"message\": \"not found\""
        log_warn "  minisign: not found (needed for signing)"
        fixes+=("Install minisign: brew install minisign")
        ((warnings++))
    fi

    # Check syft (SBOM generation)
    if command -v syft &>/dev/null; then
        local syft_ver
        syft_ver=$(syft --version 2>/dev/null | head -1 || echo "unknown")
        _add_check "syft" "ok" ", \"version\": \"$(_json_escape "$syft_ver")\""
        log_ok "  syft: $syft_ver"
    else
        _add_check "syft" "warning" ", \"message\": \"not found\""
        log_warn "  syft: not found (needed for SBOM generation)"
        fixes+=("Install syft: brew install syft OR https://github.com/anchore/syft/releases")
        ((warnings++))
    fi

    # ========== NETWORK CONNECTIVITY ==========
    echo ""
    log_info "Network connectivity:"

    # Check api.github.com
    if curl -sf --max-time 5 "https://api.github.com" >/dev/null 2>&1; then
        _add_check "network-api.github.com" "ok" ""
        log_ok "  api.github.com: reachable"
    else
        _add_check "network-api.github.com" "warning" ", \"message\": \"unreachable\""
        log_warn "  api.github.com: unreachable"
        fixes+=("Check network connectivity to GitHub")
        ((warnings++))
    fi

    # Check github.com
    if curl -sf --max-time 5 "https://github.com" >/dev/null 2>&1; then
        _add_check "network-github.com" "ok" ""
        log_ok "  github.com: reachable"
    else
        _add_check "network-github.com" "warning" ", \"message\": \"unreachable\""
        log_warn "  github.com: unreachable"
        ((warnings++))
    fi

    # ========== DISK SPACE ==========
    echo ""
    log_info "Disk space:"

    local disk_avail_kb disk_avail_gb
    disk_avail_kb=$(df -k . 2>/dev/null | tail -1 | awk '{print $4}')
    if [[ -n "$disk_avail_kb" ]]; then
        disk_avail_gb=$((disk_avail_kb / 1024 / 1024))
        if [[ $disk_avail_gb -lt 5 ]]; then
            _add_check "disk-local" "warning" ", \"available_gb\": $disk_avail_gb"
            log_warn "  local: ${disk_avail_gb}GB available (low)"
            fixes+=("Free up disk space (< 5GB available)")
            ((warnings++))
        else
            _add_check "disk-local" "ok" ", \"available_gb\": $disk_avail_gb"
            log_ok "  local: ${disk_avail_gb}GB available"
        fi
    fi

    # ========== CONFIG ==========
    echo ""
    log_info "Configuration:"

    config_load 2>/dev/null || true
    if config_validate &>/dev/null 2>&1; then
        _add_check "config" "ok" ""
        log_ok "  config: valid"
    else
        _add_check "config" "warning" ", \"message\": \"invalid or missing\""
        log_warn "  config: invalid or missing"
        fixes+=("Initialize config: dsr config init")
        ((warnings++))
    fi

    # Summary
    echo ""
    _doctor_summary "$errors" "$warnings" "$fix_mode"
    [[ $errors -eq 0 ]] && return 0 || return 3
}

# Doctor summary helper - called at end to print summary and JSON output
# Uses global arrays: checks[], fixes[]
_doctor_summary() {
    local errors="$1"
    local warnings="$2"
    local fix_mode="$3"

    local exit_code=0
    local overall_status="healthy"

    if [[ $errors -gt 0 ]]; then
        log_error "Found $errors error(s), $warnings warning(s)"
        exit_code=3
        overall_status="unhealthy"
    elif [[ $warnings -gt 0 ]]; then
        log_warn "Found $warnings warning(s)"
        overall_status="degraded"
    else
        log_ok "All checks passed"
    fi

    # Show fixes if requested
    if [[ "$fix_mode" == "true" && ${#fixes[@]} -gt 0 ]]; then
        echo ""
        log_info "Suggested fixes:"
        for fix in "${fixes[@]}"; do
            log_info "  → $fix"
        done
    fi

    if $JSON_MODE; then
        local checks_json details_json
        checks_json=$(printf '%s\n' "${checks[@]}" | jq -sc '.')
        details_json=$(jq -nc \
            --argjson errors "$errors" \
            --argjson warnings "$warnings" \
            --arg overall_status "$overall_status" \
            --argjson checks "$checks_json" \
            '{
                overall_status: $overall_status,
                errors: $errors,
                warnings: $warnings,
                checks: $checks
            }')
        local status_str
        [[ "$errors" -eq 0 ]] && status_str="success" || status_str="error"
        json_envelope "doctor" "$status_str" "$exit_code" "$details_json"
    fi
}

# ============================================================================
# STUB COMMANDS (to be implemented)
# ============================================================================

# ============================================================================
# CHECK SUBCOMMAND
# ============================================================================

cmd_check() {
    local repos=()
    local threshold=600  # 10 minutes in seconds
    local check_all=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repos|-r)
                IFS=',' read -ra repos <<< "$2"
                shift 2
                ;;
            --threshold|-t)
                threshold="$2"
                shift 2
                ;;
            --all|-a)
                check_all=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr check - Detect throttled GitHub Actions runs

USAGE:
    dsr check <repo>
    dsr check --repos repo1,repo2
    dsr check --all

OPTIONS:
    -r, --repos <list>      Comma-separated repos (e.g., ntm,bv)
    -t, --threshold <sec>   Queue time threshold in seconds (default: 600)
    -a, --all               Check all configured repos
    --json                  JSON output (global flag)

EXAMPLES:
    dsr check Dicklesworthstone/ntm
    dsr check --repos ntm,bv --threshold 300
    dsr check --all --json

EXIT CODES:
    0  - No throttling detected
    1  - Throttling detected
    3  - Dependency error (gh not authenticated)
    4  - Invalid arguments
    8  - Network/API error
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr check --help' for usage"
                return 4
                ;;
            *)
                # Positional argument - repo
                repos+=("$1")
                shift
                ;;
        esac
    done

    # Load config for --all option
    if $check_all; then
        config_load 2>/dev/null || true
        # Get repos from config (parse repos.yaml)
        local repos_file="$DSR_CONFIG_DIR/repos.yaml"
        if [[ -f "$repos_file" ]]; then
            while IFS= read -r repo; do
                [[ -n "$repo" ]] && repos+=("$repo")
            done < <(grep -E '^\s+repo:' "$repos_file" 2>/dev/null | sed 's/.*repo:\s*//' | tr -d '"' || true)
        fi
    fi

    # Validate we have repos to check
    if [[ ${#repos[@]} -eq 0 ]]; then
        log_error "No repos specified. Use: dsr check <repo> or --all"
        return 4
    fi

    # Check dependencies
    if ! gh_check 2>/dev/null; then
        if ! gh_check_token 2>/dev/null; then
            if $JSON_MODE; then
                json_envelope "check" "error" 3 '{"error": "GitHub authentication required"}'
            fi
            return 3
        fi
    fi

    # Process each repo
    local any_throttled=false
    local results=()
    local now
    now=$(date +%s)

    for repo in "${repos[@]}"; do
        local result
        result=$(_check_repo "$repo" "$threshold" "$now")
        local status=$?

        if [[ $status -eq 1 ]]; then
            any_throttled=true
        fi

        results+=("$result")

        if ! $JSON_MODE; then
            _check_print_result "$result"
        fi
    done

    # JSON output
    if $JSON_MODE; then
        local results_json
        results_json=$(printf '%s\n' "${results[@]}" | jq -sc '.')
        local summary_status="ok"
        $any_throttled && summary_status="throttled"
        json_envelope "check" "$summary_status" "$($any_throttled && echo 1 || echo 0)" \
            "$(jq -nc --argjson repos "$results_json" --argjson threshold "$threshold" \
                '{threshold_seconds: $threshold, repos: $repos}')"
    fi

    $any_throttled && return 1 || return 0
}

# Check a single repo for throttling
# Returns JSON result, exit code 1 if throttled
_check_repo() {
    local repo="$1"
    local threshold="$2"
    local now="$3"

    # Resolve short repo name to owner/repo
    if [[ ! "$repo" =~ / ]]; then
        # Assume Dicklesworthstone if no owner specified
        repo="Dicklesworthstone/$repo"
    fi

    # Fetch workflow runs
    local runs_json
    runs_json=$(gh_workflow_runs "$repo" --limit 20 2>/dev/null)
    local fetch_status=$?

    if [[ $fetch_status -ne 0 ]] || [[ -z "$runs_json" ]]; then
        echo '{"repo": "'"$repo"'", "status": "error", "error": "failed to fetch runs"}'
        return 8
    fi

    # Extract and analyze runs
    local queued_runs stuck_runs
    queued_runs=$(echo "$runs_json" | jq -c --argjson now "$now" --argjson threshold "$threshold" '
        .workflow_runs // [] |
        map(select(.status == "queued")) |
        map(. as $run |
            ($now - ($run.created_at | fromdateiso8601 // $now)) as $age |
            select($age > $threshold) |
            {
                id: .id,
                status: .status,
                created_at: .created_at,
                workflow_id: .workflow_id,
                workflow_name: .name,
                event: .event,
                html_url: .html_url,
                age_seconds: $age
            }
        )' 2>/dev/null || echo '[]')

    stuck_runs=$(echo "$runs_json" | jq -c --argjson now "$now" --argjson threshold "$threshold" '
        .workflow_runs // [] |
        map(select(.status == "in_progress")) |
        map(. as $run |
            ($run.run_started_at // $run.created_at) as $start_time |
            ($now - ($start_time | fromdateiso8601 // $now)) as $age |
            select($age > $threshold) |
            {
                id: .id,
                status: .status,
                created_at: .created_at,
                run_started_at: .run_started_at,
                workflow_id: .workflow_id,
                workflow_name: .name,
                event: .event,
                html_url: .html_url,
                age_seconds: $age
            }
        )' 2>/dev/null || echo '[]')

    # Count issues
    local queued_count stuck_count
    queued_count=$(echo "$queued_runs" | jq 'length')
    stuck_count=$(echo "$stuck_runs" | jq 'length')

    # Determine oldest queued time
    local oldest_queued_sec=0
    if [[ "$queued_count" -gt 0 ]]; then
        oldest_queued_sec=$(echo "$queued_runs" | jq '[.[].age_seconds] | max // 0')
    fi

    # Build result
    local status="ok"
    if [[ "$queued_count" -gt 0 ]] || [[ "$stuck_count" -gt 0 ]]; then
        status="throttled"
    fi

    jq -nc \
        --arg repo "$repo" \
        --arg status "$status" \
        --argjson threshold "$threshold" \
        --argjson queued_count "$queued_count" \
        --argjson stuck_count "$stuck_count" \
        --argjson oldest_queued_sec "$oldest_queued_sec" \
        --argjson queued_runs "$queued_runs" \
        --argjson stuck_runs "$stuck_runs" \
        '{
            repo: $repo,
            status: $status,
            threshold_seconds: $threshold,
            queued_count: $queued_count,
            stuck_in_progress_count: $stuck_count,
            oldest_queued_seconds: $oldest_queued_sec,
            oldest_queued_minutes: (($oldest_queued_sec / 60) | floor),
            queued_runs: $queued_runs,
            stuck_runs: $stuck_runs
        }'

    [[ "$status" == "throttled" ]] && return 1 || return 0
}

# Print human-readable check result
_check_print_result() {
    local result="$1"

    local repo status queued stuck oldest_min
    repo=$(echo "$result" | jq -r '.repo')
    status=$(echo "$result" | jq -r '.status')
    queued=$(echo "$result" | jq -r '.queued_count')
    stuck=$(echo "$result" | jq -r '.stuck_in_progress_count')
    oldest_min=$(echo "$result" | jq -r '.oldest_queued_minutes')

    if [[ "$status" == "error" ]]; then
        log_error "$repo: $(echo "$result" | jq -r '.error // "unknown error"')"
    elif [[ "$status" == "throttled" ]]; then
        log_warn "$repo: THROTTLED"
        [[ "$queued" -gt 0 ]] && log_warn "  - $queued runs queued (oldest: ${oldest_min}m)"
        [[ "$stuck" -gt 0 ]] && log_warn "  - $stuck runs stuck in_progress"

        # Show URLs for queued runs
        echo "$result" | jq -r '.queued_runs[:3][] | "    → \(.html_url)"' 2>/dev/null | while read -r url; do
            log_info "$url"
        done
    else
        log_ok "$repo: OK (no throttling detected)"
    fi
}

cmd_watch() {
    log_warn "watch command not yet implemented"
    log_info "See bead bd-1jt.1.2 for implementation plan"
    return 4
}

cmd_build() {
    log_warn "build command not yet implemented"
    log_info "See bead bd-1jt.2.1 for implementation plan"
    return 4
}

cmd_release() {
    log_warn "release command not yet implemented"
    log_info "See bead bd-1jt.3.1 for implementation plan"
    return 4
}

cmd_fallback() {
    log_warn "fallback command not yet implemented"
    log_info "See bead bd-1jt.1.4 for implementation plan"
    return 4
}

cmd_repos() {
    local subcmd="${1:-list}"
    shift 2>/dev/null || true

    case "$subcmd" in
        list)
            cmd_repos_list "$@"
            ;;
        add)
            cmd_repos_add "$@"
            ;;
        remove)
            cmd_repos_remove "$@"
            ;;
        info)
            cmd_repos_info "$@"
            ;;
        validate)
            cmd_repos_validate "$@"
            ;;
        discover)
            cmd_repos_discover "$@"
            ;;
        sync)
            cmd_repos_sync "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr repos - Manage repository registry

USAGE:
    dsr repos <subcommand> [options]

SUBCOMMANDS:
    list        List all registered repositories
    add         Add a repository to the registry
    remove      Remove a repository from the registry
    info        Show detailed info for a repository
    validate    Validate repository configurations
    discover    Discover repos that could benefit from dsr
    sync        Sync repository metadata from GitHub

OPTIONS:
    --json      Output in JSON format (global)

EXAMPLES:
    dsr repos list                          List all repos
    dsr repos add ntm --local-path /data/projects/ntm
    dsr repos add dicklesworthstone/bv
    dsr repos remove ntm
    dsr repos info ntm --json
    dsr repos validate
    dsr repos discover --path /data/projects

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            log_error "Unknown repos subcommand: $subcmd"
            log_info "Run 'dsr repos --help' for usage"
            return 4
            ;;
    esac
}

# List all registered repositories
cmd_repos_list() {
    local format="table"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format|-f)
                format="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Load repos config
    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found: $DSR_REPOS_FILE"
        log_info "Run: dsr config init"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 '{"action": "list", "repos": [], "errors": [{"code": "E052", "message": "repos file not found"}]}'
        fi
        return 4
    fi

    local repos_json="[]"
    if command -v yq &>/dev/null; then
        repos_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null | jq -c '
            to_entries | map({
                name: .key,
                repo: (.value.repo // ""),
                local_path: (.value.local_path // ""),
                language: (.value.language // ""),
                targets: (.value.targets // []),
                workflow: (.value.workflow // ""),
                enabled: (.value.enabled // true)
            })
        ' 2>/dev/null || echo "[]")
    else
        # Fallback: simple parsing without yq
        repos_json="[]"
        log_warn "yq not found. Install yq for full repos functionality."
    fi

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson repos "$repos_json" '{action: "list", repos: $repos}')"
    else
        local count
        count=$(echo "$repos_json" | jq 'length')

        if [[ "$count" -eq 0 ]]; then
            log_info "No repositories registered."
            log_info "Run: dsr repos add <owner/repo> --local-path <path>"
            return 0
        fi

        log_info "Registered repositories ($count):"
        echo ""

        if [[ "$format" == "table" ]]; then
            printf "%-12s %-30s %-10s %s\n" "NAME" "REPO" "LANGUAGE" "TARGETS"
            printf "%s\n" "$(printf '%.0s-' {1..80})"
            echo "$repos_json" | jq -r '.[] | [.name, .repo, .language, (.targets | join(","))] | @tsv' | \
                while IFS=$'\t' read -r name repo lang targets; do
                    printf "%-12s %-30s %-10s %s\n" "$name" "$repo" "${lang:-?}" "${targets:-all}"
                done
        else
            echo "$repos_json" | jq -r '.[] | "\(.name): \(.repo)"'
        fi
    fi
}

# Add a repository to the registry
cmd_repos_add() {
    local repo_input=""
    local local_path=""
    local language=""
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --local-path|-p)
                local_path="$2"
                shift 2
                ;;
            --language|-l)
                language="$2"
                shift 2
                ;;
            --name|-n)
                name="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                return 4
                ;;
            *)
                repo_input="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$repo_input" ]]; then
        log_error "Usage: dsr repos add <owner/repo|name> [--local-path <path>] [--language <lang>]"
        return 4
    fi

    # Parse repo input - could be "owner/repo" or just "name"
    local repo
    if [[ "$repo_input" =~ / ]]; then
        repo="$repo_input"
        [[ -z "$name" ]] && name="${repo_input#*/}"
    else
        name="$repo_input"
        repo=""
    fi

    # Validate local_path if provided
    if [[ -n "$local_path" ]]; then
        # Source guardrails for path resolution
        source "$SCRIPT_DIR/src/guardrails.sh"
        local_path=$(resolve_path "$local_path" 2>&1) || {
            log_error "Invalid local path: $local_path"
            if $JSON_MODE; then
                json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "add", repo: $name, errors: [{code: "E052", message: "invalid local path"}]}')"
            fi
            return 4
        }

        # Auto-detect language if not specified
        if [[ -z "$language" && -d "$local_path" ]]; then
            if [[ -f "$local_path/Cargo.toml" ]]; then
                language="rust"
            elif [[ -f "$local_path/go.mod" ]]; then
                language="go"
            elif [[ -f "$local_path/package.json" ]]; then
                if [[ -f "$local_path/bun.lockb" ]]; then
                    language="bun"
                else
                    language="node"
                fi
            elif [[ -f "$local_path/pyproject.toml" || -f "$local_path/setup.py" ]]; then
                language="python"
            fi
        fi

        # Auto-detect repo from git remote if not specified
        if [[ -z "$repo" && -d "$local_path/.git" ]]; then
            local remote_url
            remote_url=$(git -C "$local_path" remote get-url origin 2>/dev/null || true)
            if [[ -n "$remote_url" ]]; then
                # Parse owner/repo from git URL
                repo=$(echo "$remote_url" | sed -E 's#.*(github\.com[:/])([^/]+/[^/]+)(\.git)?$#\2#')
                repo="${repo%.git}"
            fi
        fi
    fi

    # Check if yq is available for writing
    if ! command -v yq &>/dev/null; then
        log_error "yq is required to add repositories"
        log_info "Install: brew install yq  OR  apt install yq"
        if $JSON_MODE; then
            json_envelope "repos" "error" 3 '{"action": "add", "errors": [{"code": "E041", "message": "yq required"}]}'
        fi
        return 3
    fi

    # Ensure repos file exists
    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_warn "Repos file not found, running config init..."
        config_init >/dev/null 2>&1
    fi

    # Check if already exists
    local existing
    existing=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    if [[ "$existing" != "null" && -n "$existing" ]]; then
        log_error "Repository '$name' already exists"
        log_info "Use 'dsr repos remove $name' first, or choose a different name"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "add", repo: $name, errors: [{code: "E052", message: "repo already exists"}]}')"
        fi
        return 4
    fi

    # Build the tool entry
    local tool_yaml=""
    tool_yaml+="repo: \"${repo:-}\""
    [[ -n "$local_path" ]] && tool_yaml+="\n    local_path: \"$local_path\""
    [[ -n "$language" ]] && tool_yaml+="\n    language: \"$language\""
    tool_yaml+="\n    targets:\n      - linux/amd64\n      - darwin/arm64\n      - windows/amd64"

    # Add to repos.yaml using yq
    yq -i ".tools.$name = {}" "$DSR_REPOS_FILE"
    [[ -n "$repo" ]] && yq -i ".tools.$name.repo = \"$repo\"" "$DSR_REPOS_FILE"
    [[ -n "$local_path" ]] && yq -i ".tools.$name.local_path = \"$local_path\"" "$DSR_REPOS_FILE"
    [[ -n "$language" ]] && yq -i ".tools.$name.language = \"$language\"" "$DSR_REPOS_FILE"
    yq -i ".tools.$name.targets = [\"linux/amd64\", \"darwin/arm64\", \"windows/amd64\"]" "$DSR_REPOS_FILE"

    if $JSON_MODE; then
        local added_json
        added_json=$(jq -nc \
            --arg name "$name" \
            --arg repo "${repo:-}" \
            --arg local_path "${local_path:-}" \
            --arg language "${language:-}" \
            '{name: $name, repo: $repo, local_path: $local_path, language: $language, targets: ["linux/amd64", "darwin/arm64", "windows/amd64"]}')
        json_envelope "repos" "success" 0 "$(jq -nc --argjson added "[$added_json]" '{action: "add", added: $added}')"
    else
        log_ok "Added repository: $name"
        [[ -n "$repo" ]] && log_info "  repo: $repo"
        [[ -n "$local_path" ]] && log_info "  local_path: $local_path"
        [[ -n "$language" ]] && log_info "  language: $language"
    fi
}

# Remove a repository from the registry
cmd_repos_remove() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: dsr repos remove <name>"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq is required to remove repositories"
        if $JSON_MODE; then
            json_envelope "repos" "error" 3 '{"action": "remove", "errors": [{"code": "E041", "message": "yq required"}]}'
        fi
        return 3
    fi

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    # Check if exists
    local existing
    existing=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    if [[ "$existing" == "null" || -z "$existing" ]]; then
        log_error "Repository '$name' not found"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "remove", repo: $name, errors: [{code: "E052", message: "repo not found"}]}')"
        fi
        return 4
    fi

    # Remove from repos.yaml
    yq -i "del(.tools.$name)" "$DSR_REPOS_FILE"

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --arg name "$name" '{action: "remove", removed: [{name: $name}]}')"
    else
        log_ok "Removed repository: $name"
    fi
}

# Show detailed info for a repository
cmd_repos_info() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: dsr repos info <name>"
        return 4
    fi

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    local tool_yaml
    if command -v yq &>/dev/null; then
        tool_yaml=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    else
        log_error "yq required for repos info"
        return 3
    fi

    if [[ "$tool_yaml" == "null" || -z "$tool_yaml" ]]; then
        log_error "Repository '$name' not found"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "info", repo: $name, errors: [{code: "E052", message: "repo not found"}]}')"
        fi
        return 4
    fi

    local tool_json
    tool_json=$(yq -o=json ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null | jq -c --arg name "$name" '. + {name: $name}')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson repos "[$tool_json]" --arg name "$name" '{action: "info", repo: $name, repos: $repos}')"
    else
        log_info "Repository: $name"
        echo ""
        echo "$tool_json" | jq -r 'to_entries[] | "  \(.key): \(.value)"'
    fi
}

# Validate repository configurations
cmd_repos_validate() {
    local repo_filter="${1:-}"

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq required for validation"
        return 3
    fi

    local tools_json
    tools_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null)

    local results=()
    local errors=0
    local warnings=0

    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        [[ -n "$repo_filter" && "$name" != "$repo_filter" ]] && continue

        local tool_json
        tool_json=$(echo "$tools_json" | jq -c --arg name "$name" '.[$name]')

        local status="ok"
        local messages=()

        # Check required fields
        local repo local_path
        repo=$(echo "$tool_json" | jq -r '.repo // ""')
        local_path=$(echo "$tool_json" | jq -r '.local_path // ""')

        if [[ -z "$repo" && -z "$local_path" ]]; then
            status="error"
            messages+=("Missing both 'repo' and 'local_path' - need at least one")
            ((errors++))
        fi

        # Check local_path exists
        if [[ -n "$local_path" ]]; then
            source "$SCRIPT_DIR/src/guardrails.sh"
            local resolved_path
            resolved_path=$(resolve_path "$local_path" 2>/dev/null) || {
                status="error"
                messages+=("Invalid local_path: $local_path")
                ((errors++))
            }
            if [[ -n "$resolved_path" && ! -d "$resolved_path" ]]; then
                status="warn"
                messages+=("local_path does not exist: $resolved_path")
                ((warnings++))
            fi
        fi

        # Check workflow file exists
        local workflow
        workflow=$(echo "$tool_json" | jq -r '.workflow // ""')
        if [[ -n "$workflow" && -n "$local_path" ]]; then
            source "$SCRIPT_DIR/src/guardrails.sh"
            local resolved_path
            resolved_path=$(resolve_path "$local_path" 2>/dev/null) || true
            if [[ -n "$resolved_path" && ! -f "$resolved_path/$workflow" ]]; then
                if [[ "$status" != "error" ]]; then
                    status="warn"
                fi
                messages+=("Workflow file not found: $workflow")
                ((warnings++))
            fi
        fi

        local msg_str=""
        [[ ${#messages[@]} -gt 0 ]] && msg_str=$(IFS='; '; echo "${messages[*]}")

        results+=("$(jq -nc --arg repo "$name" --arg status "$status" --arg message "$msg_str" \
            '{repo: $repo, status: $status, message: $message}')")

        if ! $JSON_MODE; then
            if [[ "$status" == "ok" ]]; then
                log_ok "$name: OK"
            elif [[ "$status" == "warn" ]]; then
                log_warn "$name: $msg_str"
            else
                log_error "$name: $msg_str"
            fi
        fi

    done < <(echo "$tools_json" | jq -r 'keys[]')

    local results_json
    results_json=$(printf '%s\n' "${results[@]}" | jq -sc '.')

    if $JSON_MODE; then
        local status="success"
        local exit_code=0
        if [[ $errors -gt 0 ]]; then
            status="error"
            exit_code=1
        elif [[ $warnings -gt 0 ]]; then
            status="partial"
        fi
        json_envelope "repos" "$status" "$exit_code" "$(jq -nc --argjson validated "$results_json" '{action: "validate", validated: $validated}')"
    else
        echo ""
        if [[ $errors -gt 0 ]]; then
            log_error "Validation found $errors error(s), $warnings warning(s)"
            return 1
        elif [[ $warnings -gt 0 ]]; then
            log_warn "Validation found $warnings warning(s)"
        else
            log_ok "All repositories validated successfully"
        fi
    fi
}

# Discover repositories that could benefit from dsr
cmd_repos_discover() {
    local search_path="/data/projects"
    local apply=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --path|-p)
                search_path="$2"
                shift 2
                ;;
            --apply)
                apply=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Validate search path
    source "$SCRIPT_DIR/src/guardrails.sh"
    search_path=$(resolve_path "$search_path" --must-exist 2>&1) || {
        log_error "Invalid search path: $search_path"
        return 4
    }

    log_info "Scanning $search_path for buildable projects..."

    local discovered=()

    # Find directories with build files
    while IFS= read -r dir; do
        local name
        name=$(basename "$dir")
        local language=""
        local repo=""

        # Detect language
        if [[ -f "$dir/Cargo.toml" ]]; then
            language="rust"
        elif [[ -f "$dir/go.mod" ]]; then
            language="go"
        elif [[ -f "$dir/package.json" ]]; then
            language="node"
        else
            continue
        fi

        # Get repo from git remote
        if [[ -d "$dir/.git" ]]; then
            local remote_url
            remote_url=$(git -C "$dir" remote get-url origin 2>/dev/null || true)
            if [[ -n "$remote_url" ]]; then
                repo=$(echo "$remote_url" | sed -E 's#.*(github\.com[:/])([^/]+/[^/]+)(\.git)?$#\2#')
                repo="${repo%.git}"
            fi
        fi

        # Check if has release workflow
        local has_workflow=false
        if [[ -d "$dir/.github/workflows" ]]; then
            if grep -l -E 'release|build' "$dir/.github/workflows/"*.yml "$dir/.github/workflows/"*.yaml 2>/dev/null | head -1 >/dev/null; then
                has_workflow=true
            fi
        fi

        local entry
        entry=$(jq -nc \
            --arg name "$name" \
            --arg repo "${repo:-}" \
            --arg local_path "$dir" \
            --arg language "$language" \
            --argjson has_workflow "$has_workflow" \
            '{name: $name, repo: $repo, local_path: $local_path, language: $language, has_workflow: $has_workflow}')

        discovered+=("$entry")

        if ! $JSON_MODE; then
            local workflow_indicator="  "
            $has_workflow && workflow_indicator="✓ "
            log_info "$workflow_indicator$name ($language) - $dir"
        fi

    done < <(find "$search_path" -maxdepth 2 -type f \( -name "Cargo.toml" -o -name "go.mod" -o -name "package.json" \) -print0 2>/dev/null | xargs -0 -I{} dirname {} | sort -u)

    local discovered_json
    discovered_json=$(printf '%s\n' "${discovered[@]}" | jq -sc '.')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson discovered "$discovered_json" '{action: "discover", discovered: $discovered}')"
    else
        echo ""
        local count
        count=$(echo "$discovered_json" | jq 'length')
        log_info "Discovered $count potential repositories"
        if [[ $count -gt 0 ]] && ! $apply; then
            log_info "Run with --apply to add them to the registry"
        fi
    fi

    # Apply if requested
    if $apply && [[ ${#discovered[@]} -gt 0 ]]; then
        log_info "Adding discovered repositories..."
        for entry in "${discovered[@]}"; do
            local name repo local_path language
            name=$(echo "$entry" | jq -r '.name')
            repo=$(echo "$entry" | jq -r '.repo // ""')
            local_path=$(echo "$entry" | jq -r '.local_path')
            language=$(echo "$entry" | jq -r '.language')

            cmd_repos_add "$name" --local-path "$local_path" --language "$language" 2>/dev/null || true
        done
    fi
}

# Sync repository metadata from GitHub
cmd_repos_sync() {
    log_info "Syncing repository metadata from GitHub..."

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq required for sync"
        return 3
    fi

    local tools_json
    tools_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null)

    local synced=0
    local failed=0

    while IFS= read -r name; do
        [[ -z "$name" ]] && continue

        local repo
        repo=$(echo "$tools_json" | jq -r --arg name "$name" '.[$name].repo // ""')

        if [[ -z "$repo" ]]; then
            log_warn "$name: no repo configured, skipping"
            continue
        fi

        log_info "Syncing $name ($repo)..."

        # Fetch repo info from GitHub
        if gh_check 2>/dev/null || gh_check_token 2>/dev/null; then
            local repo_info
            repo_info=$(gh_repo "$repo" 2>/dev/null) || {
                log_warn "$name: failed to fetch repo info"
                ((failed++))
                continue
            }

            local default_branch
            default_branch=$(echo "$repo_info" | jq -r '.default_branch // "main"')

            # Update the entry with synced data
            yq -i ".tools.$name.default_branch = \"$default_branch\"" "$DSR_REPOS_FILE"
            ((synced++))
            log_ok "$name: synced (default_branch: $default_branch)"
        else
            log_warn "$name: GitHub auth not available"
            ((failed++))
        fi

    done < <(echo "$tools_json" | jq -r 'keys[]')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson synced "$synced" --argjson failed "$failed" '{action: "sync", synced: $synced, failed: $failed}')"
    else
        echo ""
        log_info "Sync complete: $synced synced, $failed failed"
    fi
}

# ============================================================================
# HEALTH SUBCOMMAND
# ============================================================================

cmd_health() {
    local subcmd="${1:-check}"
    shift 2>/dev/null || true

    case "$subcmd" in
        check)
            cmd_health_check "$@"
            ;;
        all)
            cmd_health_all "$@"
            ;;
        clear-cache)
            cmd_health_clear_cache "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr health - Check health of build hosts

USAGE:
    dsr health <subcommand> [options]

SUBCOMMANDS:
    check <host>    Check specific host health
    all             Check all configured hosts
    clear-cache     Clear health check cache

OPTIONS:
    --no-cache      Skip cache and perform fresh checks
    --json          Output in JSON format (global)

CHECKS PERFORMED:
    - SSH connectivity (short timeout + BatchMode)
    - Disk space threshold (warn >90%, error >95%)
    - Toolchain availability (rust/go/bun per host)
    - Docker/Colima for act runners
    - Clock drift detection

EXAMPLES:
    dsr health check trj            Check local Threadripper
    dsr health check mmini          Check Mac Mini via SSH
    dsr health all                  Check all build hosts
    dsr health all --no-cache       Force fresh checks
    dsr health clear-cache          Clear cached results

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            # Treat as hostname if not a subcommand
            cmd_health_check "$subcmd" "$@"
            ;;
    esac
}

cmd_health_check() {
    local hostname="${1:-}"
    shift 2>/dev/null || true
    local no_cache=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-cache) no_cache=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$hostname" ]]; then
        log_error "Usage: dsr health check <hostname>"
        return 4
    fi

    local flags=""
    $no_cache && flags+=" --no-cache"
    $JSON_MODE && flags+=" --json"

    # shellcheck disable=SC2086  # flags needs word splitting
    host_health_check "$hostname" $flags
}

cmd_health_all() {
    local no_cache=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-cache) no_cache=true; shift ;;
            *) shift ;;
        esac
    done

    local flags=""
    $no_cache && flags+=" --no-cache"
    $JSON_MODE && flags+=" --json"

    # shellcheck disable=SC2086  # flags needs word splitting
    host_health_check_all $flags
}

cmd_health_clear_cache() {
    local hostname="${1:-}"
    host_health_clear_cache "$hostname"

    if $JSON_MODE; then
        if [[ -n "$hostname" ]]; then
            json_envelope "health" "success" 0 "{\"action\": \"clear-cache\", \"host\": \"$hostname\"}"
        else
            json_envelope "health" "success" 0 '{"action": "clear-cache", "all": true}'
        fi
    else
        if [[ -n "$hostname" ]]; then
            log_ok "Cleared health cache for: $hostname"
        else
            log_ok "Cleared all health cache"
        fi
    fi
}

# ============================================================================
# SIGNING SUBCOMMAND
# ============================================================================

cmd_signing() {
    local subcmd="${1:-check}"
    shift 2>/dev/null || true

    case "$subcmd" in
        init)
            signing_init "$@"
            ;;
        check)
            if $JSON_MODE; then
                signing_check --json
            else
                signing_check
            fi
            ;;
        sign)
            signing_sign "$@"
            ;;
        verify)
            signing_verify "$@"
            ;;
        fix)
            signing_fix_permissions
            ;;
        pubkey|public-key)
            signing_get_public_key "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr signing - Manage minisign keys and artifact signing

USAGE:
    dsr signing <subcommand> [options]

SUBCOMMANDS:
    init        Generate new keypair (interactive)
    check       Verify keypair is configured
    sign        Sign a file
    verify      Verify a file signature
    fix         Fix private key permissions
    pubkey      Display public key

EXAMPLES:
    dsr signing init              Generate new keypair
    dsr signing check             Check if keys are configured
    dsr signing sign artifact.tar.gz
    dsr signing verify artifact.tar.gz
    dsr signing pubkey --oneline  Get public key for embedding

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            log_error "Unknown signing subcommand: $subcmd"
            log_info "Run 'dsr signing --help' for usage"
            return 4
            ;;
    esac
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    # shellcheck disable=SC2034  # DRY_RUN/NON_INTERACTIVE reserved for future use
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json|-j)
                JSON_MODE=true
                shift
                ;;
            --dry-run|-n)
                DRY_RUN=true
                shift
                ;;
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            --quiet|-q)
                QUIET=true
                shift
                ;;
            --non-interactive|-y)
                NON_INTERACTIVE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -*)
                # Unknown option - might be command-specific
                break
                ;;
            *)
                # Not an option - must be command
                break
                ;;
        esac
    done

    # Initialize logging with appropriate level
    log_set_level_from_flags "$VERBOSE" "$QUIET"
    log_init

    # Get command
    local command="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$command" ]]; then
        show_help
        exit 0
    fi

    # Set command context for logging
    log_set_command "$command"

    # Dispatch to command handler
    case "$command" in
        config)
            cmd_config "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        check)
            cmd_check "$@"
            ;;
        watch)
            cmd_watch "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        release)
            cmd_release "$@"
            ;;
        fallback)
            cmd_fallback "$@"
            ;;
        repos)
            cmd_repos "$@"
            ;;
        health)
            cmd_health "$@"
            ;;
        signing)
            cmd_signing "$@"
            ;;
        help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown command: $command"
            log_info "Run 'dsr --help' for usage"
            exit 4
            ;;
    esac
}

main "$@"
