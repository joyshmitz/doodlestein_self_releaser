#!/usr/bin/env bash
# dsr - Doodlestein Self-Releaser
#
# Fallback release infrastructure for when GitHub Actions is throttled.
#
# Usage:
#   dsr <command> [options]
#
# Commands:
#   check     Detect throttled GitHub Actions runs
#   watch     Continuous monitoring daemon
#   build     Build artifacts locally
#   release   Upload artifacts to GitHub
#   fallback  Full pipeline: check -> build -> release
#   repos     Manage repository registry
#   health    Check health of build hosts
#   prune     Clean up old artifacts and cache
#   config    View/modify configuration
#   doctor    System diagnostics
#   signing   Manage minisign keys and signing
#
# Global Options:
#   --json, -j          Machine-readable JSON output
#   --non-interactive   Disable prompts (CI mode)
#   --dry-run, -n       Show planned actions without executing
#   --verbose, -v       Enable verbose logging
#   --quiet, -q         Suppress non-error output
#   --help, -h          Show help
#   --version           Show version

set -uo pipefail

# Version
DSR_VERSION="0.1.0"

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source modules (logging first, others may depend on it)
source "$SCRIPT_DIR/src/logging.sh"
source "$SCRIPT_DIR/src/config.sh"
source "$SCRIPT_DIR/src/secrets.sh"
source "$SCRIPT_DIR/src/notify.sh"
source "$SCRIPT_DIR/src/signing.sh"
source "$SCRIPT_DIR/src/github.sh"
source "$SCRIPT_DIR/src/host_health.sh"
source "$SCRIPT_DIR/src/host_selector.sh"
source "$SCRIPT_DIR/src/quality_gates.sh"
source "$SCRIPT_DIR/src/build_state.sh"
source "$SCRIPT_DIR/src/git_ops.sh"
source "$SCRIPT_DIR/src/version.sh"
source "$SCRIPT_DIR/src/act_runner.sh"

# Global flags
JSON_MODE=false
# shellcheck disable=SC2034  # Reserved for future use
DRY_RUN=false
VERBOSE=false
QUIET=false
# shellcheck disable=SC2034  # Reserved for future use
NON_INTERACTIVE=false

# Note: Colors and log functions are now provided by src/logging.sh
# The logging module provides: log_error, log_warn, log_info, log_debug, log_ok, log_timed

# Show help
show_help() {
    cat << 'EOF'
dsr - Doodlestein Self-Releaser

Fallback release infrastructure for when GitHub Actions is throttled.

USAGE:
    dsr <command> [options]

COMMANDS:
    check       Detect throttled GitHub Actions runs
    watch       Continuous monitoring daemon
    build       Build artifacts locally
    release     Upload artifacts to GitHub
    fallback    Full pipeline: check -> build -> release
    quality     Run pre-release quality checks
    repos       Manage repository registry
    health      Check health of build hosts
    prune       Clean up old artifacts and cache
    config      View/modify configuration
    doctor      System diagnostics
    signing     Manage minisign keys and signing
    status      System and last run summary
    version     Detect and tag versions from version files

GLOBAL OPTIONS:
    -j, --json          Machine-readable JSON output
    -y, --non-interactive   Disable prompts (CI mode)
    -n, --dry-run       Show planned actions without executing
    -v, --verbose       Enable verbose logging
    -q, --quiet         Suppress non-error output
    -h, --help          Show this help
        --version       Show version

EXAMPLES:
    dsr config init              Initialize configuration
    dsr config show              Show current configuration
    dsr check --repos ntm,bv     Check if repos are throttled
    dsr build --repo ntm         Build ntm locally
    dsr doctor                   Check system dependencies

For more information, see docs/CLI_CONTRACT.md
EOF
}

# Show version
show_version() {
    if $JSON_MODE; then
        echo "{\"tool\": \"dsr\", \"version\": \"$DSR_VERSION\"}"
    else
        echo "dsr version $DSR_VERSION"
    fi
}

# JSON envelope helper
# Usage: json_envelope <command> <status> <exit_code> [details_json]
json_envelope() {
    local cmd="$1"
    local vstatus="$2"  # renamed to avoid potential conflict
    local exit_code="$3"
    local details="${4:-"{}"}"
    local run_id
    run_id=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "unknown")
    local started_at
    started_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat << EOF
{
  "command": "$cmd",
  "status": "$vstatus",
  "exit_code": $exit_code,
  "run_id": "$run_id",
  "started_at": "$started_at",
  "duration_ms": 0,
  "tool": "dsr",
  "version": "$DSR_VERSION",
  "details": $details
}
EOF
}

# ============================================================================
# CONFIG SUBCOMMAND
# ============================================================================

cmd_config() {
    local subcmd="${1:-show}"
    shift 2>/dev/null || true

    case "$subcmd" in
        init)
            cmd_config_init "$@"
            ;;
        show)
            cmd_config_show "$@"
            ;;
        get)
            cmd_config_get "$@"
            ;;
        set)
            cmd_config_set "$@"
            ;;
        validate)
            cmd_config_validate "$@"
            ;;
        edit)
            cmd_config_edit "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr config - View and modify configuration

USAGE:
    dsr config <subcommand> [options]

SUBCOMMANDS:
    init        Initialize configuration directories and files
    show        Show current configuration
    get <key>   Get a specific config value
    set <k>=<v> Set a config value
    validate    Validate configuration files
    edit        Open config in $EDITOR

OPTIONS:
    --json      Output in JSON format
    --force     Overwrite existing files (init only)

EXAMPLES:
    dsr config init              Create default config files
    dsr config show              Show all configuration
    dsr config get threshold_seconds
    dsr config set log_level=debug
    dsr config validate
EOF
            ;;
        *)
            log_error "Unknown config subcommand: $subcmd"
            log_info "Run 'dsr config --help' for usage"
            return 4
            ;;
    esac
}

cmd_config_init() {
    local force=false
    [[ "${1:-}" == "--force" ]] && force=true

    if $JSON_MODE; then
        local status
        if $force; then
            config_init --force >/dev/null 2>&1
            status=$?
        else
            config_init >/dev/null 2>&1
            status=$?
        fi
        if [[ $status -eq 0 ]]; then
            json_envelope "config init" "success" 0 "{\"config_dir\": \"$DSR_CONFIG_DIR\", \"initialized\": true}"
        else
            json_envelope "config init" "error" $status "{\"error\": \"initialization failed\"}"
        fi
        return $status
    else
        if $force; then
            config_init --force
        else
            config_init
        fi
    fi
}

cmd_config_show() {
    if $JSON_MODE; then
        config_show --json
    else
        config_show "$@"
    fi
}

cmd_config_get() {
    local key="${1:-}"
    if [[ -z "$key" ]]; then
        log_error "Usage: dsr config get <key>"
        return 4
    fi

    config_load
    local value
    value=$(config_get "$key" "")

    if [[ -z "$value" ]]; then
        log_error "Key not found: $key"
        return 4
    fi

    if $JSON_MODE; then
        echo "{\"key\": \"$key\", \"value\": \"$value\"}"
    else
        echo "$value"
    fi
}

cmd_config_set() {
    local input="${1:-}"
    if [[ -z "$input" || ! "$input" =~ = ]]; then
        log_error "Usage: dsr config set KEY=VALUE"
        return 4
    fi

    local key="${input%%=*}"
    local value="${input#*=}"

    config_load
    config_set "$key" "$value" --persist

    if $JSON_MODE; then
        echo "{\"key\": \"$key\", \"value\": \"$value\", \"persisted\": true}"
    fi
}

cmd_config_validate() {
    if $JSON_MODE; then
        config_load
        if config_validate 2>/dev/null; then
            json_envelope "config validate" "success" 0 "{\"valid\": true}"
        else
            json_envelope "config validate" "error" 4 "{\"valid\": false}"
            return 4
        fi
    else
        config_load
        config_validate
    fi
}

cmd_config_edit() {
    local editor="${EDITOR:-vi}"
    if [[ ! -f "$DSR_CONFIG_FILE" ]]; then
        log_error "Config file not found. Run: dsr config init"
        return 4
    fi
    exec "$editor" "$DSR_CONFIG_FILE"
}

# ============================================================================
# DOCTOR SUBCOMMAND
# ============================================================================

cmd_doctor() {
    local quick_mode=false
    local fix_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quick|-q)
                quick_mode=true
                shift
                ;;
            --fix|-f)
                fix_mode=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr doctor - System diagnostics

USAGE:
    dsr doctor [options]

OPTIONS:
    --quick, -q     Quick check (core deps + auth only)
    --fix, -f       Suggest fixes for issues found
    --json          JSON output (global flag)

CHECKS:
    Core (always run):
      - git, gh (auth status), jq, curl

    Build tools:
      - docker, act, ssh to build hosts

    Signing tools (if enabled):
      - minisign, syft

    Network:
      - api.github.com, github.com connectivity

    Config:
      - Configuration file validation

EXIT CODES:
    0  - All checks passed (or only warnings)
    3  - Critical errors found (missing core deps)

EXAMPLES:
    dsr doctor              Full diagnostics
    dsr doctor --quick      Core deps only
    dsr doctor --fix        Show remediation steps
    dsr doctor --json       Machine-readable output
EOF
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    log_info "Running system diagnostics..."
    $quick_mode && log_info "(quick mode - core checks only)"
    echo ""

    local errors=0
    local warnings=0
    local checks=()
    local fixes=()

    # Helper to escape JSON strings
    _json_escape() {
        printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\n/\\n/g'
    }

    # Helper to add a check result
    _add_check() {
        local name="$1"
        local status="$2"
        local details="$3"
        checks+=("{\"name\": \"$name\", \"status\": \"$status\"$details}")
    }

    # ========== CORE DEPENDENCIES ==========
    log_info "Core dependencies:"

    # Check git
    if command -v git &>/dev/null; then
        local git_ver
        git_ver=$(git --version | cut -d' ' -f3)
        _add_check "git" "ok" ", \"version\": \"$(_json_escape "$git_ver")\""
        log_ok "  git: $git_ver"
    else
        _add_check "git" "error" ", \"message\": \"not found\""
        log_error "  git: not found"
        fixes+=("Install git: apt install git OR brew install git")
        ((errors++))
    fi

    # Check gh
    if command -v gh &>/dev/null; then
        local gh_ver
        gh_ver=$(gh --version 2>/dev/null | head -1 | awk '{print $3}')
        if gh auth status &>/dev/null 2>&1; then
            local gh_user
            gh_user=$(gh api user --jq '.login' 2>/dev/null || echo "unknown")
            _add_check "gh" "ok" ", \"version\": \"$gh_ver\", \"authenticated\": true, \"user\": \"$gh_user\""
            log_ok "  gh: $gh_ver (authenticated as $gh_user)"
        else
            _add_check "gh" "error" ", \"version\": \"$gh_ver\", \"authenticated\": false"
            log_error "  gh: not authenticated"
            fixes+=("Authenticate GitHub CLI: gh auth login")
            ((errors++))
        fi
    else
        _add_check "gh" "error" ", \"message\": \"not found\""
        log_error "  gh: not found"
        fixes+=("Install GitHub CLI: brew install gh OR apt install gh")
        ((errors++))
    fi

    # Check jq
    if command -v jq &>/dev/null; then
        local jq_ver
        jq_ver=$(jq --version 2>/dev/null | sed 's/jq-//')
        _add_check "jq" "ok" ", \"version\": \"$jq_ver\""
        log_ok "  jq: $jq_ver"
    else
        _add_check "jq" "error" ", \"message\": \"not found\""
        log_error "  jq: not found"
        fixes+=("Install jq: brew install jq OR apt install jq")
        ((errors++))
    fi

    # Check curl
    if command -v curl &>/dev/null; then
        local curl_ver
        curl_ver=$(curl --version 2>/dev/null | head -1 | awk '{print $2}')
        _add_check "curl" "ok" ", \"version\": \"$curl_ver\""
        log_ok "  curl: $curl_ver"
    else
        _add_check "curl" "error" ", \"message\": \"not found\""
        log_error "  curl: not found"
        fixes+=("Install curl: apt install curl")
        ((errors++))
    fi

    # Check yq (needed for config operations)
    if command -v yq &>/dev/null; then
        local yq_ver
        yq_ver=$(yq --version 2>/dev/null | awk '{print $NF}')
        _add_check "yq" "ok" ", \"version\": \"$yq_ver\""
        log_ok "  yq: $yq_ver"
    else
        _add_check "yq" "warning" ", \"message\": \"not found\""
        log_warn "  yq: not found (needed for config operations)"
        fixes+=("Install yq: brew install yq OR snap install yq")
        ((warnings++))
    fi

    # Quick mode stops here
    if $quick_mode; then
        echo ""
        _doctor_summary "$errors" "$warnings" "$fix_mode"
        [[ $errors -eq 0 ]] && return 0 || return 3
    fi

    # ========== BUILD TOOLS ==========
    echo ""
    log_info "Build tools:"

    # Check docker
    if command -v docker &>/dev/null; then
        if docker info &>/dev/null 2>&1; then
            local docker_ver
            docker_ver=$(docker --version 2>/dev/null | awk '{print $3}' | tr -d ',')
            _add_check "docker" "ok" ", \"version\": \"$docker_ver\", \"running\": true"
            log_ok "  docker: $docker_ver (running)"
        else
            _add_check "docker" "warning" ", \"running\": false"
            log_warn "  docker: installed but not running"
            fixes+=("Start Docker: systemctl start docker OR open Docker Desktop")
            ((warnings++))
        fi
    else
        _add_check "docker" "warning" ", \"message\": \"not found\""
        log_warn "  docker: not found (needed for act)"
        fixes+=("Install Docker: https://docs.docker.com/get-docker/")
        ((warnings++))
    fi

    # Check act
    if command -v act &>/dev/null; then
        local act_ver
        act_ver=$(act --version 2>/dev/null | head -1)
        _add_check "act" "ok" ", \"version\": \"$(_json_escape "$act_ver")\""
        log_ok "  act: $act_ver"
    else
        _add_check "act" "warning" ", \"message\": \"not found\""
        log_warn "  act: not found (needed for local builds)"
        fixes+=("Install act: brew install act OR https://github.com/nektos/act/releases")
        ((warnings++))
    fi

    # Check SSH
    if command -v ssh &>/dev/null; then
        _add_check "ssh" "ok" ""
        log_ok "  ssh: available"
    else
        _add_check "ssh" "warning" ", \"message\": \"not found\""
        log_warn "  ssh: not found (needed for remote builds)"
        ((warnings++))
    fi

    # ========== SSH TO BUILD HOSTS ==========
    echo ""
    log_info "Build hosts:"

    for host in mmini wlap; do
        if timeout 5 ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" "echo ok" &>/dev/null 2>&1; then
            _add_check "ssh-$host" "ok" ""
            log_ok "  $host: reachable"
        else
            _add_check "ssh-$host" "warning" ", \"message\": \"unreachable\""
            log_warn "  $host: unreachable"
            fixes+=("Check SSH config for $host: ssh $host")
            ((warnings++))
        fi
    done

    # ========== SIGNING TOOLS ==========
    echo ""
    log_info "Signing tools:"

    # Check minisign
    if command -v minisign &>/dev/null; then
        local minisign_ver
        minisign_ver=$(minisign -v 2>&1 | head -1 || echo "unknown")
        _add_check "minisign" "ok" ", \"version\": \"$(_json_escape "$minisign_ver")\""
        log_ok "  minisign: available"

        # Check if key exists
        if [[ -f "${SIGNING_PRIVATE_KEY:-$HOME/.config/dsr/secrets/minisign.key}" ]]; then
            _add_check "minisign-key" "ok" ""
            log_ok "  minisign key: configured"
        else
            _add_check "minisign-key" "warning" ", \"message\": \"not configured\""
            log_warn "  minisign key: not configured"
            fixes+=("Generate signing key: dsr signing init")
            ((warnings++))
        fi
    else
        _add_check "minisign" "warning" ", \"message\": \"not found\""
        log_warn "  minisign: not found (needed for signing)"
        fixes+=("Install minisign: brew install minisign")
        ((warnings++))
    fi

    # Check syft (SBOM generation)
    if command -v syft &>/dev/null; then
        local syft_ver
        syft_ver=$(syft --version 2>/dev/null | head -1 || echo "unknown")
        _add_check "syft" "ok" ", \"version\": \"$(_json_escape "$syft_ver")\""
        log_ok "  syft: $syft_ver"
    else
        _add_check "syft" "warning" ", \"message\": \"not found\""
        log_warn "  syft: not found (needed for SBOM generation)"
        fixes+=("Install syft: brew install syft OR https://github.com/anchore/syft/releases")
        ((warnings++))
    fi

    # ========== NETWORK CONNECTIVITY ==========
    echo ""
    log_info "Network connectivity:"

    # Check api.github.com
    if curl -sf --max-time 5 "https://api.github.com" >/dev/null 2>&1; then
        _add_check "network-api.github.com" "ok" ""
        log_ok "  api.github.com: reachable"
    else
        _add_check "network-api.github.com" "warning" ", \"message\": \"unreachable\""
        log_warn "  api.github.com: unreachable"
        fixes+=("Check network connectivity to GitHub")
        ((warnings++))
    fi

    # Check github.com
    if curl -sf --max-time 5 "https://github.com" >/dev/null 2>&1; then
        _add_check "network-github.com" "ok" ""
        log_ok "  github.com: reachable"
    else
        _add_check "network-github.com" "warning" ", \"message\": \"unreachable\""
        log_warn "  github.com: unreachable"
        ((warnings++))
    fi

    # ========== DISK SPACE ==========
    echo ""
    log_info "Disk space:"

    local disk_avail_kb disk_avail_gb
    disk_avail_kb=$(df -k . 2>/dev/null | tail -1 | awk '{print $4}')
    if [[ -n "$disk_avail_kb" ]]; then
        disk_avail_gb=$((disk_avail_kb / 1024 / 1024))
        if [[ $disk_avail_gb -lt 5 ]]; then
            _add_check "disk-local" "warning" ", \"available_gb\": $disk_avail_gb"
            log_warn "  local: ${disk_avail_gb}GB available (low)"
            fixes+=("Free up disk space (< 5GB available)")
            ((warnings++))
        else
            _add_check "disk-local" "ok" ", \"available_gb\": $disk_avail_gb"
            log_ok "  local: ${disk_avail_gb}GB available"
        fi
    fi

    # ========== CONFIG ==========
    echo ""
    log_info "Configuration:"

    config_load 2>/dev/null || true
    if config_validate &>/dev/null 2>&1; then
        _add_check "config" "ok" ""
        log_ok "  config: valid"
    else
        _add_check "config" "warning" ", \"message\": \"invalid or missing\""
        log_warn "  config: invalid or missing"
        fixes+=("Initialize config: dsr config init")
        ((warnings++))
    fi

    # Summary
    echo ""
    _doctor_summary "$errors" "$warnings" "$fix_mode"
    [[ $errors -eq 0 ]] && return 0 || return 3
}

# Doctor summary helper - called at end to print summary and JSON output
# Uses global arrays: checks[], fixes[]
_doctor_summary() {
    local errors="$1"
    local warnings="$2"
    local fix_mode="$3"

    local exit_code=0
    local overall_status="healthy"

    if [[ $errors -gt 0 ]]; then
        log_error "Found $errors error(s), $warnings warning(s)"
        exit_code=3
        overall_status="unhealthy"
    elif [[ $warnings -gt 0 ]]; then
        log_warn "Found $warnings warning(s)"
        overall_status="degraded"
    else
        log_ok "All checks passed"
    fi

    # Show fixes if requested
    if [[ "$fix_mode" == "true" && ${#fixes[@]} -gt 0 ]]; then
        echo ""
        log_info "Suggested fixes:"
        for fix in "${fixes[@]}"; do
            log_info "  → $fix"
        done
    fi

    if $JSON_MODE; then
        local checks_json details_json
        checks_json=$(printf '%s\n' "${checks[@]}" | jq -sc '.')
        details_json=$(jq -nc \
            --argjson errors "$errors" \
            --argjson warnings "$warnings" \
            --arg overall_status "$overall_status" \
            --argjson checks "$checks_json" \
            '{
                overall_status: $overall_status,
                errors: $errors,
                warnings: $warnings,
                checks: $checks
            }')
        local status_str
        [[ "$errors" -eq 0 ]] && status_str="success" || status_str="error"
        json_envelope "doctor" "$status_str" "$exit_code" "$details_json"
    fi
}

# ============================================================================
# STUB COMMANDS (to be implemented)
# ============================================================================

# ============================================================================
# CHECK SUBCOMMAND
# ============================================================================

cmd_check() {
    local repos=()
    local threshold=600  # 10 minutes in seconds
    local check_all=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repos|-r)
                IFS=',' read -ra repos <<< "$2"
                shift 2
                ;;
            --threshold|-t)
                threshold="$2"
                shift 2
                ;;
            --all|-a)
                check_all=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr check - Detect throttled GitHub Actions runs

USAGE:
    dsr check <repo>
    dsr check --repos repo1,repo2
    dsr check --all

OPTIONS:
    -r, --repos <list>      Comma-separated repos (e.g., ntm,bv)
    -t, --threshold <sec>   Queue time threshold in seconds (default: 600)
    -a, --all               Check all configured repos
    --json                  JSON output (global flag)

EXAMPLES:
    dsr check Dicklesworthstone/ntm
    dsr check --repos ntm,bv --threshold 300
    dsr check --all --json

EXIT CODES:
    0  - No throttling detected
    1  - Throttling detected
    3  - Dependency error (gh not authenticated)
    4  - Invalid arguments
    8  - Network/API error
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr check --help' for usage"
                return 4
                ;;
            *)
                # Positional argument - repo
                repos+=("$1")
                shift
                ;;
        esac
    done

    # Load config for --all option
    if $check_all; then
        config_load 2>/dev/null || true
        # Get repos from config (parse repos.yaml)
        local repos_file="$DSR_CONFIG_DIR/repos.yaml"
        if [[ -f "$repos_file" ]]; then
            while IFS= read -r repo; do
                [[ -n "$repo" ]] && repos+=("$repo")
            done < <(grep -E '^\s+repo:' "$repos_file" 2>/dev/null | sed 's/.*repo:\s*//' | tr -d '"' || true)
        fi
    fi

    # Validate we have repos to check
    if [[ ${#repos[@]} -eq 0 ]]; then
        log_error "No repos specified. Use: dsr check <repo> or --all"
        return 4
    fi

    # Check dependencies
    if ! gh_check 2>/dev/null; then
        if ! gh_check_token 2>/dev/null; then
            if $JSON_MODE; then
                json_envelope "check" "error" 3 '{"error": "GitHub authentication required"}'
            fi
            return 3
        fi
    fi

    # Process each repo
    local any_throttled=false
    local results=()
    local now
    now=$(date +%s)

    for repo in "${repos[@]}"; do
        local result
        result=$(_check_repo "$repo" "$threshold" "$now")
        local status=$?

        if [[ $status -eq 1 ]]; then
            any_throttled=true
        fi

        results+=("$result")

        if ! $JSON_MODE; then
            _check_print_result "$result"
        fi
    done

    # JSON output
    if $JSON_MODE; then
        local results_json
        results_json=$(printf '%s\n' "${results[@]}" | jq -sc '.')
        local summary_status="ok"
        $any_throttled && summary_status="throttled"
        json_envelope "check" "$summary_status" "$($any_throttled && echo 1 || echo 0)" \
            "$(jq -nc --argjson repos "$results_json" --argjson threshold "$threshold" \
                '{threshold_seconds: $threshold, repos: $repos}')"
    fi

    $any_throttled && return 1 || return 0
}

# Check a single repo for throttling
# Returns JSON result, exit code 1 if throttled
_check_repo() {
    local repo="$1"
    local threshold="$2"
    local now="$3"

    # Resolve short repo name to owner/repo
    if [[ ! "$repo" =~ / ]]; then
        # Assume Dicklesworthstone if no owner specified
        repo="Dicklesworthstone/$repo"
    fi

    # Fetch workflow runs
    local runs_json
    runs_json=$(gh_workflow_runs "$repo" --limit 20 2>/dev/null)
    local fetch_status=$?

    if [[ $fetch_status -ne 0 ]] || [[ -z "$runs_json" ]]; then
        echo '{"repo": "'"$repo"'", "status": "error", "error": "failed to fetch runs"}'
        return 8
    fi

    # Extract and analyze runs
    local queued_runs stuck_runs
    queued_runs=$(echo "$runs_json" | jq -c --argjson now "$now" --argjson threshold "$threshold" '
        .workflow_runs // [] |
        map(select(.status == "queued")) |
        map(. as $run |
            ($now - ($run.created_at | fromdateiso8601 // $now)) as $age |
            select($age > $threshold) |
            {
                id: .id,
                status: .status,
                created_at: .created_at,
                workflow_id: .workflow_id,
                workflow_name: .name,
                event: .event,
                html_url: .html_url,
                age_seconds: $age
            }
        )' 2>/dev/null || echo '[]')

    stuck_runs=$(echo "$runs_json" | jq -c --argjson now "$now" --argjson threshold "$threshold" '
        .workflow_runs // [] |
        map(select(.status == "in_progress")) |
        map(. as $run |
            ($run.run_started_at // $run.created_at) as $start_time |
            ($now - ($start_time | fromdateiso8601 // $now)) as $age |
            select($age > $threshold) |
            {
                id: .id,
                status: .status,
                created_at: .created_at,
                run_started_at: .run_started_at,
                workflow_id: .workflow_id,
                workflow_name: .name,
                event: .event,
                html_url: .html_url,
                age_seconds: $age
            }
        )' 2>/dev/null || echo '[]')

    # Count issues
    local queued_count stuck_count
    queued_count=$(echo "$queued_runs" | jq 'length')
    stuck_count=$(echo "$stuck_runs" | jq 'length')

    # Determine oldest queued time
    local oldest_queued_sec=0
    if [[ "$queued_count" -gt 0 ]]; then
        oldest_queued_sec=$(echo "$queued_runs" | jq '[.[].age_seconds] | max // 0')
    fi

    # Build result
    local status="ok"
    if [[ "$queued_count" -gt 0 ]] || [[ "$stuck_count" -gt 0 ]]; then
        status="throttled"
    fi

    jq -nc \
        --arg repo "$repo" \
        --arg status "$status" \
        --argjson threshold "$threshold" \
        --argjson queued_count "$queued_count" \
        --argjson stuck_count "$stuck_count" \
        --argjson oldest_queued_sec "$oldest_queued_sec" \
        --argjson queued_runs "$queued_runs" \
        --argjson stuck_runs "$stuck_runs" \
        '{
            repo: $repo,
            status: $status,
            threshold_seconds: $threshold,
            queued_count: $queued_count,
            stuck_in_progress_count: $stuck_count,
            oldest_queued_seconds: $oldest_queued_sec,
            oldest_queued_minutes: (($oldest_queued_sec / 60) | floor),
            queued_runs: $queued_runs,
            stuck_runs: $stuck_runs
        }'

    [[ "$status" == "throttled" ]] && return 1 || return 0
}

# Print human-readable check result
_check_print_result() {
    local result="$1"

    local repo status queued stuck oldest_min
    repo=$(echo "$result" | jq -r '.repo')
    status=$(echo "$result" | jq -r '.status')
    queued=$(echo "$result" | jq -r '.queued_count')
    stuck=$(echo "$result" | jq -r '.stuck_in_progress_count')
    oldest_min=$(echo "$result" | jq -r '.oldest_queued_minutes')

    if [[ "$status" == "error" ]]; then
        log_error "$repo: $(echo "$result" | jq -r '.error // "unknown error"')"
    elif [[ "$status" == "throttled" ]]; then
        log_warn "$repo: THROTTLED"
        [[ "$queued" -gt 0 ]] && log_warn "  - $queued runs queued (oldest: ${oldest_min}m)"
        [[ "$stuck" -gt 0 ]] && log_warn "  - $stuck runs stuck in_progress"

        # Show URLs for queued runs
        echo "$result" | jq -r '.queued_runs[:3][] | "    → \(.html_url)"' 2>/dev/null | while read -r url; do
            log_info "$url"
        done
    else
        log_ok "$repo: OK (no throttling detected)"
    fi
}

# ============================================================================
# WATCH SUBCOMMAND - Continuous Monitoring Daemon
# ============================================================================

# State file paths
_WATCH_STATE_DIR="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
_WATCH_TRIGGERED_FILE="$_WATCH_STATE_DIR/triggered.json"
_WATCH_LOCK_FILE="$_WATCH_STATE_DIR/watch.lock"

# Default settings
_WATCH_DEFAULT_INTERVAL=300  # 5 minutes
_WATCH_JITTER_PERCENT=20     # ±20% jitter
_WATCH_DEBOUNCE_WINDOW=180   # 3 minutes
_WATCH_BACKOFF_INITIAL=60    # 1 minute initial backoff
_WATCH_BACKOFF_MAX=3600      # 1 hour max backoff

# Internal state
_WATCH_RUNNING=false
_WATCH_CURRENT_BACKOFF=0

# Watch signal handlers
_watch_cleanup() {
    log_info "Shutting down watcher..."
    _watch_release_lock
    _WATCH_RUNNING=false
}

# Acquire lock to prevent multiple watcher instances
_watch_acquire_lock() {
    mkdir -p "$_WATCH_STATE_DIR"

    # Check for existing lock
    if [[ -f "$_WATCH_LOCK_FILE" ]]; then
        local lock_pid
        lock_pid=$(cat "$_WATCH_LOCK_FILE" 2>/dev/null)

        # Check if process is still running
        if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
            log_error "Another watcher is running (PID $lock_pid)"
            return 2
        fi

        # Stale lock - remove it
        log_warn "Removing stale lock file"
        rm -f "$_WATCH_LOCK_FILE"
    fi

    # Create lock
    echo "$$" > "$_WATCH_LOCK_FILE"
    return 0
}

_watch_release_lock() {
    rm -f "$_WATCH_LOCK_FILE" 2>/dev/null
}

# Load triggered runs state
_watch_load_triggered() {
    if [[ -f "$_WATCH_TRIGGERED_FILE" ]]; then
        cat "$_WATCH_TRIGGERED_FILE"
    else
        echo '{"runs": {}, "last_check": null}'
    fi
}

# Save triggered runs state
_watch_save_triggered() {
    local state="$1"
    echo "$state" > "$_WATCH_TRIGGERED_FILE"
}

# Check if a run was already triggered
_watch_is_triggered() {
    local run_id="$1"
    local state
    state=$(_watch_load_triggered)

    echo "$state" | jq -e --arg id "$run_id" '.runs[$id] != null' &>/dev/null
}

# Mark a run as triggered
_watch_mark_triggered() {
    local run_id="$1"
    local state now
    state=$(_watch_load_triggered)
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    state=$(echo "$state" | jq --arg id "$run_id" --arg ts "$now" \
        '.runs[$id] = $ts | .last_check = $ts')

    _watch_save_triggered "$state"
}

# Clean old triggered entries (older than 24 hours)
_watch_cleanup_triggered() {
    local state cutoff
    state=$(_watch_load_triggered)
    cutoff=$(date -u -d "-24 hours" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || \
             date -u -v-24H +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "")

    if [[ -n "$cutoff" ]]; then
        state=$(echo "$state" | jq --arg cutoff "$cutoff" \
            '.runs |= with_entries(select(.value >= $cutoff))')
        _watch_save_triggered "$state"
    fi
}

# Calculate jittered sleep interval
_watch_jittered_sleep() {
    local base_interval="$1"
    local jitter_range=$((base_interval * _WATCH_JITTER_PERCENT / 100))
    local jitter=$((RANDOM % (jitter_range * 2 + 1) - jitter_range))
    local sleep_time=$((base_interval + jitter))

    [[ $sleep_time -lt 10 ]] && sleep_time=10
    echo "$sleep_time"
}

# Main watch loop iteration
_watch_iteration() {
    local dry_run="$1"
    local triggered_count=0

    log_info "Running throttle check..."

    # Run dsr check
    local check_output check_exit
    if check_output=$(./dsr --json check --all 2>/dev/null); then
        check_exit=0
        _WATCH_CURRENT_BACKOFF=0  # Reset backoff on success
    else
        check_exit=$?

        # Network error - apply backoff
        if [[ $check_exit -eq 8 ]]; then
            if [[ $_WATCH_CURRENT_BACKOFF -eq 0 ]]; then
                _WATCH_CURRENT_BACKOFF=$_WATCH_BACKOFF_INITIAL
            else
                _WATCH_CURRENT_BACKOFF=$((_WATCH_CURRENT_BACKOFF * 2))
                [[ $_WATCH_CURRENT_BACKOFF -gt $_WATCH_BACKOFF_MAX ]] && \
                    _WATCH_CURRENT_BACKOFF=$_WATCH_BACKOFF_MAX
            fi
            log_warn "API error, backing off for ${_WATCH_CURRENT_BACKOFF}s"
            return 1
        fi
    fi

    # Parse check results
    local throttled_runs
    throttled_runs=$(echo "$check_output" | jq -r \
        '.details.repos[]?.throttled_runs[]? | "\(.id)|\(.repo)"' 2>/dev/null)

    if [[ -z "$throttled_runs" ]]; then
        log_ok "No throttled runs detected"
        return 0
    fi

    # Process each throttled run
    while IFS='|' read -r run_id repo; do
        [[ -z "$run_id" ]] && continue

        # Check if already triggered
        if _watch_is_triggered "$run_id"; then
            log_debug "Run $run_id already triggered, skipping"
            continue
        fi

        log_warn "Throttled run detected: $run_id ($repo)"
        if [[ "${DSR_NOTIFY_ENABLED:-false}" == "true" ]]; then
            notify_event "watch.throttled" "warn" \
                "Throttle detected" \
                "Repo $repo run $run_id exceeded threshold" \
                "$run_id" || true
        fi

        if $dry_run; then
            log_info "[DRY RUN] Would trigger fallback for $repo (run $run_id)"
        else
            log_info "Triggering fallback for $repo..."

            # Mark as triggered before attempting (to prevent repeated attempts on failure)
            _watch_mark_triggered "$run_id"

            # TODO: Actually trigger fallback when build/release commands are implemented
            # For now, just log that we would trigger it
            log_info "Fallback queued for $repo (run $run_id)"
            # ./dsr fallback --repo "$repo" &
            if [[ "${DSR_NOTIFY_ENABLED:-false}" == "true" ]]; then
                notify_event "watch.fallback_queued" "info" \
                    "Fallback queued" \
                    "Repo $repo run $run_id queued for fallback" \
                    "$run_id" || true
            fi
        fi

        ((triggered_count++))
    done <<< "$throttled_runs"

    if [[ $triggered_count -gt 0 ]]; then
        log_info "Triggered $triggered_count fallback(s)"
    fi

    return 0
}

cmd_watch() {
    local interval=$_WATCH_DEFAULT_INTERVAL
    local daemon_mode=false
    local dry_run=false
    local once_mode=false
    local notify_methods="none"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --interval|-i)
                interval="$2"
                shift 2
                ;;
            --notify)
                notify_methods="$2"
                shift 2
                ;;
            --notify=*)
                notify_methods="${1#*=}"
                shift
                ;;
            --daemon|-d)
                daemon_mode=true
                shift
                ;;
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            --once|-1)
                once_mode=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr watch - Continuous monitoring daemon

USAGE:
    dsr watch [options]

OPTIONS:
    --interval, -i <sec>   Poll interval in seconds (default: 300)
    --daemon, -d           Run in background (daemon mode)
    --dry-run, -n          Check but don't trigger fallbacks
    --once, -1             Single check and exit
    --notify <method>      Notification: slack|discord|desktop|terminal|none
    --json                 JSON output (global flag)

BEHAVIOR:
    - Polls all configured repos for throttled GH Actions runs
    - Triggers fallback builds once per detected throttle
    - Deduplicates by run ID (won't re-trigger same run)
    - Uses jittered intervals to avoid thundering herd
    - Exponential backoff on API errors (up to 1 hour)
    - Stores state in ~/.local/state/dsr/triggered.json

STATE FILES:
    ~/.local/state/dsr/triggered.json  - Triggered run history
    ~/.local/state/dsr/watch.lock      - Lock file (single instance)

EXAMPLES:
    dsr watch                  Start watching (foreground)
    dsr watch --once           Single check and exit
    dsr watch --dry-run        Check without triggering
    dsr watch --interval 60    Poll every minute
    dsr watch --daemon &       Run in background

EXIT CODES:
    0  - Success (or clean shutdown)
    2  - Another watcher is already running
    3  - Dependency error (run dsr doctor)
    5  - Interrupted (SIGTERM/SIGINT)
EOF
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    # Validate interval
    if ! [[ "$interval" =~ ^[0-9]+$ ]] || [[ "$interval" -lt 10 ]]; then
        log_error "Invalid interval: $interval (must be >= 10 seconds)"
        return 4
    fi

    # Configure notifications for watch loop
    if [[ "$notify_methods" != "none" ]]; then
        # shellcheck disable=SC2034  # Used by notify.sh
        DSR_NOTIFY_METHODS="$notify_methods"
        DSR_NOTIFY_ENABLED=true
        notify_init >/dev/null 2>&1 || true
        log_info "Notifications enabled: $notify_methods"
    else
        DSR_NOTIFY_ENABLED=false
    fi

    # Run preflight check
    log_info "Running preflight check..."
    if ! ./dsr doctor --quick &>/dev/null; then
        log_error "Preflight check failed. Run 'dsr doctor' for details."
        return 3
    fi
    log_ok "Preflight check passed"

    # Single check mode
    if $once_mode; then
        log_info "Running single check..."
        _watch_iteration "$dry_run"
        local result=$?

        if $JSON_MODE; then
            local state
            state=$(_watch_load_triggered)
            json_envelope "watch" "success" "$result" "$(jq -nc \
                --arg mode "once" \
                --argjson state "$state" \
                '{mode: $mode, triggered_state: $state}')"
        fi

        return $result
    fi

    # Acquire lock for continuous mode
    if ! _watch_acquire_lock; then
        return 2
    fi

    # Set up signal handlers
    trap _watch_cleanup SIGTERM SIGINT

    # Daemon mode
    if $daemon_mode; then
        log_info "Starting daemon mode (interval: ${interval}s)..."
        # For true daemon mode, the process should be backgrounded by the caller
        # We just continue running in foreground but signal that we're ready
    else
        log_info "Starting watch mode (interval: ${interval}s, Ctrl+C to stop)..."
    fi

    $dry_run && log_info "(dry-run mode - no fallbacks will be triggered)"

    # Clean old triggered entries on startup
    _watch_cleanup_triggered

    _WATCH_RUNNING=true
    local iteration=0

    while $_WATCH_RUNNING; do
        ((iteration++))
        log_info "--- Iteration $iteration ---"

        # Run check
        if ! _watch_iteration "$dry_run"; then
            # Backoff on error
            if [[ $_WATCH_CURRENT_BACKOFF -gt 0 ]]; then
                log_info "Sleeping ${_WATCH_CURRENT_BACKOFF}s (backoff)..."
                sleep "$_WATCH_CURRENT_BACKOFF" || break
                continue
            fi
        fi

        # Calculate jittered sleep
        local sleep_time
        sleep_time=$(_watch_jittered_sleep "$interval")
        log_info "Next check in ${sleep_time}s..."

        # Sleep (interruptible)
        sleep "$sleep_time" || break
    done

    # Cleanup
    _watch_release_lock
    log_info "Watcher stopped"

    if $JSON_MODE; then
        local state
        state=$(_watch_load_triggered)
        json_envelope "watch" "success" 0 "$(jq -nc \
            --argjson iterations "$iteration" \
            --argjson state "$state" \
            '{mode: "continuous", iterations: $iterations, triggered_state: $state}')"
    fi

    return 0
}

cmd_build() {
    local tool_name=""
    local targets=()
    local version=""
    local output_dir=""
    # shellcheck disable=SC2034  # parallel reserved for future parallel build support
    local parallel=false
    # shellcheck disable=SC2034  # resume reserved for future resume support
    local resume=false
    local allow_dirty=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tool|-t)
                tool_name="$2"
                shift 2
                ;;
            --target)
                targets+=("$2")
                shift 2
                ;;
            --targets)
                # Allow comma-separated list
                IFS=',' read -ra targets <<< "$2"
                shift 2
                ;;
            --version|-V)
                version="$2"
                shift 2
                ;;
            --output-dir|-o)
                output_dir="$2"
                shift 2
                ;;
            --parallel|-p)
                parallel=true  # shellcheck disable=SC2034
                shift
                ;;
            --resume|-r)
                resume=true  # shellcheck disable=SC2034
                shift
                ;;
            --allow-dirty)
                allow_dirty=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr build - Build artifacts locally

USAGE:
    dsr build <tool> [options]
    dsr build --tool <name> [options]

OPTIONS:
    -t, --tool <name>      Tool to build (required, or as first positional arg)
    --target <target>      Specific target (e.g., linux/amd64); can repeat
    --targets <list>       Comma-separated target list
    -V, --version <ver>    Version to build (default: detect from version files)
    -o, --output-dir <dir> Output directory for artifacts
    -p, --parallel         Build targets in parallel
    -r, --resume           Resume interrupted build
    --allow-dirty          Allow building with uncommitted changes

DESCRIPTION:
    Builds a tool for all configured targets using act (Linux) and
    SSH to remote hosts (macOS/Windows).

TARGETS:
    Configured per tool in ~/.config/dsr/repos.d/<tool>.yaml
    Common targets: linux/amd64, linux/arm64, darwin/arm64, windows/amd64

EXAMPLES:
    dsr build ntm                           Build ntm for all targets
    dsr build ntm --target linux/amd64      Build only for Linux x64
    dsr build ntm --version 1.2.3           Build specific version
    dsr build ntm --parallel                Build all targets in parallel
    dsr build --tool bv --resume            Resume interrupted bv build

EXIT CODES:
    0  - All builds succeeded
    1  - Some builds failed
    2  - Build already in progress (lock held)
    4  - Invalid arguments or missing config
    6  - Build failed
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr build --help' for usage"
                return 4
                ;;
            *)
                # First positional arg is tool name
                if [[ -z "$tool_name" ]]; then
                    tool_name="$1"
                else
                    # Additional positional args might be targets
                    targets+=("$1")
                fi
                shift
                ;;
        esac
    done

    # Validate tool name
    if [[ -z "$tool_name" ]]; then
        log_error "Tool name required"
        log_info "Run 'dsr build --help' for usage"
        return 4
    fi

    # Set output directory default
    local state_dir="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
    [[ -z "$output_dir" ]] && output_dir="$state_dir/artifacts"
    mkdir -p "$output_dir"

    # Check if act is available
    if ! act_check; then
        log_error "act not available - cannot build"
        return 3
    fi

    # Load tool config
    if ! act_load_repo_config "$tool_name"; then
        log_error "Tool '$tool_name' not found in repos.d"
        log_info "Available tools: $(act_list_tools 2>/dev/null | tr '\n' ' ')"
        return 4
    fi

    # Get local path
    local local_path
    local_path=$(act_get_local_path "$tool_name")
    if [[ -z "$local_path" || ! -d "$local_path" ]]; then
        log_error "Local path not found for $tool_name: $local_path"
        return 4
    fi

    # Check for dirty working tree
    if ! $allow_dirty; then
        if git_ops_is_dirty "$local_path"; then
            log_error "Working tree has uncommitted changes in $local_path"
            log_info "Commit changes or use --allow-dirty to override"
            return 1
        fi
    fi

    # Detect version if not specified
    if [[ -z "$version" ]]; then
        log_info "Detecting version from version files..."
        if version=$(version_detect "$local_path" 2>/dev/null); then
            log_info "Detected version: $version"
        else
            log_error "Cannot detect version. Specify with --version"
            return 4
        fi
    fi

    # Normalize version (ensure it has 'v' prefix for tag)
    local tag
    tag=$(git_ops_version_to_tag "$version")

    # Check if tag exists
    if ! git_ops_tag_exists "$local_path" "$tag"; then
        log_warn "Tag $tag does not exist in $local_path"
        log_info "Creating tag with: dsr version tag $tool_name"
        # For now, proceed anyway - the version might be in version files but not tagged
    fi

    log_info "Building $tool_name $version"
    log_set_tool "$tool_name"

    # Get targets from args or config
    local target_list
    if [[ ${#targets[@]} -gt 0 ]]; then
        target_list="${targets[*]}"
    else
        target_list=$(act_get_targets "$tool_name")
    fi

    if [[ -z "$target_list" ]]; then
        log_error "No targets configured for $tool_name"
        return 4
    fi

    log_info "Targets: $target_list"

    # Record start time
    local start_time
    start_time=$(date +%s)

    # Run orchestrated build
    local result
    # shellcheck disable=SC2086
    result=$(act_orchestrate_build "$tool_name" "$version" $target_list 2>&1)
    local exit_code=$?

    # Parse result
    local end_time duration
    end_time=$(date +%s)
    duration=$((end_time - start_time))

    # Extract summary from result
    local total success failed
    total=$(echo "$result" | grep -o '"total":[0-9]*' | grep -o '[0-9]*' | tail -1)
    success=$(echo "$result" | grep -o '"success":[0-9]*' | grep -o '[0-9]*' | tail -1)
    failed=$(echo "$result" | grep -o '"failed":[0-9]*' | grep -o '[0-9]*' | tail -1)

    # Default values if parsing failed
    [[ -z "$total" ]] && total=0
    [[ -z "$success" ]] && success=0
    [[ -z "$failed" ]] && failed=0

    # Generate manifest
    local manifest_file="$output_dir/${tool_name}-${version}-manifest.json"
    if [[ $success -gt 0 ]]; then
        # Generate manifest from results
        act_generate_manifest "$tool_name" "$version" "$output_dir" > "$manifest_file" 2>/dev/null || true
    fi

    # Output
    if $JSON_MODE; then
        local build_details
        build_details=$(cat << EOF
{
  "tool": "$tool_name",
  "version": "$version",
  "targets": $(echo "$target_list" | tr ' ' '\n' | jq -R . | jq -s .),
  "total": $total,
  "success": $success,
  "failed": $failed,
  "duration_seconds": $duration,
  "output_dir": "$output_dir",
  "manifest": "$manifest_file"
}
EOF
)
        if [[ $failed -eq 0 && $success -gt 0 ]]; then
            json_envelope "build" "success" 0 "$build_details"
        elif [[ $success -gt 0 ]]; then
            json_envelope "build" "partial" 1 "$build_details"
        else
            json_envelope "build" "failed" 6 "$build_details"
        fi
    else
        echo ""
        log_info "=== Build Summary ==="
        log_info "Tool:     $tool_name"
        log_info "Version:  $version"
        log_info "Duration: ${duration}s"
        echo ""
        log_info "Results:"
        log_info "  Total:    $total"
        if [[ $success -gt 0 ]]; then
            log_ok "  Success:  $success"
        else
            log_info "  Success:  $success"
        fi
        if [[ $failed -gt 0 ]]; then
            log_error "  Failed:   $failed"
        else
            log_info "  Failed:   $failed"
        fi
        echo ""
        if [[ -f "$manifest_file" ]]; then
            log_ok "Manifest: $manifest_file"
        fi
        log_info "Artifacts: $output_dir"
    fi

    # Return appropriate exit code
    if [[ $failed -eq 0 && $success -gt 0 ]]; then
        return 0
    elif [[ $success -gt 0 ]]; then
        return 1  # Partial success
    else
        return 6  # All failed
    fi
}

# Quality gates command - run pre-release checks
cmd_quality() {
    local tool_name=""
    local dry_run=false
    local skip_checks=false
    local work_dir=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tool|-t)
                tool_name="$2"
                shift 2
                ;;
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            --skip-checks)
                skip_checks=true
                shift
                ;;
            --work-dir|-w)
                work_dir="$2"
                shift 2
                ;;
            --help|-h)
                cat << 'EOF'
dsr quality - Run pre-release quality checks

USAGE:
    dsr quality --tool <name> [options]

OPTIONS:
    -t, --tool <name>    Tool to check (required)
    -n, --dry-run        Show checks without running them
    --skip-checks        Skip all checks (for testing)
    -w, --work-dir       Directory to run checks in

DESCRIPTION:
    Runs quality gate checks configured in repos.yaml for the specified tool.
    Checks are commands like 'cargo test', 'go vet', etc.

CONFIGURATION:
    Configure checks in ~/.config/dsr/repos.yaml:

    tools:
      ntm:
        checks:
          - "cargo clippy --all-targets -- -D warnings"
          - "cargo test"
          - "cargo fmt --check"

EXAMPLES:
    dsr quality --tool ntm             Run checks for ntm
    dsr quality --tool ntm --dry-run   Show what would run
    dsr quality --tool bv -w /path/to/bv

EXIT CODES:
    0  - All checks passed
    1  - One or more checks failed
    4  - Invalid arguments
EOF
                return 0
                ;;
            *)
                if [[ -z "$tool_name" ]]; then
                    tool_name="$1"
                else
                    log_error "Unknown argument: $1"
                    return 4
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$tool_name" ]]; then
        log_error "Tool name required. Use --tool <name> or provide as first argument."
        log_info "Run 'dsr quality --help' for usage"
        return 4
    fi

    # Build qg_run_checks arguments
    local qg_args=("$tool_name")
    $dry_run && qg_args+=("--dry-run")
    $skip_checks && qg_args+=("--skip-checks")
    [[ -n "$work_dir" ]] && qg_args+=("--work-dir" "$work_dir")

    # Run quality checks
    local result exit_code=0
    result=$(qg_run_checks "${qg_args[@]}") || exit_code=$?

    # Output
    if $JSON_MODE; then
        json_envelope "quality" "$([ $exit_code -eq 0 ] && echo success || echo failure)" "$exit_code" "$result"
    fi

    return $exit_code
}

cmd_release() {
    log_warn "release command not yet implemented"
    log_info "See bead bd-1jt.3.1 for implementation plan"
    return 4
}

cmd_fallback() {
    log_warn "fallback command not yet implemented"
    log_info "See bead bd-1jt.1.4 for implementation plan"
    return 4
}

cmd_repos() {
    local subcmd="${1:-list}"
    shift 2>/dev/null || true

    case "$subcmd" in
        list)
            cmd_repos_list "$@"
            ;;
        add)
            cmd_repos_add "$@"
            ;;
        remove)
            cmd_repos_remove "$@"
            ;;
        info)
            cmd_repos_info "$@"
            ;;
        validate)
            cmd_repos_validate "$@"
            ;;
        discover)
            cmd_repos_discover "$@"
            ;;
        sync)
            cmd_repos_sync "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr repos - Manage repository registry

USAGE:
    dsr repos <subcommand> [options]

SUBCOMMANDS:
    list        List all registered repositories
    add         Add a repository to the registry
    remove      Remove a repository from the registry
    info        Show detailed info for a repository
    validate    Validate repository configurations
    discover    Discover repos that could benefit from dsr
    sync        Sync repository metadata from GitHub

OPTIONS:
    --json      Output in JSON format (global)

EXAMPLES:
    dsr repos list                          List all repos
    dsr repos add ntm --local-path /data/projects/ntm
    dsr repos add dicklesworthstone/bv
    dsr repos remove ntm
    dsr repos info ntm --json
    dsr repos validate
    dsr repos discover --path /data/projects

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            log_error "Unknown repos subcommand: $subcmd"
            log_info "Run 'dsr repos --help' for usage"
            return 4
            ;;
    esac
}

# List all registered repositories
cmd_repos_list() {
    local format="table"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format|-f)
                format="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Load repos config
    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found: $DSR_REPOS_FILE"
        log_info "Run: dsr config init"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 '{"action": "list", "repos": [], "errors": [{"code": "E052", "message": "repos file not found"}]}'
        fi
        return 4
    fi

    local repos_json="[]"
    if command -v yq &>/dev/null; then
        repos_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null | jq -c '
            to_entries | map({
                name: .key,
                repo: (.value.repo // ""),
                local_path: (.value.local_path // ""),
                language: (.value.language // ""),
                targets: (.value.targets // []),
                workflow: (.value.workflow // ""),
                enabled: (.value.enabled // true)
            })
        ' 2>/dev/null || echo "[]")
    else
        # Fallback: simple parsing without yq
        repos_json="[]"
        log_warn "yq not found. Install yq for full repos functionality."
    fi

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson repos "$repos_json" '{action: "list", repos: $repos}')"
    else
        local count
        count=$(echo "$repos_json" | jq 'length')

        if [[ "$count" -eq 0 ]]; then
            log_info "No repositories registered."
            log_info "Run: dsr repos add <owner/repo> --local-path <path>"
            return 0
        fi

        log_info "Registered repositories ($count):"
        echo ""

        if [[ "$format" == "table" ]]; then
            printf "%-12s %-30s %-10s %s\n" "NAME" "REPO" "LANGUAGE" "TARGETS"
            printf "%s\n" "$(printf '%.0s-' {1..80})"
            echo "$repos_json" | jq -r '.[] | [.name, .repo, .language, (.targets | join(","))] | @tsv' | \
                while IFS=$'\t' read -r name repo lang targets; do
                    printf "%-12s %-30s %-10s %s\n" "$name" "$repo" "${lang:-?}" "${targets:-all}"
                done
        else
            echo "$repos_json" | jq -r '.[] | "\(.name): \(.repo)"'
        fi
    fi
}

# Add a repository to the registry
cmd_repos_add() {
    local repo_input=""
    local local_path=""
    local language=""
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --local-path|-p)
                local_path="$2"
                shift 2
                ;;
            --language|-l)
                language="$2"
                shift 2
                ;;
            --name|-n)
                name="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                return 4
                ;;
            *)
                repo_input="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$repo_input" ]]; then
        log_error "Usage: dsr repos add <owner/repo|name> [--local-path <path>] [--language <lang>]"
        return 4
    fi

    # Parse repo input - could be "owner/repo" or just "name"
    local repo
    if [[ "$repo_input" =~ / ]]; then
        repo="$repo_input"
        [[ -z "$name" ]] && name="${repo_input#*/}"
    else
        name="$repo_input"
        repo=""
    fi

    # Validate local_path if provided
    if [[ -n "$local_path" ]]; then
        # Source guardrails for path resolution
        source "$SCRIPT_DIR/src/guardrails.sh"
        local_path=$(resolve_path "$local_path" 2>&1) || {
            log_error "Invalid local path: $local_path"
            if $JSON_MODE; then
                json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "add", repo: $name, errors: [{code: "E052", message: "invalid local path"}]}')"
            fi
            return 4
        }

        # Auto-detect language if not specified
        if [[ -z "$language" && -d "$local_path" ]]; then
            if [[ -f "$local_path/Cargo.toml" ]]; then
                language="rust"
            elif [[ -f "$local_path/go.mod" ]]; then
                language="go"
            elif [[ -f "$local_path/package.json" ]]; then
                if [[ -f "$local_path/bun.lockb" ]]; then
                    language="bun"
                else
                    language="node"
                fi
            elif [[ -f "$local_path/pyproject.toml" || -f "$local_path/setup.py" ]]; then
                language="python"
            fi
        fi

        # Auto-detect repo from git remote if not specified
        if [[ -z "$repo" && -d "$local_path/.git" ]]; then
            local remote_url
            remote_url=$(git -C "$local_path" remote get-url origin 2>/dev/null || true)
            if [[ -n "$remote_url" ]]; then
                # Parse owner/repo from git URL
                repo=$(echo "$remote_url" | sed -E 's#.*(github\.com[:/])([^/]+/[^/]+)(\.git)?$#\2#')
                repo="${repo%.git}"
            fi
        fi
    fi

    # Check if yq is available for writing
    if ! command -v yq &>/dev/null; then
        log_error "yq is required to add repositories"
        log_info "Install: brew install yq  OR  apt install yq"
        if $JSON_MODE; then
            json_envelope "repos" "error" 3 '{"action": "add", "errors": [{"code": "E041", "message": "yq required"}]}'
        fi
        return 3
    fi

    # Ensure repos file exists
    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_warn "Repos file not found, running config init..."
        config_init >/dev/null 2>&1
    fi

    # Check if already exists
    local existing
    existing=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    if [[ "$existing" != "null" && -n "$existing" ]]; then
        log_error "Repository '$name' already exists"
        log_info "Use 'dsr repos remove $name' first, or choose a different name"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "add", repo: $name, errors: [{code: "E052", message: "repo already exists"}]}')"
        fi
        return 4
    fi

    # Build the tool entry
    local tool_yaml=""
    tool_yaml+="repo: \"${repo:-}\""
    [[ -n "$local_path" ]] && tool_yaml+="\n    local_path: \"$local_path\""
    [[ -n "$language" ]] && tool_yaml+="\n    language: \"$language\""
    tool_yaml+="\n    targets:\n      - linux/amd64\n      - darwin/arm64\n      - windows/amd64"

    # Add to repos.yaml using yq
    yq -i ".tools.$name = {}" "$DSR_REPOS_FILE"
    [[ -n "$repo" ]] && yq -i ".tools.$name.repo = \"$repo\"" "$DSR_REPOS_FILE"
    [[ -n "$local_path" ]] && yq -i ".tools.$name.local_path = \"$local_path\"" "$DSR_REPOS_FILE"
    [[ -n "$language" ]] && yq -i ".tools.$name.language = \"$language\"" "$DSR_REPOS_FILE"
    yq -i ".tools.$name.targets = [\"linux/amd64\", \"darwin/arm64\", \"windows/amd64\"]" "$DSR_REPOS_FILE"

    if $JSON_MODE; then
        local added_json
        added_json=$(jq -nc \
            --arg name "$name" \
            --arg repo "${repo:-}" \
            --arg local_path "${local_path:-}" \
            --arg language "${language:-}" \
            '{name: $name, repo: $repo, local_path: $local_path, language: $language, targets: ["linux/amd64", "darwin/arm64", "windows/amd64"]}')
        json_envelope "repos" "success" 0 "$(jq -nc --argjson added "[$added_json]" '{action: "add", added: $added}')"
    else
        log_ok "Added repository: $name"
        [[ -n "$repo" ]] && log_info "  repo: $repo"
        [[ -n "$local_path" ]] && log_info "  local_path: $local_path"
        [[ -n "$language" ]] && log_info "  language: $language"
    fi
}

# Remove a repository from the registry
cmd_repos_remove() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: dsr repos remove <name>"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq is required to remove repositories"
        if $JSON_MODE; then
            json_envelope "repos" "error" 3 '{"action": "remove", "errors": [{"code": "E041", "message": "yq required"}]}'
        fi
        return 3
    fi

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    # Check if exists
    local existing
    existing=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    if [[ "$existing" == "null" || -z "$existing" ]]; then
        log_error "Repository '$name' not found"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "remove", repo: $name, errors: [{code: "E052", message: "repo not found"}]}')"
        fi
        return 4
    fi

    # Remove from repos.yaml
    yq -i "del(.tools.$name)" "$DSR_REPOS_FILE"

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --arg name "$name" '{action: "remove", removed: [{name: $name}]}')"
    else
        log_ok "Removed repository: $name"
    fi
}

# Show detailed info for a repository
cmd_repos_info() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: dsr repos info <name>"
        return 4
    fi

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    local tool_yaml
    if command -v yq &>/dev/null; then
        tool_yaml=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    else
        log_error "yq required for repos info"
        return 3
    fi

    if [[ "$tool_yaml" == "null" || -z "$tool_yaml" ]]; then
        log_error "Repository '$name' not found"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "info", repo: $name, errors: [{code: "E052", message: "repo not found"}]}')"
        fi
        return 4
    fi

    local tool_json
    tool_json=$(yq -o=json ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null | jq -c --arg name "$name" '. + {name: $name}')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson repos "[$tool_json]" --arg name "$name" '{action: "info", repo: $name, repos: $repos}')"
    else
        log_info "Repository: $name"
        echo ""
        echo "$tool_json" | jq -r 'to_entries[] | "  \(.key): \(.value)"'
    fi
}

# Validate repository configurations
cmd_repos_validate() {
    local repo_filter="${1:-}"

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq required for validation"
        return 3
    fi

    local tools_json
    tools_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null)

    local results=()
    local errors=0
    local warnings=0

    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        [[ -n "$repo_filter" && "$name" != "$repo_filter" ]] && continue

        local tool_json
        tool_json=$(echo "$tools_json" | jq -c --arg name "$name" '.[$name]')

        local status="ok"
        local messages=()

        # Check required fields
        local repo local_path
        repo=$(echo "$tool_json" | jq -r '.repo // ""')
        local_path=$(echo "$tool_json" | jq -r '.local_path // ""')

        if [[ -z "$repo" && -z "$local_path" ]]; then
            status="error"
            messages+=("Missing both 'repo' and 'local_path' - need at least one")
            ((errors++))
        fi

        # Check local_path exists
        if [[ -n "$local_path" ]]; then
            source "$SCRIPT_DIR/src/guardrails.sh"
            local resolved_path
            resolved_path=$(resolve_path "$local_path" 2>/dev/null) || {
                status="error"
                messages+=("Invalid local_path: $local_path")
                ((errors++))
            }
            if [[ -n "$resolved_path" && ! -d "$resolved_path" ]]; then
                status="warn"
                messages+=("local_path does not exist: $resolved_path")
                ((warnings++))
            fi
        fi

        # Check workflow file exists
        local workflow
        workflow=$(echo "$tool_json" | jq -r '.workflow // ""')
        if [[ -n "$workflow" && -n "$local_path" ]]; then
            source "$SCRIPT_DIR/src/guardrails.sh"
            local resolved_path
            resolved_path=$(resolve_path "$local_path" 2>/dev/null) || true
            if [[ -n "$resolved_path" && ! -f "$resolved_path/$workflow" ]]; then
                if [[ "$status" != "error" ]]; then
                    status="warn"
                fi
                messages+=("Workflow file not found: $workflow")
                ((warnings++))
            fi
        fi

        local msg_str=""
        [[ ${#messages[@]} -gt 0 ]] && msg_str=$(IFS='; '; echo "${messages[*]}")

        results+=("$(jq -nc --arg repo "$name" --arg status "$status" --arg message "$msg_str" \
            '{repo: $repo, status: $status, message: $message}')")

        if ! $JSON_MODE; then
            if [[ "$status" == "ok" ]]; then
                log_ok "$name: OK"
            elif [[ "$status" == "warn" ]]; then
                log_warn "$name: $msg_str"
            else
                log_error "$name: $msg_str"
            fi
        fi

    done < <(echo "$tools_json" | jq -r 'keys[]')

    local results_json
    results_json=$(printf '%s\n' "${results[@]}" | jq -sc '.')

    if $JSON_MODE; then
        local status="success"
        local exit_code=0
        if [[ $errors -gt 0 ]]; then
            status="error"
            exit_code=1
        elif [[ $warnings -gt 0 ]]; then
            status="partial"
        fi
        json_envelope "repos" "$status" "$exit_code" "$(jq -nc --argjson validated "$results_json" '{action: "validate", validated: $validated}')"
    else
        echo ""
        if [[ $errors -gt 0 ]]; then
            log_error "Validation found $errors error(s), $warnings warning(s)"
            return 1
        elif [[ $warnings -gt 0 ]]; then
            log_warn "Validation found $warnings warning(s)"
        else
            log_ok "All repositories validated successfully"
        fi
    fi
}

# Discover repositories that could benefit from dsr
cmd_repos_discover() {
    local search_path="/data/projects"
    local apply=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --path|-p)
                search_path="$2"
                shift 2
                ;;
            --apply)
                apply=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Validate search path
    source "$SCRIPT_DIR/src/guardrails.sh"
    # shellcheck disable=SC2034 # Used by guardrails is_non_interactive
    [[ "$NON_INTERACTIVE" == "true" ]] && DSR_NON_INTERACTIVE=true
    search_path=$(resolve_path "$search_path" --must-exist 2>&1) || {
        log_error "Invalid search path: $search_path"
        return 4
    }

    log_info "Scanning $search_path for buildable projects..."

    local discovered=()

    # Find directories with build files
    while IFS= read -r dir; do
        local name
        name=$(basename "$dir")
        local language=""
        local repo=""

        # Detect language
        if [[ -f "$dir/Cargo.toml" ]]; then
            language="rust"
        elif [[ -f "$dir/go.mod" ]]; then
            language="go"
        elif [[ -f "$dir/package.json" ]]; then
            language="node"
        else
            continue
        fi

        # Get repo from git remote
        if [[ -d "$dir/.git" ]]; then
            local remote_url
            remote_url=$(git -C "$dir" remote get-url origin 2>/dev/null || true)
            if [[ -n "$remote_url" ]]; then
                repo=$(echo "$remote_url" | sed -E 's#.*(github\.com[:/])([^/]+/[^/]+)(\.git)?$#\2#')
                repo="${repo%.git}"
            fi
        fi

        # Check if has release workflow
        local has_workflow=false
        if [[ -d "$dir/.github/workflows" ]]; then
            if grep -l -E 'release|build' "$dir/.github/workflows/"*.yml "$dir/.github/workflows/"*.yaml 2>/dev/null | head -1 >/dev/null; then
                has_workflow=true
            fi
        fi

        local entry
        entry=$(jq -nc \
            --arg name "$name" \
            --arg repo "${repo:-}" \
            --arg local_path "$dir" \
            --arg language "$language" \
            --argjson has_workflow "$has_workflow" \
            '{name: $name, repo: $repo, local_path: $local_path, language: $language, has_workflow: $has_workflow}')

        discovered+=("$entry")

        if ! $JSON_MODE; then
            local workflow_indicator="  "
            $has_workflow && workflow_indicator="✓ "
            log_info "$workflow_indicator$name ($language) - $dir"
        fi

    done < <(find "$search_path" -maxdepth 2 -type f \( -name "Cargo.toml" -o -name "go.mod" -o -name "package.json" \) -print0 2>/dev/null | xargs -0 -I{} dirname {} | sort -u)

    local discovered_json
    discovered_json=$(printf '%s\n' "${discovered[@]}" | jq -sc '.')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson discovered "$discovered_json" '{action: "discover", discovered: $discovered}')"
    else
        echo ""
        local count
        count=$(echo "$discovered_json" | jq 'length')
        log_info "Discovered $count potential repositories"
        if [[ $count -gt 0 ]] && ! $apply; then
            log_info "Run with --apply to add them to the registry"
        fi
    fi

    # Apply if requested
    if $apply && [[ ${#discovered[@]} -gt 0 ]]; then
        log_info "Adding discovered repositories..."
        for entry in "${discovered[@]}"; do
            local name repo local_path language
            name=$(echo "$entry" | jq -r '.name')
            repo=$(echo "$entry" | jq -r '.repo // ""')
            local_path=$(echo "$entry" | jq -r '.local_path')
            language=$(echo "$entry" | jq -r '.language')

            cmd_repos_add "$name" --local-path "$local_path" --language "$language" 2>/dev/null || true
        done
    fi
}

# Sync repository metadata from GitHub
cmd_repos_sync() {
    log_info "Syncing repository metadata from GitHub..."

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq required for sync"
        return 3
    fi

    local tools_json
    tools_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null)

    local synced=0
    local failed=0

    while IFS= read -r name; do
        [[ -z "$name" ]] && continue

        local repo
        repo=$(echo "$tools_json" | jq -r --arg name "$name" '.[$name].repo // ""')

        if [[ -z "$repo" ]]; then
            log_warn "$name: no repo configured, skipping"
            continue
        fi

        log_info "Syncing $name ($repo)..."

        # Fetch repo info from GitHub
        if gh_check 2>/dev/null || gh_check_token 2>/dev/null; then
            local repo_info
            repo_info=$(gh_repo "$repo" 2>/dev/null) || {
                log_warn "$name: failed to fetch repo info"
                ((failed++))
                continue
            }

            local default_branch
            default_branch=$(echo "$repo_info" | jq -r '.default_branch // "main"')

            # Update the entry with synced data
            yq -i ".tools.$name.default_branch = \"$default_branch\"" "$DSR_REPOS_FILE"
            ((synced++))
            log_ok "$name: synced (default_branch: $default_branch)"
        else
            log_warn "$name: GitHub auth not available"
            ((failed++))
        fi

    done < <(echo "$tools_json" | jq -r 'keys[]')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson synced "$synced" --argjson failed "$failed" '{action: "sync", synced: $synced, failed: $failed}')"
    else
        echo ""
        log_info "Sync complete: $synced synced, $failed failed"
    fi
}

# ============================================================================
# HEALTH SUBCOMMAND
# ============================================================================

cmd_health() {
    local subcmd="${1:-check}"
    shift 2>/dev/null || true

    case "$subcmd" in
        check)
            cmd_health_check "$@"
            ;;
        all)
            cmd_health_all "$@"
            ;;
        clear-cache)
            cmd_health_clear_cache "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr health - Check health of build hosts

USAGE:
    dsr health <subcommand> [options]

SUBCOMMANDS:
    check <host>    Check specific host health
    all             Check all configured hosts
    clear-cache     Clear health check cache

OPTIONS:
    --no-cache      Skip cache and perform fresh checks
    --json          Output in JSON format (global)

CHECKS PERFORMED:
    - SSH connectivity (short timeout + BatchMode)
    - Disk space threshold (warn >90%, error >95%)
    - Toolchain availability (rust/go/bun per host)
    - Docker/Colima for act runners
    - Clock drift detection

EXAMPLES:
    dsr health check trj            Check local Threadripper
    dsr health check mmini          Check Mac Mini via SSH
    dsr health all                  Check all build hosts
    dsr health all --no-cache       Force fresh checks
    dsr health clear-cache          Clear cached results

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            # Treat as hostname if not a subcommand
            cmd_health_check "$subcmd" "$@"
            ;;
    esac
}

cmd_health_check() {
    local hostname="${1:-}"
    shift 2>/dev/null || true
    local no_cache=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-cache) no_cache=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$hostname" ]]; then
        log_error "Usage: dsr health check <hostname>"
        return 4
    fi

    local flags=""
    $no_cache && flags+=" --no-cache"
    $JSON_MODE && flags+=" --json"

    # shellcheck disable=SC2086  # flags needs word splitting
    host_health_check "$hostname" $flags
}

cmd_health_all() {
    local no_cache=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-cache) no_cache=true; shift ;;
            *) shift ;;
        esac
    done

    local flags=""
    $no_cache && flags+=" --no-cache"
    $JSON_MODE && flags+=" --json"

    # shellcheck disable=SC2086  # flags needs word splitting
    host_health_check_all $flags
}

cmd_health_clear_cache() {
    local hostname="${1:-}"
    host_health_clear_cache "$hostname"

    if $JSON_MODE; then
        if [[ -n "$hostname" ]]; then
            json_envelope "health" "success" 0 "{\"action\": \"clear-cache\", \"host\": \"$hostname\"}"
        else
            json_envelope "health" "success" 0 '{"action": "clear-cache", "all": true}'
        fi
    else
        if [[ -n "$hostname" ]]; then
            log_ok "Cleared health cache for: $hostname"
        else
            log_ok "Cleared all health cache"
        fi
    fi
}

# ============================================================================
# PRUNE SUBCOMMAND
# ============================================================================

_prune_size_bytes() {
    local path="$1"
    if [[ -f "$path" ]]; then
        stat -c%s "$path" 2>/dev/null || stat -f%z "$path" 2>/dev/null || echo 0
        return 0
    fi
    if [[ -d "$path" ]]; then
        local kb
        kb=$(du -sk "$path" 2>/dev/null | awk '{print $1}' || echo 0)
        echo $((kb * 1024))
        return 0
    fi
    echo 0
}

_prune_mtime_epoch() {
    local path="$1"
    stat -c%Y "$path" 2>/dev/null || stat -f%m "$path" 2>/dev/null || echo 0
}

_prune_epoch_to_iso() {
    local epoch="$1"
    if date -u -d "@$epoch" +"%Y-%m-%dT%H:%M:%SZ" >/dev/null 2>&1; then
        date -u -d "@$epoch" +"%Y-%m-%dT%H:%M:%SZ"
        return 0
    fi
    date -u -r "$epoch" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo ""
}

_prune_log_file() {
    local msg="$1"
    local path="$2"
    local size_bytes="$3"
    local log_file="${LOG_FILE:-}"

    [[ -z "$log_file" ]] && return 0

    local ts escaped_msg escaped_path
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    escaped_msg=$(_json_escape "$msg")
    escaped_path=$(_json_escape "$path")

    cat >> "$log_file" << EOF
{"ts":"$ts","run_id":"$DSR_RUN_ID","level":"info","cmd":"prune","msg":"$escaped_msg","event":"prune","path":"$escaped_path","size_bytes":$size_bytes}
EOF
}

cmd_prune() {
    local dry_run=false
    local max_age_days=30
    local keep_last=5
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            --max-age|--cutoff-days)
                max_age_days="${2:-}"
                shift 2
                ;;
            --keep-last)
                keep_last="${2:-}"
                shift 2
                ;;
            --force|--yes|-y)
                force=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr prune - Clean up old artifacts, logs, and cache

USAGE:
    dsr prune [options]

OPTIONS:
    -n, --dry-run       Show what would be removed without deleting
        --max-age DAYS  Remove items older than DAYS (default: 30)
        --keep-last N   Keep the most recent N build runs per tool/version (default: 5)
        --force         Skip confirmation prompt

EXAMPLES:
    dsr prune --dry-run
    dsr prune --max-age 14 --keep-last 3
EOF
                return 0
                ;;
            *)
                log_error "Unknown option: $1"
                log_info "Run 'dsr prune --help' for usage"
                return 4
                ;;
        esac
    done

    if [[ -z "$max_age_days" || ! "$max_age_days" =~ ^[0-9]+$ ]]; then
        log_error "Invalid --max-age: $max_age_days"
        return 4
    fi
    if [[ -z "$keep_last" || ! "$keep_last" =~ ^[0-9]+$ ]]; then
        log_error "Invalid --keep-last: $keep_last"
        return 4
    fi

    source "$SCRIPT_DIR/src/guardrails.sh"

    local state_dir cache_dir
    state_dir=$(resolve_path "$DSR_STATE_DIR" 2>/dev/null || echo "$DSR_STATE_DIR")
    cache_dir=$(resolve_path "$DSR_CACHE_DIR" 2>/dev/null || echo "$DSR_CACHE_DIR")

    if [[ ! -d "$state_dir" ]]; then
        log_error "State directory not found: $state_dir"
        if $JSON_MODE; then
            json_envelope "prune" "error" 4 "{\"state_dir\": \"$state_dir\", \"dry_run\": $dry_run, \"pruned_count\": 0, \"bytes_freed\": 0}"
        fi
        return 4
    fi

    if [[ ! -d "$cache_dir" ]]; then
        if ! $JSON_MODE; then
            log_warn "Cache directory not found: $cache_dir (skipping cache cleanup)"
        fi
    fi

    if ! $dry_run && ! $force; then
        if ! confirm "Prune old artifacts and cache in $state_dir and $cache_dir?" "n"; then
            if $JSON_MODE; then
                json_envelope "prune" "error" 5 "{\"state_dir\": \"$state_dir\", \"dry_run\": $dry_run, \"pruned_count\": 0, \"bytes_freed\": 0}"
            fi
            return 5
        fi
    fi

    local now_epoch cutoff_epoch
    now_epoch=$(date +%s)
    cutoff_epoch=$((now_epoch - max_age_days * 86400))

    local pruned_count=0
    local bytes_freed=0
    local pruned_items=()
    local errors=()

    _prune_record() {
        local path="$1"
        local size_bytes="$2"
        local mtime_iso="$3"
        pruned_items+=("{\"path\":\"$(_json_escape "$path")\",\"size_bytes\":$size_bytes,\"mtime\":\"$mtime_iso\"}")
        pruned_count=$((pruned_count + 1))
        bytes_freed=$((bytes_freed + size_bytes))
        if ! $JSON_MODE; then
            echo "$path"
        fi
    }

    _prune_error() {
        local code="$1"
        local message="$2"
        local path="$3"
        errors+=("{\"code\":\"$code\",\"message\":\"$(_json_escape "$message")\",\"path\":\"$(_json_escape "$path")\"}")
        if ! $JSON_MODE; then
            log_warn "$message: $path"
        fi
    }

    _prune_consider() {
        local path="$1"
        [[ -z "$path" ]] && return 0

        local size_bytes mtime_epoch mtime_iso
        size_bytes=$(_prune_size_bytes "$path")
        mtime_epoch=$(_prune_mtime_epoch "$path")
        mtime_iso=$(_prune_epoch_to_iso "$mtime_epoch")

        if $dry_run; then
            _prune_record "$path" "$size_bytes" "$mtime_iso"
            return 0
        fi

        if safe_rm "$path" --force; then
            _prune_record "$path" "$size_bytes" "$mtime_iso"
            _prune_log_file "Pruned path" "$path" "$size_bytes"
            if ! $JSON_MODE; then
                log_info "Pruned: $path"
            fi
            return 0
        fi

        _prune_error "E051" "Failed to delete" "$path"
        return 1
    }

    if ! $JSON_MODE; then
        $dry_run && log_info "Dry run: scanning for items older than $max_age_days days..."
        $dry_run || log_info "Pruning items older than $max_age_days days..."
    fi

    # Prune old logs
    if [[ -d "$state_dir/logs" ]]; then
        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$state_dir/logs" -mindepth 1 -maxdepth 1 -type d -mtime +"$max_age_days" 2>/dev/null)

        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$state_dir/logs" -type f -mtime +"$max_age_days" 2>/dev/null)
    fi

    # Prune old manifests
    if [[ -d "$state_dir/manifests" ]]; then
        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$state_dir/manifests" -type f -mtime +"$max_age_days" 2>/dev/null)
    fi

    # Prune old artifacts (by version directories)
    if [[ -d "$state_dir/artifacts" ]]; then
        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$state_dir/artifacts" -mindepth 2 -maxdepth 2 -type d -mtime +"$max_age_days" 2>/dev/null)
    fi

    # Prune old build runs beyond keep_last
    if [[ -d "$state_dir/builds" ]]; then
        local tool_dir version_dir
        for tool_dir in "$state_dir/builds"/*; do
            [[ -d "$tool_dir" ]] || continue
            for version_dir in "$tool_dir"/*; do
                [[ -d "$version_dir" ]] || continue

                local run_dirs=()
                while IFS= read -r line; do
                    run_dirs+=("$line")
                done < <(
                    find "$version_dir" -maxdepth 1 -type d -name 'run-*' 2>/dev/null | while read -r dir; do
                        local mtime
                        mtime=$(_prune_mtime_epoch "$dir")
                        echo "$mtime $dir"
                    done | sort -rn | awk '{print $2}'
                )

                local idx=0
                for run_dir in "${run_dirs[@]}"; do
                    idx=$((idx + 1))
                    if [[ $idx -le $keep_last ]]; then
                        continue
                    fi
                    local run_mtime
                    run_mtime=$(_prune_mtime_epoch "$run_dir")
                    if [[ "$run_mtime" -le "$cutoff_epoch" ]]; then
                        _prune_consider "$run_dir"
                    fi
                done
            done
        done
    fi

    # Prune cache entries
    if [[ -d "$cache_dir" ]]; then
        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$cache_dir" -mindepth 1 -maxdepth 1 -mtime +"$max_age_days" 2>/dev/null)
    fi

    local pruned_json errors_json details_json
    pruned_json=$(printf '%s\n' "${pruned_items[@]}" | jq -sc '.' 2>/dev/null || echo "[]")
    errors_json=$(printf '%s\n' "${errors[@]}" | jq -sc '.' 2>/dev/null || echo "[]")

    local status="success"
    local exit_code=0
    if [[ "${#errors[@]}" -gt 0 ]]; then
        status="partial"
        exit_code=1
    fi

    if $JSON_MODE; then
        details_json=$(jq -nc \
            --arg state_dir "$state_dir" \
            --argjson dry_run "$dry_run" \
            --argjson cutoff_days "$max_age_days" \
            --argjson keep_last "$keep_last" \
            --argjson pruned_count "$pruned_count" \
            --argjson bytes_freed "$bytes_freed" \
            --argjson pruned_paths "$pruned_json" \
            --argjson errors "$errors_json" \
            '{state_dir: $state_dir, dry_run: $dry_run, cutoff_days: $cutoff_days, keep_last: $keep_last, pruned_count: $pruned_count, bytes_freed: $bytes_freed, pruned_paths: $pruned_paths, errors: $errors}')
        json_envelope "prune" "$status" "$exit_code" "$details_json"
    else
        if $dry_run; then
            log_info "Dry run complete: $pruned_count item(s) would be removed, ${bytes_freed} bytes freed"
        else
            log_info "Prune complete: $pruned_count item(s) removed, ${bytes_freed} bytes freed"
        fi
    fi

    return $exit_code
}

# ============================================================================
# STATUS SUBCOMMAND
# ============================================================================

# Get last run info from log directory
_status_get_last_run() {
    local state_dir="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
    local log_dir="$state_dir/logs"
    local latest_link="$log_dir/latest"

    if [[ ! -L "$latest_link" ]]; then
        echo '{"run_id": null, "timestamp": null, "log_file": null}'
        return
    fi

    local latest_date
    latest_date=$(readlink "$latest_link" 2>/dev/null)
    local run_log="$log_dir/$latest_date/run.log"

    if [[ ! -f "$run_log" ]]; then
        echo '{"run_id": null, "timestamp": null, "log_file": null}'
        return
    fi

    # Extract run_id and timestamp from last session start
    local last_entry
    last_entry=$(grep '"msg":"Session started"' "$run_log" 2>/dev/null | tail -1)

    if [[ -n "$last_entry" ]]; then
        local run_id ts
        run_id=$(echo "$last_entry" | jq -r '.run_id // empty')
        ts=$(echo "$last_entry" | jq -r '.ts // empty')
        jq -nc --arg run_id "$run_id" --arg ts "$ts" --arg log "$run_log" \
            '{run_id: $run_id, timestamp: $ts, log_file: $log}'
    else
        echo '{"run_id": null, "timestamp": null, "log_file": null}'
    fi
}

# Get config summary
_status_get_config() {
    local config_file="${DSR_CONFIG_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/dsr}/config.yaml"

    if [[ ! -f "$config_file" ]]; then
        echo '{"valid": false, "path": null}'
        return
    fi

    echo "{\"valid\": true, \"path\": \"$config_file\"}"
}

# Get signing status
_status_get_signing() {
    local private_key="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/secrets/minisign.key"
    local public_key="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/minisign.pub"

    local configured=false
    if [[ -f "$private_key" && -f "$public_key" ]]; then
        configured=true
    fi

    echo "{\"configured\": $configured}"
}

# Status command
cmd_status() {
    local refresh=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --refresh|-r)
                refresh=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr status - System and last run summary

USAGE:
    dsr status [options]

OPTIONS:
    --refresh, -r    Refresh host health (makes network calls)
    --json           JSON output (global flag)

DESCRIPTION:
    Shows a quick summary of:
    - Last run information (run_id, timestamp)
    - Configuration status
    - Host health (from cache by default)
    - Signing configuration

    By default, status is read from local state only (<1s).
    Use --refresh to update host health checks.

EXAMPLES:
    dsr status                Show cached status
    dsr status --refresh      Refresh host health
    dsr status --json         Machine-readable output
EOF
                return 0
                ;;
            *)
                log_error "Unknown option: $1"
                return 4
                ;;
        esac
    done

    # Collect status information
    local last_run config_status signing_status hosts_status

    last_run=$(_status_get_last_run)
    config_status=$(_status_get_config)
    signing_status=$(_status_get_signing)

    # Get host health (refresh if requested)
    if $refresh; then
        log_info "Refreshing host health..."
        hosts_status=$(host_health_check_all 2>/dev/null | jq -c '.')
    else
        # Try to get from cache, fallback to empty
        local cache_dir="${DSR_CACHE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}/dsr}/health"
        if [[ -d "$cache_dir" ]] && ls "$cache_dir"/*.json &>/dev/null; then
            hosts_status=$(cat "$cache_dir"/*.json 2>/dev/null | jq -s 'map({(.hostname): .}) | add' 2>/dev/null) || hosts_status='{}'
        else
            hosts_status='{}'
        fi
    fi

    # Ensure hosts_status is valid JSON
    if [[ -z "$hosts_status" ]] || ! echo "$hosts_status" | jq -e . &>/dev/null; then
        hosts_status='{}'
    fi

    # Build JSON output
    local json_output
    json_output=$(jq -nc \
        --argjson last_run "$last_run" \
        --argjson config "$config_status" \
        --argjson signing "$signing_status" \
        --argjson hosts "$hosts_status" \
        '{
            last_run: $last_run,
            config: $config,
            signing: $signing,
            hosts: $hosts
        }' 2>/dev/null) || json_output='{}'

    if $JSON_MODE; then
        json_envelope "status" "success" 0 "$json_output"
    else
        # Human-readable output
        echo ""
        log_info "=== DSR Status ==="
        echo ""

        # Last run
        local run_id ts
        run_id=$(echo "$last_run" | jq -r '.run_id // "none"')
        ts=$(echo "$last_run" | jq -r '.timestamp // "never"')

        if [[ "$run_id" != "null" && "$run_id" != "none" ]]; then
            log_info "Last Run:"
            log_info "  Run ID:    $run_id"
            log_info "  Timestamp: $ts"
        else
            log_info "Last Run: no runs recorded"
        fi
        echo ""

        # Config
        local config_valid config_path
        config_valid=$(echo "$config_status" | jq -r '.valid')
        config_path=$(echo "$config_status" | jq -r '.path // "not found"')

        log_info "Configuration:"
        if [[ "$config_valid" == "true" ]]; then
            log_ok "  Config: valid ($config_path)"
        else
            log_warn "  Config: not found (run 'dsr config init')"
        fi
        echo ""

        # Signing
        local signing_configured
        signing_configured=$(echo "$signing_status" | jq -r '.configured')

        log_info "Signing:"
        if [[ "$signing_configured" == "true" ]]; then
            log_ok "  Keypair: configured"
        else
            log_warn "  Keypair: not configured (run 'dsr signing init')"
        fi
        echo ""

        # Hosts (if any cached)
        if [[ -n "$hosts_status" && "$hosts_status" != "{}" && "$hosts_status" != "null" ]]; then
            log_info "Build Hosts (cached):"
            echo "$hosts_status" | jq -r 'to_entries[] | "  \(.key): \(.value.status // "unknown")"' 2>/dev/null || true
        else
            log_info "Build Hosts: no cached status (use --refresh)"
        fi
        echo ""
    fi

    return 0
}

# ============================================================================
# VERSION SUBCOMMAND
# ============================================================================

cmd_version() {
    local subcmd="${1:-detect}"
    shift 2>/dev/null || true

    case "$subcmd" in
        detect)
            # dsr version detect <tool|path>
            local target="${1:-}"
            local repo_path=""

            if [[ -z "$target" ]]; then
                log_error "Usage: dsr version detect <tool|path>"
                return 4
            fi

            # Resolve target to repo path
            if [[ -d "$target" ]]; then
                repo_path="$target"
            else
                # Try to find tool in repos.d
                local config_file="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/repos.d/${target}.yaml"
                if [[ -f "$config_file" ]] && command -v yq &>/dev/null; then
                    repo_path=$(yq -r '.local_path // ""' "$config_file" 2>/dev/null)
                fi
            fi

            if [[ -z "$repo_path" || ! -d "$repo_path" ]]; then
                log_error "Cannot resolve target to repository: $target"
                return 4
            fi

            if $JSON_MODE; then
                local json_result
                json_result=$(version_info_json "$repo_path")
                json_envelope "version detect" "success" 0 "$json_result"
            else
                local version
                if version=$(version_detect "$repo_path"); then
                    log_ok "Version: $version (v$version)"
                    if version_needs_tag "$repo_path"; then
                        log_info "Tag v$version does not exist (create with: dsr version tag $target)"
                    else
                        log_info "Tag v$version already exists"
                    fi
                else
                    log_error "No version file found in $repo_path"
                    return 1
                fi
            fi
            ;;

        tag)
            # dsr version tag <tool|path> [--push] [--all]
            local target="${1:-}"
            local push=false
            local tag_all=false

            # Parse options
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --push) push=true; shift ;;
                    --all) tag_all=true; shift ;;
                    --dry-run|-n) shift ;;  # Already handled by global DRY_RUN
                    -*) shift ;;
                    *)
                        if [[ -z "$target" || "$target" == --* ]]; then
                            target="$1"
                        fi
                        shift
                        ;;
                esac
            done

            if $tag_all; then
                # Tag all configured tools
                local args=""
                $push && args+=" --push"
                $DRY_RUN && args+=" --dry-run"
                $JSON_MODE && args+=" --json"
                # shellcheck disable=SC2086
                version_tag_all $args
                return $?
            fi

            if [[ -z "$target" ]]; then
                log_error "Usage: dsr version tag <tool|path> [--push]"
                log_error "       dsr version tag --all [--push]"
                return 4
            fi

            # Resolve target to repo path
            local repo_path=""
            if [[ -d "$target" ]]; then
                repo_path="$target"
            else
                local config_file="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/repos.d/${target}.yaml"
                if [[ -f "$config_file" ]] && command -v yq &>/dev/null; then
                    repo_path=$(yq -r '.local_path // ""' "$config_file" 2>/dev/null)
                fi
            fi

            if [[ -z "$repo_path" || ! -d "$repo_path" ]]; then
                log_error "Cannot resolve target to repository: $target"
                return 4
            fi

            local tag_args=""
            $push && tag_args+=" --push"
            $DRY_RUN && tag_args+=" --dry-run"

            # shellcheck disable=SC2086
            if version_create_tag "$repo_path" $tag_args; then
                if $JSON_MODE; then
                    local json_result
                    json_result=$(version_info_json "$repo_path")
                    json_envelope "version tag" "success" 0 "$json_result"
                fi
                return 0
            else
                return 1
            fi
            ;;

        --help|-h|help)
            cat << 'EOF'
dsr version - Detect and tag versions from version files

USAGE:
    dsr version <subcommand> [options]

SUBCOMMANDS:
    detect <tool|path>      Show version from version files
    tag <tool|path>         Create git tag for detected version
    tag --all               Tag all configured tools with new versions

OPTIONS:
    --push          Push tags to remote after creation
    --dry-run       Show planned actions without executing

VERSION SOURCES:
    Rust        Cargo.toml       version = "X.Y.Z"
    Go          VERSION, *.go    Version = "X.Y.Z"
    Node/Bun    package.json     "version": "X.Y.Z"
    Python      pyproject.toml   version = "X.Y.Z"

EXAMPLES:
    dsr version detect ntm          Show version for ntm tool
    dsr version detect /path/to/repo
    dsr version tag ntm --push      Create and push tag
    dsr version tag --all           Tag all tools needing tags
    dsr version tag --all --push    Tag and push all

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;

        *)
            log_error "Unknown version subcommand: $subcmd"
            log_info "Run 'dsr version --help' for usage"
            return 4
            ;;
    esac
}

# ============================================================================
# SIGNING SUBCOMMAND
# ============================================================================

cmd_signing() {
    local subcmd="${1:-check}"
    shift 2>/dev/null || true

    case "$subcmd" in
        init)
            signing_init "$@"
            ;;
        check)
            if $JSON_MODE; then
                signing_check --json
            else
                signing_check
            fi
            ;;
        sign)
            signing_sign "$@"
            ;;
        verify)
            signing_verify "$@"
            ;;
        fix)
            signing_fix_permissions
            ;;
        pubkey|public-key)
            signing_get_public_key "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr signing - Manage minisign keys and artifact signing

USAGE:
    dsr signing <subcommand> [options]

SUBCOMMANDS:
    init        Generate new keypair (interactive)
    check       Verify keypair is configured
    sign        Sign a file
    verify      Verify a file signature
    fix         Fix private key permissions
    pubkey      Display public key

EXAMPLES:
    dsr signing init              Generate new keypair
    dsr signing check             Check if keys are configured
    dsr signing sign artifact.tar.gz
    dsr signing verify artifact.tar.gz
    dsr signing pubkey --oneline  Get public key for embedding

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            log_error "Unknown signing subcommand: $subcmd"
            log_info "Run 'dsr signing --help' for usage"
            return 4
            ;;
    esac
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    # shellcheck disable=SC2034  # DRY_RUN/NON_INTERACTIVE reserved for future use
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json|-j)
                JSON_MODE=true
                shift
                ;;
            --dry-run|-n)
                DRY_RUN=true
                shift
                ;;
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            --quiet|-q)
                QUIET=true
                shift
                ;;
            --non-interactive|-y)
                NON_INTERACTIVE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -*)
                # Unknown option - might be command-specific
                break
                ;;
            *)
                # Not an option - must be command
                break
                ;;
        esac
    done

    # Initialize logging with appropriate level
    log_set_level_from_flags "$VERBOSE" "$QUIET"
    log_init

    # Get command
    local command="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$command" ]]; then
        show_help
        exit 0
    fi

    # Set command context for logging
    log_set_command "$command"

    # Dispatch to command handler
    case "$command" in
        config)
            cmd_config "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        check)
            cmd_check "$@"
            ;;
        watch)
            cmd_watch "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        release)
            cmd_release "$@"
            ;;
        fallback)
            cmd_fallback "$@"
            ;;
        quality)
            cmd_quality "$@"
            ;;
        repos)
            cmd_repos "$@"
            ;;
        health)
            cmd_health "$@"
            ;;
        prune)
            cmd_prune "$@"
            ;;
        signing)
            cmd_signing "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        version)
            cmd_version "$@"
            ;;
        help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown command: $command"
            log_info "Run 'dsr --help' for usage"
            exit 4
            ;;
    esac
}

main "$@"
