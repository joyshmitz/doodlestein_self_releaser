#!/usr/bin/env bash
# dsr - Doodlestein Self-Releaser
#
# Fallback release infrastructure for when GitHub Actions is throttled.
#
# Usage:
#   dsr <command> [options]
#
# Commands:
#   check     Detect throttled GitHub Actions runs
#   watch     Continuous monitoring daemon
#   build     Build artifacts locally
#   release   Upload artifacts to GitHub
#   fallback  Full pipeline: check -> build -> release
#   repos     Manage repository registry
#   health    Check health of build hosts
#   prune     Clean up old artifacts and cache
#   config    View/modify configuration
#   doctor    System diagnostics
#   signing   Manage minisign keys and signing
#
# Global Options:
#   --json, -j          Machine-readable JSON output
#   --non-interactive   Disable prompts (CI mode)
#   --dry-run, -n       Show planned actions without executing
#   --verbose, -v       Enable verbose logging
#   --quiet, -q         Suppress non-error output
#   --help, -h          Show help
#   --version           Show version

set -uo pipefail

# Version
DSR_VERSION="0.1.0"

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source guardrails first for Bash version check
source "$SCRIPT_DIR/src/guardrails.sh"

# Enforce Bash 4.0+ requirement
require_bash_4 || exit $?

# Source modules (logging first, others may depend on it)
source "$SCRIPT_DIR/src/logging.sh"
source "$SCRIPT_DIR/src/config.sh"
source "$SCRIPT_DIR/src/secrets.sh"
source "$SCRIPT_DIR/src/notify.sh"
source "$SCRIPT_DIR/src/signing.sh"
source "$SCRIPT_DIR/src/github.sh"
source "$SCRIPT_DIR/src/host_health.sh"
source "$SCRIPT_DIR/src/host_selector.sh"
source "$SCRIPT_DIR/src/quality_gates.sh"
source "$SCRIPT_DIR/src/build_state.sh"
source "$SCRIPT_DIR/src/git_ops.sh"
source "$SCRIPT_DIR/src/version.sh"
source "$SCRIPT_DIR/src/act_runner.sh"
source "$SCRIPT_DIR/src/release_formulas.sh"
source "$SCRIPT_DIR/src/canary.sh"
source "$SCRIPT_DIR/src/upgrade_verify.sh"
source "$SCRIPT_DIR/src/sbom.sh"
source "$SCRIPT_DIR/src/slsa.sh"
source "$SCRIPT_DIR/src/docker.sh"

# Global flags
JSON_MODE=false
# shellcheck disable=SC2034  # Reserved for future use
DRY_RUN=false
VERBOSE=false
QUIET=false
# shellcheck disable=SC2034  # Reserved for future use
NON_INTERACTIVE=false

# Note: Colors and log functions are now provided by src/logging.sh
# The logging module provides: log_error, log_warn, log_info, log_debug, log_ok, log_timed

# Show help
show_help() {
    cat << 'EOF'
dsr - Doodlestein Self-Releaser

Fallback release infrastructure for when GitHub Actions is throttled.

USAGE:
    dsr <command> [options]

COMMANDS:
    check       Detect throttled GitHub Actions runs
    watch       Continuous monitoring daemon
    build       Build artifacts locally
    release     Upload artifacts to GitHub
    fallback    Full pipeline: check -> build -> release
    quality     Run pre-release quality checks
    repos       Manage repository registry
    health      Check health of build hosts
    prune       Clean up old artifacts and cache
    config      View/modify configuration
    doctor      System diagnostics
    signing     Manage minisign keys and signing
    status      System and last run summary
    version     Detect and tag versions from version files
    canary      Test installers in Docker containers
    sbom        Generate Software Bill of Materials
    slsa        Generate SLSA provenance attestation
    docker      Build multi-arch Docker images
    verify      Verification commands (upgrade checks)

GLOBAL OPTIONS:
    -j, --json          Machine-readable JSON output
    -y, --non-interactive   Disable prompts (CI mode)
    -n, --dry-run       Show planned actions without executing
    -v, --verbose       Enable verbose logging
    -q, --quiet         Suppress non-error output
    -h, --help          Show this help
        --version       Show version

EXAMPLES:
    dsr config init              Initialize configuration
    dsr config show              Show current configuration
    dsr check --repos ntm,bv     Check if repos are throttled
    dsr build --repo ntm         Build ntm locally
    dsr doctor                   Check system dependencies

For more information, see docs/CLI_CONTRACT.md
EOF
}

# Show version
show_version() {
    if $JSON_MODE; then
        echo "{\"tool\": \"dsr\", \"version\": \"$DSR_VERSION\"}"
    else
        echo "dsr version $DSR_VERSION"
    fi
}

# JSON envelope helper
# Usage: json_envelope <command> <status> <exit_code> [details_json]
json_envelope() {
    local cmd="$1"
    local vstatus="$2"  # renamed to avoid potential conflict
    local exit_code="$3"
    local details="${4:-"{}"}"
    local run_id
    run_id=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "unknown")
    local started_at
    started_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat << EOF
{
  "command": "$cmd",
  "status": "$vstatus",
  "exit_code": $exit_code,
  "run_id": "$run_id",
  "started_at": "$started_at",
  "duration_ms": 0,
  "tool": "dsr",
  "version": "$DSR_VERSION",
  "details": $details
}
EOF
}

# ============================================================================
# CONFIG SUBCOMMAND
# ============================================================================

cmd_config() {
    local subcmd="${1:-show}"
    shift 2>/dev/null || true

    case "$subcmd" in
        init)
            cmd_config_init "$@"
            ;;
        show)
            cmd_config_show "$@"
            ;;
        get)
            cmd_config_get "$@"
            ;;
        set)
            cmd_config_set "$@"
            ;;
        validate)
            cmd_config_validate "$@"
            ;;
        edit)
            cmd_config_edit "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr config - View and modify configuration

USAGE:
    dsr config <subcommand> [options]

SUBCOMMANDS:
    init        Initialize configuration directories and files
    show        Show current configuration
    get <key>   Get a specific config value
    set <k>=<v> Set a config value
    validate    Validate configuration files
    edit        Open config in $EDITOR

OPTIONS:
    --json      Output in JSON format
    --force     Overwrite existing files (init only)

EXAMPLES:
    dsr config init              Create default config files
    dsr config show              Show all configuration
    dsr config get threshold_seconds
    dsr config set log_level=debug
    dsr config validate
EOF
            ;;
        *)
            log_error "Unknown config subcommand: $subcmd"
            log_info "Run 'dsr config --help' for usage"
            return 4
            ;;
    esac
}

cmd_config_init() {
    local force=false
    [[ "${1:-}" == "--force" ]] && force=true

    if $JSON_MODE; then
        local status
        if $force; then
            config_init --force >/dev/null 2>&1
            status=$?
        else
            config_init >/dev/null 2>&1
            status=$?
        fi
        if [[ $status -eq 0 ]]; then
            json_envelope "config init" "success" 0 "{\"config_dir\": \"$DSR_CONFIG_DIR\", \"initialized\": true}"
        else
            json_envelope "config init" "error" $status "{\"error\": \"initialization failed\"}"
        fi
        return $status
    else
        if $force; then
            config_init --force
        else
            config_init
        fi
    fi
}

cmd_config_show() {
    if $JSON_MODE; then
        config_show --json
    else
        config_show "$@"
    fi
}

cmd_config_get() {
    local key="${1:-}"
    if [[ -z "$key" ]]; then
        log_error "Usage: dsr config get <key>"
        return 4
    fi

    config_load
    local value
    value=$(config_get "$key" "")

    if [[ -z "$value" ]]; then
        log_error "Key not found: $key"
        return 4
    fi

    if $JSON_MODE; then
        echo "{\"key\": \"$key\", \"value\": \"$value\"}"
    else
        echo "$value"
    fi
}

cmd_config_set() {
    local input="${1:-}"
    if [[ -z "$input" || ! "$input" =~ = ]]; then
        log_error "Usage: dsr config set KEY=VALUE"
        return 4
    fi

    local key="${input%%=*}"
    local value="${input#*=}"

    config_load
    config_set "$key" "$value" --persist

    if $JSON_MODE; then
        echo "{\"key\": \"$key\", \"value\": \"$value\", \"persisted\": true}"
    fi
}

cmd_config_validate() {
    if $JSON_MODE; then
        config_load
        if config_validate 2>/dev/null; then
            json_envelope "config validate" "success" 0 "{\"valid\": true}"
        else
            json_envelope "config validate" "error" 4 "{\"valid\": false}"
            return 4
        fi
    else
        config_load
        config_validate
    fi
}

cmd_config_edit() {
    local editor="${EDITOR:-vi}"
    if [[ ! -f "$DSR_CONFIG_FILE" ]]; then
        log_error "Config file not found. Run: dsr config init"
        return 4
    fi
    exec "$editor" "$DSR_CONFIG_FILE"
}

# ============================================================================
# DOCTOR SUBCOMMAND
# ============================================================================

cmd_doctor() {
    local quick_mode=false
    local fix_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quick|-q)
                quick_mode=true
                shift
                ;;
            --fix|-f)
                fix_mode=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr doctor - System diagnostics

USAGE:
    dsr doctor [options]

OPTIONS:
    --quick, -q     Quick check (core deps + auth only)
    --fix, -f       Suggest fixes for issues found
    --json          JSON output (global flag)

CHECKS:
    Core (always run):
      - git, gh (auth status), jq, curl

    Build tools:
      - docker, act, ssh to build hosts

    Signing tools (if enabled):
      - minisign, syft

    Network:
      - api.github.com, github.com connectivity

    Config:
      - Configuration file validation

EXIT CODES:
    0  - All checks passed (or only warnings)
    3  - Critical errors found (missing core deps)

EXAMPLES:
    dsr doctor              Full diagnostics
    dsr doctor --quick      Core deps only
    dsr doctor --fix        Show remediation steps
    dsr doctor --json       Machine-readable output
EOF
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    log_info "Running system diagnostics..."
    $quick_mode && log_info "(quick mode - core checks only)"
    echo ""

    local errors=0
    local warnings=0
    local checks=()
    local fixes=()

    # Helper to escape JSON strings
    _json_escape() {
        printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\n/\\n/g'
    }

    # Helper to add a check result
    _add_check() {
        local name="$1"
        local status="$2"
        local details="$3"
        checks+=("{\"name\": \"$name\", \"status\": \"$status\"$details}")
    }

    # ========== CORE DEPENDENCIES ==========
    log_info "Core dependencies:"

    # Check git
    if command -v git &>/dev/null; then
        local git_ver
        git_ver=$(git --version | cut -d' ' -f3)
        _add_check "git" "ok" ", \"version\": \"$(_json_escape "$git_ver")\""
        log_ok "  git: $git_ver"
    else
        _add_check "git" "error" ", \"message\": \"not found\""
        log_error "  git: not found"
        fixes+=("Install git: apt install git OR brew install git")
        ((errors++))
    fi

    # Check gh
    if command -v gh &>/dev/null; then
        local gh_ver
        gh_ver=$(gh --version 2>/dev/null | head -1 | awk '{print $3}')
        if gh auth status &>/dev/null 2>&1; then
            local gh_user
            gh_user=$(gh api user --jq '.login' 2>/dev/null || echo "unknown")
            _add_check "gh" "ok" ", \"version\": \"$gh_ver\", \"authenticated\": true, \"user\": \"$gh_user\""
            log_ok "  gh: $gh_ver (authenticated as $gh_user)"
        else
            _add_check "gh" "error" ", \"version\": \"$gh_ver\", \"authenticated\": false"
            log_error "  gh: not authenticated"
            fixes+=("Authenticate GitHub CLI: gh auth login")
            ((errors++))
        fi
    else
        _add_check "gh" "error" ", \"message\": \"not found\""
        log_error "  gh: not found"
        fixes+=("Install GitHub CLI: brew install gh OR apt install gh")
        ((errors++))
    fi

    # Check jq
    if command -v jq &>/dev/null; then
        local jq_ver
        jq_ver=$(jq --version 2>/dev/null | sed 's/jq-//')
        _add_check "jq" "ok" ", \"version\": \"$jq_ver\""
        log_ok "  jq: $jq_ver"
    else
        _add_check "jq" "error" ", \"message\": \"not found\""
        log_error "  jq: not found"
        fixes+=("Install jq: brew install jq OR apt install jq")
        ((errors++))
    fi

    # Check curl
    if command -v curl &>/dev/null; then
        local curl_ver
        curl_ver=$(curl --version 2>/dev/null | head -1 | awk '{print $2}')
        _add_check "curl" "ok" ", \"version\": \"$curl_ver\""
        log_ok "  curl: $curl_ver"
    else
        _add_check "curl" "error" ", \"message\": \"not found\""
        log_error "  curl: not found"
        fixes+=("Install curl: apt install curl")
        ((errors++))
    fi

    # Check yq (needed for config operations)
    if command -v yq &>/dev/null; then
        local yq_ver
        yq_ver=$(yq --version 2>/dev/null | awk '{print $NF}')
        _add_check "yq" "ok" ", \"version\": \"$yq_ver\""
        log_ok "  yq: $yq_ver"
    else
        _add_check "yq" "warning" ", \"message\": \"not found\""
        log_warn "  yq: not found (needed for config operations)"
        fixes+=("Install yq: brew install yq OR snap install yq")
        ((warnings++))
    fi

    # Quick mode stops here
    if $quick_mode; then
        echo ""
        _doctor_summary "$errors" "$warnings" "$fix_mode"
        [[ $errors -eq 0 ]] && return 0 || return 3
    fi

    # ========== BUILD TOOLS ==========
    echo ""
    log_info "Build tools:"

    # Check docker
    if command -v docker &>/dev/null; then
        if docker info &>/dev/null 2>&1; then
            local docker_ver
            docker_ver=$(docker --version 2>/dev/null | awk '{print $3}' | tr -d ',')
            _add_check "docker" "ok" ", \"version\": \"$docker_ver\", \"running\": true"
            log_ok "  docker: $docker_ver (running)"
        else
            _add_check "docker" "warning" ", \"running\": false"
            log_warn "  docker: installed but not running"
            fixes+=("Start Docker: systemctl start docker OR open Docker Desktop")
            ((warnings++))
        fi
    else
        _add_check "docker" "warning" ", \"message\": \"not found\""
        log_warn "  docker: not found (needed for act)"
        fixes+=("Install Docker: https://docs.docker.com/get-docker/")
        ((warnings++))
    fi

    # Check act
    if command -v act &>/dev/null; then
        local act_ver
        act_ver=$(act --version 2>/dev/null | head -1)
        _add_check "act" "ok" ", \"version\": \"$(_json_escape "$act_ver")\""
        log_ok "  act: $act_ver"
    else
        _add_check "act" "warning" ", \"message\": \"not found\""
        log_warn "  act: not found (needed for local builds)"
        fixes+=("Install act: brew install act OR https://github.com/nektos/act/releases")
        ((warnings++))
    fi

    # Check SSH
    if command -v ssh &>/dev/null; then
        _add_check "ssh" "ok" ""
        log_ok "  ssh: available"
    else
        _add_check "ssh" "warning" ", \"message\": \"not found\""
        log_warn "  ssh: not found (needed for remote builds)"
        ((warnings++))
    fi

    # ========== SSH TO BUILD HOSTS ==========
    echo ""
    log_info "Build hosts:"

    for host in mmini wlap; do
        if timeout 5 ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" "echo ok" &>/dev/null 2>&1; then
            _add_check "ssh-$host" "ok" ""
            log_ok "  $host: reachable"
        else
            _add_check "ssh-$host" "warning" ", \"message\": \"unreachable\""
            log_warn "  $host: unreachable"
            fixes+=("Check SSH config for $host: ssh $host")
            ((warnings++))
        fi
    done

    # ========== SIGNING TOOLS ==========
    echo ""
    log_info "Signing tools:"

    # Check minisign
    if command -v minisign &>/dev/null; then
        local minisign_ver
        minisign_ver=$(minisign -v 2>&1 | head -1 || echo "unknown")
        _add_check "minisign" "ok" ", \"version\": \"$(_json_escape "$minisign_ver")\""
        log_ok "  minisign: available"

        # Check if key exists
        if [[ -f "${SIGNING_PRIVATE_KEY:-$HOME/.config/dsr/secrets/minisign.key}" ]]; then
            _add_check "minisign-key" "ok" ""
            log_ok "  minisign key: configured"
        else
            _add_check "minisign-key" "warning" ", \"message\": \"not configured\""
            log_warn "  minisign key: not configured"
            fixes+=("Generate signing key: dsr signing init")
            ((warnings++))
        fi
    else
        _add_check "minisign" "warning" ", \"message\": \"not found\""
        log_warn "  minisign: not found (needed for signing)"
        fixes+=("Install minisign: brew install minisign")
        ((warnings++))
    fi

    # Check syft (SBOM generation)
    if command -v syft &>/dev/null; then
        local syft_ver
        syft_ver=$(syft --version 2>/dev/null | head -1 || echo "unknown")
        _add_check "syft" "ok" ", \"version\": \"$(_json_escape "$syft_ver")\""
        log_ok "  syft: $syft_ver"
    else
        _add_check "syft" "warning" ", \"message\": \"not found\""
        log_warn "  syft: not found (needed for SBOM generation)"
        fixes+=("Install syft: brew install syft OR https://github.com/anchore/syft/releases")
        ((warnings++))
    fi

    # ========== NETWORK CONNECTIVITY ==========
    echo ""
    log_info "Network connectivity:"

    # Check api.github.com
    if curl -sf --max-time 5 "https://api.github.com" >/dev/null 2>&1; then
        _add_check "network-api.github.com" "ok" ""
        log_ok "  api.github.com: reachable"
    else
        _add_check "network-api.github.com" "warning" ", \"message\": \"unreachable\""
        log_warn "  api.github.com: unreachable"
        fixes+=("Check network connectivity to GitHub")
        ((warnings++))
    fi

    # Check github.com
    if curl -sf --max-time 5 "https://github.com" >/dev/null 2>&1; then
        _add_check "network-github.com" "ok" ""
        log_ok "  github.com: reachable"
    else
        _add_check "network-github.com" "warning" ", \"message\": \"unreachable\""
        log_warn "  github.com: unreachable"
        ((warnings++))
    fi

    # ========== DISK SPACE ==========
    echo ""
    log_info "Disk space:"

    local disk_avail_kb disk_avail_gb
    disk_avail_kb=$(df -k . 2>/dev/null | tail -1 | awk '{print $4}')
    if [[ -n "$disk_avail_kb" ]]; then
        disk_avail_gb=$((disk_avail_kb / 1024 / 1024))
        if [[ $disk_avail_gb -lt 5 ]]; then
            _add_check "disk-local" "warning" ", \"available_gb\": $disk_avail_gb"
            log_warn "  local: ${disk_avail_gb}GB available (low)"
            fixes+=("Free up disk space (< 5GB available)")
            ((warnings++))
        else
            _add_check "disk-local" "ok" ", \"available_gb\": $disk_avail_gb"
            log_ok "  local: ${disk_avail_gb}GB available"
        fi
    fi

    # ========== CONFIG ==========
    echo ""
    log_info "Configuration:"

    config_load 2>/dev/null || true
    if config_validate &>/dev/null 2>&1; then
        _add_check "config" "ok" ""
        log_ok "  config: valid"
    else
        _add_check "config" "warning" ", \"message\": \"invalid or missing\""
        log_warn "  config: invalid or missing"
        fixes+=("Initialize config: dsr config init")
        ((warnings++))
    fi

    # Summary
    echo ""
    _doctor_summary "$errors" "$warnings" "$fix_mode"
    [[ $errors -eq 0 ]] && return 0 || return 3
}

# Doctor summary helper - called at end to print summary and JSON output
# Uses global arrays: checks[], fixes[]
_doctor_summary() {
    local errors="$1"
    local warnings="$2"
    local fix_mode="$3"

    local exit_code=0
    local overall_status="healthy"

    if [[ $errors -gt 0 ]]; then
        log_error "Found $errors error(s), $warnings warning(s)"
        exit_code=3
        overall_status="unhealthy"
    elif [[ $warnings -gt 0 ]]; then
        log_warn "Found $warnings warning(s)"
        overall_status="degraded"
    else
        log_ok "All checks passed"
    fi

    # Show fixes if requested
    if [[ "$fix_mode" == "true" && ${#fixes[@]} -gt 0 ]]; then
        echo ""
        log_info "Suggested fixes:"
        for fix in "${fixes[@]}"; do
            log_info "  → $fix"
        done
    fi

    if $JSON_MODE; then
        local checks_json details_json
        checks_json=$(printf '%s\n' "${checks[@]}" | jq -sc '.')
        details_json=$(jq -nc \
            --argjson errors "$errors" \
            --argjson warnings "$warnings" \
            --arg overall_status "$overall_status" \
            --argjson checks "$checks_json" \
            '{
                overall_status: $overall_status,
                errors: $errors,
                warnings: $warnings,
                checks: $checks
            }')
        local status_str
        [[ "$errors" -eq 0 ]] && status_str="success" || status_str="error"
        json_envelope "doctor" "$status_str" "$exit_code" "$details_json"
    fi
}

# ============================================================================
# STUB COMMANDS (to be implemented)
# ============================================================================

# ============================================================================
# CHECK SUBCOMMAND
# ============================================================================

cmd_check() {
    local repos=()
    local threshold=600  # 10 minutes in seconds
    local check_all=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repos|-r)
                IFS=',' read -ra repos <<< "$2"
                shift 2
                ;;
            --threshold|-t)
                threshold="$2"
                shift 2
                ;;
            --all|-a)
                check_all=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr check - Detect throttled GitHub Actions runs

USAGE:
    dsr check <repo>
    dsr check --repos repo1,repo2
    dsr check --all

OPTIONS:
    -r, --repos <list>      Comma-separated repos (e.g., ntm,bv)
    -t, --threshold <sec>   Queue time threshold in seconds (default: 600)
    -a, --all               Check all configured repos
    --json                  JSON output (global flag)

EXAMPLES:
    dsr check Dicklesworthstone/ntm
    dsr check --repos ntm,bv --threshold 300
    dsr check --all --json

EXIT CODES:
    0  - No throttling detected
    1  - Throttling detected
    3  - Dependency error (gh not authenticated)
    4  - Invalid arguments
    8  - Network/API error
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr check --help' for usage"
                return 4
                ;;
            *)
                # Positional argument - repo
                repos+=("$1")
                shift
                ;;
        esac
    done

    # Load config for --all option
    if $check_all; then
        config_load 2>/dev/null || true
        # Get repos from config (parse repos.yaml)
        local repos_file="$DSR_CONFIG_DIR/repos.yaml"
        if [[ -f "$repos_file" ]]; then
            while IFS= read -r repo; do
                [[ -n "$repo" ]] && repos+=("$repo")
            done < <(grep -E '^\s+repo:' "$repos_file" 2>/dev/null | sed 's/.*repo:\s*//' | tr -d '"' || true)
        fi
    fi

    # Validate we have repos to check
    if [[ ${#repos[@]} -eq 0 ]]; then
        log_error "No repos specified. Use: dsr check <repo> or --all"
        return 4
    fi

    # Check dependencies
    if ! gh_check 2>/dev/null; then
        if ! gh_check_token 2>/dev/null; then
            if $JSON_MODE; then
                json_envelope "check" "error" 3 '{"error": "GitHub authentication required"}'
            fi
            return 3
        fi
    fi

    # Process each repo
    local any_throttled=false
    local results=()
    local now
    now=$(date +%s)

    for repo in "${repos[@]}"; do
        local result
        result=$(_check_repo "$repo" "$threshold" "$now")
        local status=$?

        if [[ $status -eq 1 ]]; then
            any_throttled=true
        fi

        results+=("$result")

        if ! $JSON_MODE; then
            _check_print_result "$result"
        fi
    done

    # JSON output
    if $JSON_MODE; then
        local results_json
        results_json=$(printf '%s\n' "${results[@]}" | jq -sc '.')
        local summary_status="ok"
        $any_throttled && summary_status="throttled"
        json_envelope "check" "$summary_status" "$($any_throttled && echo 1 || echo 0)" \
            "$(jq -nc --argjson repos "$results_json" --argjson threshold "$threshold" \
                '{threshold_seconds: $threshold, repos: $repos}')"
    fi

    $any_throttled && return 1 || return 0
}

# Check a single repo for throttling
# Returns JSON result, exit code 1 if throttled
_check_repo() {
    local repo="$1"
    local threshold="$2"
    local now="$3"

    # Resolve short repo name to owner/repo
    if [[ ! "$repo" =~ / ]]; then
        # Assume Dicklesworthstone if no owner specified
        repo="Dicklesworthstone/$repo"
    fi

    # Fetch workflow runs
    local runs_json
    runs_json=$(gh_workflow_runs "$repo" --limit 20 2>/dev/null)
    local fetch_status=$?

    if [[ $fetch_status -ne 0 ]] || [[ -z "$runs_json" ]]; then
        echo '{"repo": "'"$repo"'", "status": "error", "error": "failed to fetch runs"}'
        return 8
    fi

    # Extract and analyze runs
    local queued_runs stuck_runs
    queued_runs=$(echo "$runs_json" | jq -c --argjson now "$now" --argjson threshold "$threshold" '
        .workflow_runs // [] |
        map(select(.status == "queued")) |
        map(. as $run |
            ($now - ($run.created_at | fromdateiso8601 // $now)) as $age |
            select($age > $threshold) |
            {
                id: .id,
                status: .status,
                created_at: .created_at,
                workflow_id: .workflow_id,
                workflow_name: .name,
                event: .event,
                html_url: .html_url,
                age_seconds: $age
            }
        )' 2>/dev/null || echo '[]')

    stuck_runs=$(echo "$runs_json" | jq -c --argjson now "$now" --argjson threshold "$threshold" '
        .workflow_runs // [] |
        map(select(.status == "in_progress")) |
        map(. as $run |
            ($run.run_started_at // $run.created_at) as $start_time |
            ($now - ($start_time | fromdateiso8601 // $now)) as $age |
            select($age > $threshold) |
            {
                id: .id,
                status: .status,
                created_at: .created_at,
                run_started_at: .run_started_at,
                workflow_id: .workflow_id,
                workflow_name: .name,
                event: .event,
                html_url: .html_url,
                age_seconds: $age
            }
        )' 2>/dev/null || echo '[]')

    # Count issues
    local queued_count stuck_count
    queued_count=$(echo "$queued_runs" | jq 'length')
    stuck_count=$(echo "$stuck_runs" | jq 'length')

    # Determine oldest queued time
    local oldest_queued_sec=0
    if [[ "$queued_count" -gt 0 ]]; then
        oldest_queued_sec=$(echo "$queued_runs" | jq '[.[].age_seconds] | max // 0')
    fi

    # Build result
    local status="ok"
    if [[ "$queued_count" -gt 0 ]] || [[ "$stuck_count" -gt 0 ]]; then
        status="throttled"
    fi

    jq -nc \
        --arg repo "$repo" \
        --arg status "$status" \
        --argjson threshold "$threshold" \
        --argjson queued_count "$queued_count" \
        --argjson stuck_count "$stuck_count" \
        --argjson oldest_queued_sec "$oldest_queued_sec" \
        --argjson queued_runs "$queued_runs" \
        --argjson stuck_runs "$stuck_runs" \
        '{
            repo: $repo,
            status: $status,
            threshold_seconds: $threshold,
            queued_count: $queued_count,
            stuck_in_progress_count: $stuck_count,
            oldest_queued_seconds: $oldest_queued_sec,
            oldest_queued_minutes: (($oldest_queued_sec / 60) | floor),
            queued_runs: $queued_runs,
            stuck_runs: $stuck_runs
        }'

    [[ "$status" == "throttled" ]] && return 1 || return 0
}

# Print human-readable check result
_check_print_result() {
    local result="$1"

    local repo status queued stuck oldest_min
    repo=$(echo "$result" | jq -r '.repo')
    status=$(echo "$result" | jq -r '.status')
    queued=$(echo "$result" | jq -r '.queued_count')
    stuck=$(echo "$result" | jq -r '.stuck_in_progress_count')
    oldest_min=$(echo "$result" | jq -r '.oldest_queued_minutes')

    if [[ "$status" == "error" ]]; then
        log_error "$repo: $(echo "$result" | jq -r '.error // "unknown error"')"
    elif [[ "$status" == "throttled" ]]; then
        log_warn "$repo: THROTTLED"
        [[ "$queued" -gt 0 ]] && log_warn "  - $queued runs queued (oldest: ${oldest_min}m)"
        [[ "$stuck" -gt 0 ]] && log_warn "  - $stuck runs stuck in_progress"

        # Show URLs for queued runs
        echo "$result" | jq -r '.queued_runs[:3][] | "    → \(.html_url)"' 2>/dev/null | while read -r url; do
            log_info "$url"
        done
    else
        log_ok "$repo: OK (no throttling detected)"
    fi
}

# ============================================================================
# WATCH SUBCOMMAND - Continuous Monitoring Daemon
# ============================================================================

# State file paths
_WATCH_STATE_DIR="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
_WATCH_TRIGGERED_FILE="$_WATCH_STATE_DIR/triggered.json"
_WATCH_LOCK_FILE="$_WATCH_STATE_DIR/watch.lock"

# Default settings
_WATCH_DEFAULT_INTERVAL=300  # 5 minutes
_WATCH_JITTER_PERCENT=20     # ±20% jitter
_WATCH_DEBOUNCE_WINDOW=180   # 3 minutes
_WATCH_BACKOFF_INITIAL=60    # 1 minute initial backoff
_WATCH_BACKOFF_MAX=3600      # 1 hour max backoff

# Internal state
_WATCH_RUNNING=false
_WATCH_CURRENT_BACKOFF=0

# Watch signal handlers
_watch_cleanup() {
    log_info "Shutting down watcher..."
    _watch_release_lock
    _WATCH_RUNNING=false
}

# Acquire lock to prevent multiple watcher instances
_watch_acquire_lock() {
    mkdir -p "$_WATCH_STATE_DIR"

    # Check for existing lock
    if [[ -f "$_WATCH_LOCK_FILE" ]]; then
        local lock_pid
        lock_pid=$(cat "$_WATCH_LOCK_FILE" 2>/dev/null)

        # Check if process is still running
        if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
            log_error "Another watcher is running (PID $lock_pid)"
            return 2
        fi

        # Stale lock - remove it
        log_warn "Removing stale lock file"
        rm -f "$_WATCH_LOCK_FILE"
    fi

    # Create lock
    echo "$$" > "$_WATCH_LOCK_FILE"
    return 0
}

_watch_release_lock() {
    rm -f "$_WATCH_LOCK_FILE" 2>/dev/null
}

# Load triggered runs state
_watch_load_triggered() {
    if [[ -f "$_WATCH_TRIGGERED_FILE" ]]; then
        cat "$_WATCH_TRIGGERED_FILE"
    else
        echo '{"runs": {}, "last_check": null}'
    fi
}

# Save triggered runs state
_watch_save_triggered() {
    local state="$1"
    echo "$state" > "$_WATCH_TRIGGERED_FILE"
}

# Check if a run was already triggered
_watch_is_triggered() {
    local run_id="$1"
    local state
    state=$(_watch_load_triggered)

    echo "$state" | jq -e --arg id "$run_id" '.runs[$id] != null' &>/dev/null
}

# Mark a run as triggered
_watch_mark_triggered() {
    local run_id="$1"
    local state now
    state=$(_watch_load_triggered)
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    state=$(echo "$state" | jq --arg id "$run_id" --arg ts "$now" \
        '.runs[$id] = $ts | .last_check = $ts')

    _watch_save_triggered "$state"
}

# Clean old triggered entries (older than 24 hours)
_watch_cleanup_triggered() {
    local state cutoff
    state=$(_watch_load_triggered)
    cutoff=$(date -u -d "-24 hours" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || \
             date -u -v-24H +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "")

    if [[ -n "$cutoff" ]]; then
        state=$(echo "$state" | jq --arg cutoff "$cutoff" \
            '.runs |= with_entries(select(.value >= $cutoff))')
        _watch_save_triggered "$state"
    fi
}

# Calculate jittered sleep interval
_watch_jittered_sleep() {
    local base_interval="$1"
    local jitter_range=$((base_interval * _WATCH_JITTER_PERCENT / 100))
    local jitter=$((RANDOM % (jitter_range * 2 + 1) - jitter_range))
    local sleep_time=$((base_interval + jitter))

    [[ $sleep_time -lt 10 ]] && sleep_time=10
    echo "$sleep_time"
}

# Main watch loop iteration
_watch_iteration() {
    local dry_run="$1"
    local triggered_count=0

    log_info "Running throttle check..."

    # Run dsr check
    local check_output check_exit
    if check_output=$("$0" --json check --all 2>/dev/null); then
        check_exit=0
        _WATCH_CURRENT_BACKOFF=0  # Reset backoff on success
    else
        check_exit=$?

        # Network error - apply backoff
        if [[ $check_exit -eq 8 ]]; then
            if [[ $_WATCH_CURRENT_BACKOFF -eq 0 ]]; then
                _WATCH_CURRENT_BACKOFF=$_WATCH_BACKOFF_INITIAL
            else
                _WATCH_CURRENT_BACKOFF=$((_WATCH_CURRENT_BACKOFF * 2))
                [[ $_WATCH_CURRENT_BACKOFF -gt $_WATCH_BACKOFF_MAX ]] && \
                    _WATCH_CURRENT_BACKOFF=$_WATCH_BACKOFF_MAX
            fi
            log_warn "API error, backing off for ${_WATCH_CURRENT_BACKOFF}s"
            return 1
        fi
    fi

    # Parse check results
    local throttled_runs
    throttled_runs=$(echo "$check_output" | jq -r \
        '.details.repos[]?.throttled_runs[]? | "\(.id)|\(.repo)"' 2>/dev/null)

    if [[ -z "$throttled_runs" ]]; then
        log_ok "No throttled runs detected"
        return 0
    fi

    # Process each throttled run
    while IFS='|' read -r run_id repo; do
        [[ -z "$run_id" ]] && continue

        # Check if already triggered
        if _watch_is_triggered "$run_id"; then
            log_debug "Run $run_id already triggered, skipping"
            continue
        fi

        log_warn "Throttled run detected: $run_id ($repo)"
        if [[ "${DSR_NOTIFY_ENABLED:-false}" == "true" ]]; then
            notify_event "watch.throttled" "warn" \
                "Throttle detected" \
                "Repo $repo run $run_id exceeded threshold" \
                "$run_id" || true
        fi

        if $dry_run; then
            log_info "[DRY RUN] Would trigger fallback for $repo (run $run_id)"
        else
            log_info "Triggering fallback for $repo..."

            # Mark as triggered before attempting (to prevent repeated attempts on failure)
            _watch_mark_triggered "$run_id"

            # TODO: Actually trigger fallback when build/release commands are implemented
            # For now, just log that we would trigger it
            log_info "Fallback queued for $repo (run $run_id)"
            # ./dsr fallback --repo "$repo" &
            if [[ "${DSR_NOTIFY_ENABLED:-false}" == "true" ]]; then
                notify_event "watch.fallback_queued" "info" \
                    "Fallback queued" \
                    "Repo $repo run $run_id queued for fallback" \
                    "$run_id" || true
            fi
        fi

        ((triggered_count++))
    done <<< "$throttled_runs"

    if [[ $triggered_count -gt 0 ]]; then
        log_info "Triggered $triggered_count fallback(s)"
    fi

    return 0
}

cmd_watch() {
    local interval=$_WATCH_DEFAULT_INTERVAL
    local daemon_mode=false
    local dry_run=false
    local once_mode=false
    local notify_methods="none"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --interval|-i)
                interval="$2"
                shift 2
                ;;
            --notify)
                notify_methods="$2"
                shift 2
                ;;
            --notify=*)
                notify_methods="${1#*=}"
                shift
                ;;
            --daemon|-d)
                daemon_mode=true
                shift
                ;;
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            --once|-1)
                once_mode=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr watch - Continuous monitoring daemon

USAGE:
    dsr watch [options]

OPTIONS:
    --interval, -i <sec>   Poll interval in seconds (default: 300)
    --daemon, -d           Run in background (daemon mode)
    --dry-run, -n          Check but don't trigger fallbacks
    --once, -1             Single check and exit
    --notify <method>      Notification: slack|discord|desktop|terminal|none
    --json                 JSON output (global flag)

BEHAVIOR:
    - Polls all configured repos for throttled GH Actions runs
    - Triggers fallback builds once per detected throttle
    - Deduplicates by run ID (won't re-trigger same run)
    - Uses jittered intervals to avoid thundering herd
    - Exponential backoff on API errors (up to 1 hour)
    - Stores state in ~/.local/state/dsr/triggered.json

STATE FILES:
    ~/.local/state/dsr/triggered.json  - Triggered run history
    ~/.local/state/dsr/watch.lock      - Lock file (single instance)

EXAMPLES:
    dsr watch                  Start watching (foreground)
    dsr watch --once           Single check and exit
    dsr watch --dry-run        Check without triggering
    dsr watch --interval 60    Poll every minute
    dsr watch --daemon &       Run in background

EXIT CODES:
    0  - Success (or clean shutdown)
    2  - Another watcher is already running
    3  - Dependency error (run dsr doctor)
    5  - Interrupted (SIGTERM/SIGINT)
EOF
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    # Validate interval
    if ! [[ "$interval" =~ ^[0-9]+$ ]] || [[ "$interval" -lt 10 ]]; then
        log_error "Invalid interval: $interval (must be >= 10 seconds)"
        return 4
    fi

    # Configure notifications for watch loop
    if [[ "$notify_methods" != "none" ]]; then
        # shellcheck disable=SC2034  # Used by notify.sh
        DSR_NOTIFY_METHODS="$notify_methods"
        DSR_NOTIFY_ENABLED=true
        notify_init >/dev/null 2>&1 || true
        log_info "Notifications enabled: $notify_methods"
    else
        DSR_NOTIFY_ENABLED=false
    fi

    # Run preflight check
    log_info "Running preflight check..."
    if ! ./dsr doctor --quick &>/dev/null; then
        log_error "Preflight check failed. Run 'dsr doctor' for details."
        return 3
    fi
    log_ok "Preflight check passed"

    # Single check mode
    if $once_mode; then
        log_info "Running single check..."
        _watch_iteration "$dry_run"
        local result=$?

        if $JSON_MODE; then
            local state
            state=$(_watch_load_triggered)
            json_envelope "watch" "success" "$result" "$(jq -nc \
                --arg mode "once" \
                --argjson state "$state" \
                '{mode: $mode, triggered_state: $state}')"
        fi

        return $result
    fi

    # Acquire lock for continuous mode
    if ! _watch_acquire_lock; then
        return 2
    fi

    # Set up signal handlers
    trap _watch_cleanup SIGTERM SIGINT

    # Daemon mode
    if $daemon_mode; then
        log_info "Starting daemon mode (interval: ${interval}s)..."
        # For true daemon mode, the process should be backgrounded by the caller
        # We just continue running in foreground but signal that we're ready
    else
        log_info "Starting watch mode (interval: ${interval}s, Ctrl+C to stop)..."
    fi

    $dry_run && log_info "(dry-run mode - no fallbacks will be triggered)"

    # Clean old triggered entries on startup
    _watch_cleanup_triggered

    _WATCH_RUNNING=true
    local iteration=0

    while $_WATCH_RUNNING; do
        ((iteration++))
        log_info "--- Iteration $iteration ---"

        # Run check
        if ! _watch_iteration "$dry_run"; then
            # Backoff on error
            if [[ $_WATCH_CURRENT_BACKOFF -gt 0 ]]; then
                log_info "Sleeping ${_WATCH_CURRENT_BACKOFF}s (backoff)..."
                sleep "$_WATCH_CURRENT_BACKOFF" || break
                continue
            fi
        fi

        # Calculate jittered sleep
        local sleep_time
        sleep_time=$(_watch_jittered_sleep "$interval")
        log_info "Next check in ${sleep_time}s..."

        # Sleep (interruptible)
        sleep "$sleep_time" || break
    done

    # Cleanup
    _watch_release_lock
    log_info "Watcher stopped"

    if $JSON_MODE; then
        local state
        state=$(_watch_load_triggered)
        json_envelope "watch" "success" 0 "$(jq -nc \
            --argjson iterations "$iteration" \
            --argjson state "$state" \
            '{mode: "continuous", iterations: $iterations, triggered_state: $state}')"
    fi

    return 0
}

cmd_build() {
    local tool_name=""
    local targets=()
    local version=""
    local output_dir=""
    # shellcheck disable=SC2034  # parallel reserved for future parallel build support
    local parallel=false
    # shellcheck disable=SC2034  # resume reserved for future resume support
    local resume=false
    local allow_dirty=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tool|-t)
                tool_name="$2"
                shift 2
                ;;
            --target)
                targets+=("$2")
                shift 2
                ;;
            --targets)
                # Allow comma-separated list
                IFS=',' read -ra targets <<< "$2"
                shift 2
                ;;
            --version|-V)
                version="$2"
                shift 2
                ;;
            --output-dir|-o)
                output_dir="$2"
                shift 2
                ;;
            --parallel|-p)
                # shellcheck disable=SC2034
                parallel=true
                shift
                ;;
            --resume|-r)
                # shellcheck disable=SC2034
                resume=true
                log_warn "--resume is not yet implemented; proceeding with fresh build"
                shift
                ;;
            --allow-dirty)
                allow_dirty=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr build - Build artifacts locally

USAGE:
    dsr build <tool> [options]
    dsr build --tool <name> [options]

OPTIONS:
    -t, --tool <name>      Tool to build (required, or as first positional arg)
    --target <target>      Specific target (e.g., linux/amd64); can repeat
    --targets <list>       Comma-separated target list
    -V, --version <ver>    Version to build (default: detect from version files)
    -o, --output-dir <dir> Output directory for artifacts
    -p, --parallel         Build targets in parallel
    -r, --resume           Resume interrupted build
    --allow-dirty          Allow building with uncommitted changes

DESCRIPTION:
    Builds a tool for all configured targets using act (Linux) and
    SSH to remote hosts (macOS/Windows).

TARGETS:
    Configured per tool in ~/.config/dsr/repos.d/<tool>.yaml
    Common targets: linux/amd64, linux/arm64, darwin/arm64, windows/amd64

EXAMPLES:
    dsr build ntm                           Build ntm for all targets
    dsr build ntm --target linux/amd64      Build only for Linux x64
    dsr build ntm --version 1.2.3           Build specific version
    dsr build ntm --parallel                Build all targets in parallel
    dsr build --tool bv --resume            Resume interrupted bv build

EXIT CODES:
    0  - All builds succeeded
    1  - Some builds failed
    2  - Build already in progress (lock held)
    4  - Invalid arguments or missing config
    6  - Build failed
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr build --help' for usage"
                return 4
                ;;
            *)
                # First positional arg is tool name
                if [[ -z "$tool_name" ]]; then
                    tool_name="$1"
                else
                    # Additional positional args might be targets
                    targets+=("$1")
                fi
                shift
                ;;
        esac
    done

    # Validate tool name
    if [[ -z "$tool_name" ]]; then
        log_error "Tool name required"
        log_info "Run 'dsr build --help' for usage"
        return 4
    fi

    # Set output directory default
    local state_dir="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
    [[ -z "$output_dir" ]] && output_dir="$state_dir/artifacts"
    mkdir -p "$output_dir"

    # Check if act is available
    if ! act_check; then
        log_error "act not available - cannot build"
        return 3
    fi

    # Load tool config
    if ! act_load_repo_config "$tool_name"; then
        log_error "Tool '$tool_name' not found in repos.d"
        log_info "Available tools: $(act_list_tools 2>/dev/null | tr '\n' ' ')"
        return 4
    fi

    # Get local path
    local local_path
    local_path=$(act_get_local_path "$tool_name")
    if [[ -z "$local_path" || ! -d "$local_path" ]]; then
        log_error "Local path not found for $tool_name: $local_path"
        return 4
    fi

    # Check for dirty working tree
    if ! $allow_dirty; then
        if git_ops_is_dirty "$local_path"; then
            log_error "Working tree has uncommitted changes in $local_path"
            log_info "Commit changes or use --allow-dirty to override"
            return 1
        fi
    fi

    # Detect version if not specified
    if [[ -z "$version" ]]; then
        log_info "Detecting version from version files..."
        if version=$(version_detect "$local_path" 2>/dev/null); then
            log_info "Detected version: $version"
        else
            log_error "Cannot detect version. Specify with --version"
            return 4
        fi
    fi

    # Normalize version (ensure it has 'v' prefix for tag)
    local tag
    tag=$(git_ops_version_to_tag "$version")

    # Check if tag exists
    if ! git_ops_tag_exists "$local_path" "$tag"; then
        log_warn "Tag $tag does not exist in $local_path"
        log_info "Creating tag with: dsr version tag $tool_name"
        # For now, proceed anyway - the version might be in version files but not tagged
    fi

    log_info "Building $tool_name $version"
    log_set_tool "$tool_name"

    # Get targets from args or config
    local target_list
    if [[ ${#targets[@]} -gt 0 ]]; then
        target_list="${targets[*]}"
    else
        target_list=$(act_get_targets "$tool_name")
    fi

    if [[ -z "$target_list" ]]; then
        log_error "No targets configured for $tool_name"
        return 4
    fi

    log_info "Targets: $target_list"

    # Record start time
    local start_time
    start_time=$(date +%s)

    # Run orchestrated build
    local full_output
    # shellcheck disable=SC2086
    full_output=$(act_orchestrate_build "$tool_name" "$version" $target_list 2>&1)

    # Extract JSON from mixed output (orchestrator logs + JSON at end)
    # The JSON starts with a standalone { line and ends with standalone }
    local result
    result=$(echo "$full_output" | awk '
        /^{$/ { json = ""; capturing = 1 }
        capturing { json = json $0 "\n" }
        /^}$/ && capturing { capturing = 0 }
        END { printf "%s", json }
    ')

    # Parse result
    local end_time duration
    end_time=$(date +%s)
    duration=$((end_time - start_time))

    # Extract summary from JSON result
    local total success failed
    total=$(echo "$result" | jq -r '.summary.total // 0' 2>/dev/null || echo 0)
    success=$(echo "$result" | jq -r '.summary.success // 0' 2>/dev/null || echo 0)
    failed=$(echo "$result" | jq -r '.summary.failed // 0' 2>/dev/null || echo 0)

    # Default values if parsing failed
    [[ -z "$total" || "$total" == "null" ]] && total=0
    [[ -z "$success" || "$success" == "null" ]] && success=0
    [[ -z "$failed" || "$failed" == "null" ]] && failed=0

    # Generate manifest
    local manifest_file="$output_dir/${tool_name}-${version}-manifest.json"
    if [[ $success -gt 0 ]]; then
        # Generate manifest from orchestration result JSON
        act_generate_manifest "$result" "$manifest_file" 2>/dev/null || true
    fi

    # Output
    if $JSON_MODE; then
        local build_details
        build_details=$(cat << EOF
{
  "tool": "$tool_name",
  "version": "$version",
  "targets": $(echo "$target_list" | tr ' ' '\n' | jq -R . | jq -s .),
  "total": $total,
  "success": $success,
  "failed": $failed,
  "duration_seconds": $duration,
  "output_dir": "$output_dir",
  "manifest": "$manifest_file"
}
EOF
)
        if [[ $failed -eq 0 && $success -gt 0 ]]; then
            json_envelope "build" "success" 0 "$build_details"
        elif [[ $success -gt 0 ]]; then
            json_envelope "build" "partial" 1 "$build_details"
        else
            json_envelope "build" "failed" 6 "$build_details"
        fi
    else
        echo ""
        log_info "=== Build Summary ==="
        log_info "Tool:     $tool_name"
        log_info "Version:  $version"
        log_info "Duration: ${duration}s"
        echo ""
        log_info "Results:"
        log_info "  Total:    $total"
        if [[ $success -gt 0 ]]; then
            log_ok "  Success:  $success"
        else
            log_info "  Success:  $success"
        fi
        if [[ $failed -gt 0 ]]; then
            log_error "  Failed:   $failed"
        else
            log_info "  Failed:   $failed"
        fi
        echo ""
        if [[ -f "$manifest_file" ]]; then
            log_ok "Manifest: $manifest_file"
        fi
        log_info "Artifacts: $output_dir"
    fi

    # Return appropriate exit code
    if [[ $failed -eq 0 && $success -gt 0 ]]; then
        return 0
    elif [[ $success -gt 0 ]]; then
        return 1  # Partial success
    else
        return 6  # All failed
    fi
}

# Quality gates command - run pre-release checks
cmd_quality() {
    local tool_name=""
    local dry_run=false
    local skip_checks=false
    local work_dir=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tool|-t)
                tool_name="$2"
                shift 2
                ;;
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            --skip-checks)
                skip_checks=true
                shift
                ;;
            --work-dir|-w)
                work_dir="$2"
                shift 2
                ;;
            --help|-h)
                cat << 'EOF'
dsr quality - Run pre-release quality checks

USAGE:
    dsr quality --tool <name> [options]

OPTIONS:
    -t, --tool <name>    Tool to check (required)
    -n, --dry-run        Show checks without running them
    --skip-checks        Skip all checks (for testing)
    -w, --work-dir       Directory to run checks in

DESCRIPTION:
    Runs quality gate checks configured in repos.yaml for the specified tool.
    Checks are commands like 'cargo test', 'go vet', etc.

CONFIGURATION:
    Configure checks in ~/.config/dsr/repos.yaml:

    tools:
      ntm:
        checks:
          - "cargo clippy --all-targets -- -D warnings"
          - "cargo test"
          - "cargo fmt --check"

EXAMPLES:
    dsr quality --tool ntm             Run checks for ntm
    dsr quality --tool ntm --dry-run   Show what would run
    dsr quality --tool bv -w /path/to/bv

EXIT CODES:
    0  - All checks passed
    1  - One or more checks failed
    4  - Invalid arguments
EOF
                return 0
                ;;
            *)
                if [[ -z "$tool_name" ]]; then
                    tool_name="$1"
                else
                    log_error "Unknown argument: $1"
                    return 4
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$tool_name" ]]; then
        log_error "Tool name required. Use --tool <name> or provide as first argument."
        log_info "Run 'dsr quality --help' for usage"
        return 4
    fi

    # Build qg_run_checks arguments
    local qg_args=("$tool_name")
    $dry_run && qg_args+=("--dry-run")
    $skip_checks && qg_args+=("--skip-checks")
    [[ -n "$work_dir" ]] && qg_args+=("--work-dir" "$work_dir")

    # Run quality checks
    local result exit_code=0
    result=$(qg_run_checks "${qg_args[@]}") || exit_code=$?

    # Output
    if $JSON_MODE; then
        json_envelope "quality" "$([ $exit_code -eq 0 ] && echo success || echo failure)" "$exit_code" "$result"
    fi

    return $exit_code
}

# ============================================================================
# RELEASE SUBCOMMAND
# ============================================================================

_dispatch_is_true() {
    case "${1:-}" in
        true|TRUE|1|yes|YES|y|Y) return 0 ;;
        *) return 1 ;;
    esac
}

_dispatch_join_lines() {
    # Join newline-separated values into comma-separated string
    local input="$1"
    echo "$input" | tr '\n' ',' | sed 's/,$//'
}

_dispatch_load_config() {
    local tool_name="$1"

    local enabled=""
    local event_type=""
    local repos_csv=""

    # Env overrides (highest precedence)
    [[ -n "${DSR_DISPATCH_ENABLED:-}" ]] && enabled="$DSR_DISPATCH_ENABLED"
    [[ -n "${DSR_DISPATCH_EVENT:-}" ]] && event_type="$DSR_DISPATCH_EVENT"
    [[ -n "${DSR_DISPATCH_REPOS:-}" ]] && repos_csv="$DSR_DISPATCH_REPOS"

    # Config file overrides (requires yq)
    if command -v yq &>/dev/null; then
        local config_dir="${DSR_CONFIG_DIR:-$HOME/.config/dsr}"
        local tool_config="$config_dir/repos.d/${tool_name}.yaml"
        local cfg_enabled cfg_event cfg_repos

        if [[ -f "$tool_config" ]]; then
            cfg_enabled=$(yq -r '.dispatch.enabled // empty' "$tool_config" 2>/dev/null || echo "")
            cfg_event=$(yq -r '.dispatch.event_type // empty' "$tool_config" 2>/dev/null || echo "")
            cfg_repos=$(_dispatch_join_lines "$(yq -r '.dispatch.repos[]? // empty' "$tool_config" 2>/dev/null || true)")

            [[ -z "$enabled" && -n "$cfg_enabled" ]] && enabled="$cfg_enabled"
            [[ -z "$event_type" && -n "$cfg_event" ]] && event_type="$cfg_event"
            [[ -z "$repos_csv" && -n "$cfg_repos" ]] && repos_csv="$cfg_repos"
        fi

        if [[ -f "${DSR_CONFIG_FILE:-$config_dir/config.yaml}" ]]; then
            cfg_enabled=$(yq -r '.dispatch.enabled // empty' "${DSR_CONFIG_FILE:-$config_dir/config.yaml}" 2>/dev/null || echo "")
            cfg_event=$(yq -r '.dispatch.event_type // empty' "${DSR_CONFIG_FILE:-$config_dir/config.yaml}" 2>/dev/null || echo "")
            cfg_repos=$(_dispatch_join_lines "$(yq -r '.dispatch.repos[]? // empty' "${DSR_CONFIG_FILE:-$config_dir/config.yaml}" 2>/dev/null || true)")

            [[ -z "$enabled" && -n "$cfg_enabled" ]] && enabled="$cfg_enabled"
            [[ -z "$event_type" && -n "$cfg_event" ]] && event_type="$cfg_event"
            [[ -z "$repos_csv" && -n "$cfg_repos" ]] && repos_csv="$cfg_repos"
        fi
    fi

    # Defaults
    [[ -z "$event_type" ]] && event_type="dsr_release"
    if [[ -z "$enabled" && -n "$repos_csv" ]]; then
        enabled="true"
    fi

    echo "$enabled|$event_type|$repos_csv"
}

_dispatch_send_all() {
    local tool_name="$1"
    local version="$2"
    local tag="$3"
    local source_repo="$4"
    local git_sha="$5"
    local release_url="$6"
    local event_type="$7"
    local repos_csv="$8"
    local run_id="$9"

    if [[ -z "$repos_csv" ]]; then
        echo "[]"
        return 2
    fi

    if ! command -v jq &>/dev/null; then
        log_warn "jq not available; skipping repository dispatch"
        echo "[]"
        return 2
    fi

    local payload
    payload=$(jq -nc \
        --arg tool "$tool_name" \
        --arg version "$version" \
        --arg tag "$tag" \
        --arg repo "$source_repo" \
        --arg sha "$git_sha" \
        --arg run_id "$run_id" \
        --arg release_url "$release_url" \
        '{tool: $tool, version: $version, tag: $tag, repo: $repo, sha: $sha, run_id: $run_id, release_url: $release_url}')

    local results=()
    local any_failed=0
    local total=0
    local target
    IFS=',' read -ra targets <<< "$repos_csv"
    for target in "${targets[@]}"; do
        target="$(echo "$target" | xargs)"
        [[ -z "$target" ]] && continue

        if [[ "$target" != */* ]]; then
            target="Dicklesworthstone/$target"
        fi

        log_info "Dispatching $event_type to $target" "\"tool\":\"$tool_name\",\"version\":\"$version\",\"run_id\":\"$run_id\""

        local dispatch_status="success"
        local dispatch_error=""

        if command -v build_retry_with_backoff &>/dev/null; then
            if ! build_retry_with_backoff "${DSR_DISPATCH_RETRIES:-3}" gh_repository_dispatch "$target" "$event_type" "$payload"; then
                dispatch_status="failed"
                dispatch_error="dispatch failed"
            fi
        else
            if ! gh_repository_dispatch "$target" "$event_type" "$payload"; then
                dispatch_status="failed"
                dispatch_error="dispatch failed"
            fi
        fi

        if [[ "$dispatch_status" == "success" ]]; then
            log_ok "Dispatch sent to $target"
        else
            log_warn "Dispatch failed for $target"
        fi

        [[ "$dispatch_status" == "failed" ]] && any_failed=1
        total=$((total + 1))

        results+=("$(jq -nc \
            --arg repo "$target" \
            --arg status "$dispatch_status" \
            --arg error "$dispatch_error" \
            '{repo: $repo, status: $status, error: (if $error == "" then null else $error end)}')")
    done

    if [[ ${#results[@]} -gt 0 ]]; then
        printf '%s\n' "${results[@]}" | jq -s '.'
    else
        echo "[]"
    fi

    if [[ $total -eq 0 ]]; then
        return 2
    fi
    if [[ $any_failed -eq 1 ]]; then
        return 1
    fi
    return 0
}

cmd_release() {
    local tool_name=""
    local version=""
    local artifacts_dir=""
    local draft=false
    local prerelease=false
    local generate_notes=false
    local verify_tag=false
    local resume=false
    local verify_upgrade=false
    local dispatch_override=""
    local dispatch_event_override=""
    local dispatch_repos_override=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tool|-t)
                tool_name="$2"
                shift 2
                ;;
            --version|-V)
                version="$2"
                shift 2
                ;;
            --artifacts|--artifacts-dir|-a)
                artifacts_dir="$2"
                shift 2
                ;;
            --draft)
                draft=true
                shift
                ;;
            --prerelease)
                prerelease=true
                shift
                ;;
            --generate-notes)
                generate_notes=true
                shift
                ;;
            --verify-tag)
                verify_tag=true
                shift
                ;;
            --resume|-r)
                # shellcheck disable=SC2034
                resume=true
                log_warn "--resume is not yet implemented; proceeding with fresh upload"
                shift
                ;;
            --verify-upgrade)
                verify_upgrade=true
                shift
                ;;
            --dispatch)
                dispatch_override="true"
                shift
                ;;
            --no-dispatch)
                dispatch_override="false"
                shift
                ;;
            --dispatch-event)
                dispatch_event_override="$2"
                shift 2
                ;;
            --dispatch-repos)
                dispatch_repos_override="$2"
                shift 2
                ;;
            --help|-h)
                cat << 'EOF'
dsr release - Upload artifacts to GitHub

USAGE:
    dsr release <tool> <version>
    dsr release <tool> <version> --artifacts <dir>
    dsr release <tool> <version> --draft
    dsr release verify <tool> <version>   (verify existing release)

SUBCOMMANDS:
    verify    Verify release assets against build manifest

OPTIONS:
    -t, --tool <name>        Tool to release (or first positional arg)
    -V, --version <ver>      Version to release (or second positional arg)
    -a, --artifacts <dir>    Directory containing build artifacts
    --draft                  Create as draft release
    --prerelease             Mark as prerelease
    --generate-notes         Auto-generate release notes
    --verify-tag             Verify tag exists before release
    --verify-upgrade         Run upgrade verification after successful release
    --dispatch               Trigger repository dispatch after release
    --no-dispatch            Disable repository dispatch for this run
    --dispatch-event <name>  Override dispatch event type
    --dispatch-repos <list>  Comma-separated override of dispatch targets
    -r, --resume             Resume interrupted upload

DESCRIPTION:
    Creates a GitHub Release and uploads all build artifacts including
    binaries, checksums, and signatures. Uses manifest from build phase
    to verify completeness.

REQUIRED INPUTS:
    - Build manifest (source of truth from dsr build)
    - Checksums + signatures (from signing module)
    - Existing git tag for the version

EXAMPLES:
    dsr release ntm 1.2.3                   Create release v1.2.3
    dsr release ntm 1.2.3 --draft           Create as draft
    dsr release ntm 1.2.3 --verify-upgrade  Release + verify upgrade works
    dsr release ntm 1.2.3 --dispatch        Release + dispatch downstream workflows
    dsr release ntm 1.2.3 --resume          Resume interrupted upload
    dsr release verify ntm 1.2.3            Verify release assets
    dsr release --tool bv --version 2.0.0   Full flag syntax

EXIT CODES:
    0  - Release created successfully
    1  - Some assets failed to upload
    3  - Authentication error
    4  - Invalid arguments
    7  - Release creation failed
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr release --help' for usage"
                return 4
                ;;
            *)
                # Positional arguments: tool, version
                if [[ -z "$tool_name" ]]; then
                    tool_name="$1"
                elif [[ -z "$version" ]]; then
                    version="$1"
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$tool_name" ]]; then
        log_error "Tool name required"
        log_info "Run 'dsr release --help' for usage"
        return 4
    fi

    if [[ -z "$version" ]]; then
        log_error "Version required"
        log_info "Run 'dsr release --help' for usage"
        return 4
    fi

    # Check GitHub authentication
    if ! gh_check 2>/dev/null; then
        if ! gh_check_token 2>/dev/null; then
            log_error "GitHub authentication required"
            log_info "Run: gh auth login"
            if $JSON_MODE; then
                json_envelope "release" "error" 3 '{"error": "GitHub authentication required"}'
            fi
            return 3
        fi
    fi

    # Load tool configuration
    if ! act_load_repo_config "$tool_name" 2>/dev/null; then
        log_error "Tool '$tool_name' not found in repos.d"
        log_info "Available tools: $(act_list_tools 2>/dev/null | tr '\n' ' ')"
        return 4
    fi

    # Get repository info
    local repo local_path
    repo=$(act_get_repo "$tool_name")
    local_path=$(act_get_local_path "$tool_name")

    if [[ -z "$repo" ]]; then
        log_error "No GitHub repo configured for $tool_name"
        return 4
    fi

    # Resolve owner/repo if short name
    if [[ ! "$repo" =~ / ]]; then
        repo="Dicklesworthstone/$repo"
    fi

    # Normalize version tag
    local tag
    tag=$(git_ops_version_to_tag "$version")

    log_info "Releasing $tool_name $version to $repo"
    log_set_tool "$tool_name"

    # Verify tag exists (if requested or local_path available)
    if $verify_tag || [[ -n "$local_path" && -d "$local_path" ]]; then
        if [[ -n "$local_path" && -d "$local_path" ]]; then
            if ! git_ops_tag_exists "$local_path" "$tag"; then
                log_error "Tag $tag does not exist in $local_path"
                log_info "Create with: dsr version tag $tool_name"
                return 4
            fi
            log_info "Tag $tag verified locally"
        elif $verify_tag; then
            # User explicitly requested verification but no local path available
            log_warn "Cannot verify tag: local_path not configured for $tool_name"
            log_info "Tag verification skipped (GitHub will validate on release)"
        fi
    fi

    # Determine artifacts directory
    local state_dir="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
    if [[ -z "$artifacts_dir" ]]; then
        artifacts_dir="$state_dir/artifacts/$tool_name/$version"
    fi

    if [[ ! -d "$artifacts_dir" ]]; then
        log_error "Artifacts directory not found: $artifacts_dir"
        log_info "Run 'dsr build $tool_name --version $version' first"
        return 4
    fi

    # Find manifest
    local manifest_file="$artifacts_dir/${tool_name}-${version}-manifest.json"
    if [[ ! -f "$manifest_file" ]]; then
        # Try alternate location
        manifest_file="$state_dir/artifacts/${tool_name}-${version}-manifest.json"
    fi

    local manifest_exists=false
    if [[ -f "$manifest_file" ]]; then
        manifest_exists=true
        log_info "Using manifest: $manifest_file"
    else
        log_warn "No manifest found, will upload all files in artifacts directory"
    fi

    # Record start time
    local start_time
    start_time=$(date +%s)

    # Create or get release
    local release_json release_id upload_url release_url
    log_info "Creating GitHub release for $tag..."

    local release_args=""
    $draft && release_args+=" --draft"
    $prerelease && release_args+=" --prerelease"

    # Build release body
    local release_body="Release $version"
    if $generate_notes && [[ -n "$local_path" && -d "$local_path" ]]; then
        # Try to get previous tag for comparison
        local prev_tag
        prev_tag=$(git -C "$local_path" describe --tags --abbrev=0 "$tag^" 2>/dev/null || echo "")
        if [[ -n "$prev_tag" ]]; then
            local commit_log
            commit_log=$(git -C "$local_path" log --oneline "$prev_tag..$tag" 2>/dev/null | head -20)
            if [[ -n "$commit_log" ]]; then
                release_body="## Changes since $prev_tag"$'\n\n'"$commit_log"
            fi
        fi
    fi

    # shellcheck disable=SC2086
    release_json=$(gh_create_release "$repo" "$tag" --name "$tag" --body "$release_body" $release_args 2>&1)
    local create_status=$?

    if [[ $create_status -ne 0 ]]; then
        # Check if release already exists
        release_json=$(gh_api "repos/$repo/releases/tags/$tag" 2>/dev/null)
        if [[ -n "$release_json" ]] && echo "$release_json" | jq -e '.id' &>/dev/null; then
            log_info "Release $tag already exists, using existing release"
        else
            log_error "Failed to create release: $release_json"
            if $JSON_MODE; then
                json_envelope "release" "error" 7 "$(jq -nc --arg error "$release_json" '{error: $error}')"
            fi
            return 7
        fi
    fi

    release_id=$(echo "$release_json" | jq -r '.id')
    upload_url=$(echo "$release_json" | jq -r '.upload_url')
    release_url=$(echo "$release_json" | jq -r '.html_url')

    log_ok "Release created: $release_url"

    # Collect files to upload
    local files_to_upload=()
    local uploaded_assets=()
    local failed_assets=()
    local skipped_assets=()

    # Find all files in artifacts directory
    while IFS= read -r file; do
        [[ -f "$file" ]] && files_to_upload+=("$file")
    done < <(find "$artifacts_dir" -maxdepth 1 -type f 2>/dev/null)

    # Also look for checksum and signature files
    local checksum_file="$artifacts_dir/SHA256SUMS.txt"
    local sig_file="$artifacts_dir/SHA256SUMS.txt.minisig"

    local checksum_pattern=" $checksum_file "
    local sig_pattern=" $sig_file "
    [[ -f "$checksum_file" && ! " ${files_to_upload[*]} " =~ $checksum_pattern ]] && files_to_upload+=("$checksum_file")
    [[ -f "$sig_file" && ! " ${files_to_upload[*]} " =~ $sig_pattern ]] && files_to_upload+=("$sig_file")

    local total_files=${#files_to_upload[@]}
    log_info "Uploading $total_files file(s)..."

    # Upload state for resume
    local upload_state_file="$state_dir/releases/${tool_name}-${version}-upload.json"
    mkdir -p "$(dirname "$upload_state_file")"

    local already_uploaded=()
    if $resume && [[ -f "$upload_state_file" ]]; then
        while IFS= read -r name; do
            [[ -n "$name" ]] && already_uploaded+=("$name")
        done < <(jq -r '.uploaded[]?.name // empty' "$upload_state_file" 2>/dev/null)
        log_info "Resuming: ${#already_uploaded[@]} file(s) already uploaded"
    fi

    # Upload each file
    local idx=0
    for file in "${files_to_upload[@]}"; do
        idx=$((idx + 1))
        local filename
        filename=$(basename "$file")

        # Skip if already uploaded (resume mode)
        local filename_pattern=" $filename "
        if [[ " ${already_uploaded[*]} " =~ $filename_pattern ]]; then
            log_info "[$idx/$total_files] Skipping (already uploaded): $filename"
            skipped_assets+=("$filename")
            continue
        fi

        log_info "[$idx/$total_files] Uploading: $filename"

        local size_bytes
        size_bytes=$(stat -c %s "$file" 2>/dev/null || stat -f %z "$file" 2>/dev/null || echo 0)

        # Determine content type
        local content_type="application/octet-stream"
        case "$filename" in
            *.tar.gz|*.tgz) content_type="application/gzip" ;;
            *.zip) content_type="application/zip" ;;
            *.json) content_type="application/json" ;;
            *.txt) content_type="text/plain" ;;
            *.minisig) content_type="text/plain" ;;
        esac

        # Upload
        local upload_result
        if upload_result=$(gh_upload_asset "$upload_url" "$file" "$content_type" 2>&1); then
            log_ok "  Uploaded: $filename ($size_bytes bytes)"
            uploaded_assets+=("$(jq -nc \
                --arg name "$filename" \
                --argjson size "$size_bytes" \
                --arg content_type "$content_type" \
                '{name: $name, size_bytes: $size, content_type: $content_type, status: "uploaded"}')")

            # Update upload state for resume
            jq -nc --argjson uploaded "$(printf '%s\n' "${uploaded_assets[@]}" | jq -sc '.')" \
                '{uploaded: $uploaded}' > "$upload_state_file"
        else
            log_error "  Failed to upload: $filename"
            log_error "  Error: $upload_result"
            failed_assets+=("$(jq -nc \
                --arg name "$filename" \
                --arg error "$upload_result" \
                '{name: $name, error: $error}')")
        fi
    done

    # Calculate duration
    local end_time duration
    end_time=$(date +%s)
    duration=$((end_time - start_time))

    # Verify uploaded assets match manifest (if manifest exists)
    local verification_status="skipped"
    local missing_assets=()
    if $manifest_exists && [[ -f "$manifest_file" ]]; then
        verification_status="ok"
        while IFS= read -r expected_file; do
            [[ -z "$expected_file" ]] && continue
            local found=false
            # Check uploaded assets
            for asset in "${uploaded_assets[@]}"; do
                local asset_name
                asset_name=$(echo "$asset" | jq -r '.name')
                if [[ "$asset_name" == "$expected_file" ]]; then
                    found=true
                    break
                fi
            done
            # Also check skipped assets (from resume mode - already uploaded previously)
            if ! $found; then
                for skipped in "${skipped_assets[@]}"; do
                    if [[ "$skipped" == "$expected_file" ]]; then
                        found=true
                        break
                    fi
                done
            fi
            if ! $found; then
                missing_assets+=("$expected_file")
                verification_status="incomplete"
            fi
        done < <(jq -r '.artifacts[]?.filename // empty' "$manifest_file" 2>/dev/null)
    fi

    # Build result
    local success_count=${#uploaded_assets[@]}
    local failed_count=${#failed_assets[@]}
    local skipped_count=${#skipped_assets[@]}

    local status="success"
    local exit_code=0
    if [[ $failed_count -gt 0 ]]; then
        status="partial"
        exit_code=1
    fi

    # Repository dispatch (post-release hook)
    local dispatch_enabled dispatch_event dispatch_repos
    local dispatch_results_json="[]"
    local dispatch_status="skipped"
    local dispatch_cfg

    dispatch_cfg=$(_dispatch_load_config "$tool_name")
    IFS='|' read -r dispatch_enabled dispatch_event dispatch_repos <<< "$dispatch_cfg"

    [[ -n "$dispatch_override" ]] && dispatch_enabled="$dispatch_override"
    [[ -n "$dispatch_event_override" ]] && dispatch_event="$dispatch_event_override"
    [[ -n "$dispatch_repos_override" ]] && dispatch_repos="$dispatch_repos_override"

    if _dispatch_is_true "$dispatch_enabled" && [[ -n "$dispatch_repos" ]] && [[ $exit_code -eq 0 ]]; then
        local git_sha=""
        if [[ -n "$local_path" && -d "$local_path" ]]; then
            git_sha=$(git_ops_tag_sha "$local_path" "$tag" 2>/dev/null || true)
        fi
        if [[ -z "$git_sha" ]]; then
            git_sha=$(gh_resolve_tag_sha "$repo" "$tag" 2>/dev/null || true)
        fi
        [[ -z "$git_sha" ]] && git_sha="unknown"

        local dispatch_exit=0
        dispatch_results_json=$(_dispatch_send_all "$tool_name" "$version" "$tag" "$repo" "$git_sha" "$release_url" "$dispatch_event" "$dispatch_repos" "${DSR_RUN_ID:-run-unknown}") || dispatch_exit=$?
        case "$dispatch_exit" in
            0) dispatch_status="completed" ;;
            2) dispatch_status="skipped" ;;
            *) dispatch_status="failed" ;;
        esac
    elif _dispatch_is_true "$dispatch_enabled" && [[ -z "$dispatch_repos" ]]; then
        log_warn "Dispatch enabled but no target repos configured"
    fi

    # Clean up upload state on success
    if [[ $failed_count -eq 0 ]]; then
        rm -f "$upload_state_file"
    fi

    # Output
    if $JSON_MODE; then
        local details
        details=$(jq -nc \
            --arg repo "$repo" \
            --arg version "$version" \
            --arg tag "$tag" \
            --argjson release_id "$release_id" \
            --arg release_url "$release_url" \
            --arg upload_url "$upload_url" \
            --argjson draft "$draft" \
            --argjson prerelease "$prerelease" \
            --argjson uploaded "$(printf '%s\n' "${uploaded_assets[@]}" | jq -sc '.')" \
            --argjson failed "$(printf '%s\n' "${failed_assets[@]}" | jq -sc '.')" \
            --arg verification "$verification_status" \
            --argjson total "$total_files" \
            --argjson success "$success_count" \
            --argjson failed_count "$failed_count" \
            --argjson skipped "$skipped_count" \
            --argjson duration "$duration" \
            --arg dispatch_status "$dispatch_status" \
            --arg dispatch_event "$dispatch_event" \
            --arg dispatch_repos "$dispatch_repos" \
            --argjson dispatch_results "$dispatch_results_json" \
            '{
                repo: $repo,
                version: $version,
                tag: $tag,
                release_id: $release_id,
                release_url: $release_url,
                upload_url: $upload_url,
                draft: $draft,
                prerelease: $prerelease,
                assets_uploaded: $uploaded,
                assets_failed: $failed,
                verification: $verification,
                total: $total,
                success: $success,
                failed: $failed_count,
                skipped: $skipped,
                duration_seconds: $duration,
                dispatch: {
                    status: $dispatch_status,
                    event: $dispatch_event,
                    repos: (if $dispatch_repos == "" then [] else ($dispatch_repos | split(",") | map(gsub("^\\s+|\\s+$"; "")) | map(select(length > 0))) end),
                    results: $dispatch_results
                }
            }')
        json_envelope "release" "$status" "$exit_code" "$details"
    else
        echo ""
        if [[ $failed_count -eq 0 ]]; then
            log_ok "Release $tag complete: $success_count asset(s) uploaded"
        else
            log_error "Release $tag incomplete: $success_count uploaded, $failed_count failed"
        fi
        log_info "Release URL: $release_url"
        log_info "Duration: ${duration}s"

        if [[ ${#missing_assets[@]} -gt 0 ]]; then
            log_warn "Missing from manifest: ${missing_assets[*]}"
        fi
    fi

    # Run upgrade verification if requested and release succeeded
    if $verify_upgrade && [[ $exit_code -eq 0 ]]; then
        echo ""
        log_info "Running post-release upgrade verification..."
        if upgrade_verify_tool "$tool_name"; then
            log_ok "Upgrade verification passed for $tool_name"
        else
            log_warn "Upgrade verification failed for $tool_name"
            log_info "Run 'dsr verify upgrade $tool_name' to debug"
            # Don't fail the release, just warn
        fi
    fi

    return $exit_code
}

# ============================================================================
# RELEASE VERIFY SUBCOMMAND
# ============================================================================

cmd_release_verify() {
    local tool_name=""
    local version=""
    local verify_checksums=false
    local fix_missing=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tool|-t)
                tool_name="$2"
                shift 2
                ;;
            --version|-V)
                version="$2"
                shift 2
                ;;
            --verify-checksums|-c)
                verify_checksums=true
                shift
                ;;
            --fix)
                fix_missing=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr release verify - Verify release assets against build manifest

USAGE:
    dsr release verify <tool> <version>
    dsr release verify --tool <name> --version <tag>

OPTIONS:
    -t, --tool <name>       Tool to verify (or first positional arg)
    -V, --version <ver>     Version to verify (or second positional arg)
    -c, --verify-checksums  Download assets and verify SHA256 checksums
    --fix                   Re-upload missing assets (requires artifacts dir)

DESCRIPTION:
    Compares a GitHub release against the build manifest to verify all
    expected assets are present. Optionally downloads and verifies checksums.

OUTPUT:
    Reports missing, extra, or mismatched assets. JSON mode provides full
    verification report.

EXAMPLES:
    dsr release verify ntm 1.2.3               Quick manifest check
    dsr release verify ntm 1.2.3 --verify-checksums   Full checksum verify
    dsr release verify ntm 1.2.3 --fix         Re-upload missing assets

EXIT CODES:
    0  - All assets verified
    1  - Some assets missing or mismatched
    3  - Authentication error
    4  - Invalid arguments
    7  - Release not found
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr release verify --help' for usage"
                return 4
                ;;
            *)
                # Positional arguments: tool, version
                if [[ -z "$tool_name" ]]; then
                    tool_name="$1"
                elif [[ -z "$version" ]]; then
                    version="$1"
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$tool_name" ]]; then
        log_error "Tool name required"
        log_info "Run 'dsr release verify --help' for usage"
        return 4
    fi

    if [[ -z "$version" ]]; then
        log_error "Version required"
        log_info "Run 'dsr release verify --help' for usage"
        return 4
    fi

    # Check GitHub authentication
    if ! gh_check 2>/dev/null; then
        if ! gh_check_token 2>/dev/null; then
            log_error "GitHub authentication required"
            if $JSON_MODE; then
                json_envelope "release-verify" "error" 3 '{"error": "GitHub authentication required"}'
            fi
            return 3
        fi
    fi

    # Load tool configuration
    if ! act_load_repo_config "$tool_name" 2>/dev/null; then
        log_error "Tool '$tool_name' not found in repos.d"
        return 4
    fi

    # Get repository info
    local repo
    repo=$(act_get_repo "$tool_name")
    if [[ -z "$repo" ]]; then
        log_error "No GitHub repo configured for $tool_name"
        return 4
    fi

    # Resolve owner/repo if short name
    if [[ ! "$repo" =~ / ]]; then
        repo="Dicklesworthstone/$repo"
    fi

    # Normalize version tag
    local tag
    tag=$(git_ops_version_to_tag "$version")

    log_info "Verifying release $tool_name $tag from $repo"

    # Record start time
    local start_time
    start_time=$(date +%s)

    # Fetch release info from GitHub
    local release_json
    release_json=$(gh_api "repos/$repo/releases/tags/$tag" 2>/dev/null)
    if [[ -z "$release_json" ]] || ! echo "$release_json" | jq -e '.id' &>/dev/null; then
        log_error "Release $tag not found in $repo"
        if $JSON_MODE; then
            json_envelope "release-verify" "error" 7 "$(jq -nc --arg tag "$tag" '{error: "Release not found", tag: $tag}')"
        fi
        return 7
    fi

    local release_id release_url
    release_id=$(echo "$release_json" | jq -r '.id')
    release_url=$(echo "$release_json" | jq -r '.html_url')

    log_info "Found release: $release_url"

    # Get release assets
    local assets_json
    assets_json=$(echo "$release_json" | jq -c '.assets // []')
    local asset_count
    asset_count=$(echo "$assets_json" | jq 'length')

    log_info "Release has $asset_count asset(s)"

    # Load build manifest if available
    local state_dir="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
    local manifest_file="$state_dir/artifacts/$tool_name/$version/${tool_name}-${version}-manifest.json"
    if [[ ! -f "$manifest_file" ]]; then
        manifest_file="$state_dir/artifacts/${tool_name}-${version}-manifest.json"
    fi

    local manifest_exists=false
    local expected_assets=()
    if [[ -f "$manifest_file" ]]; then
        manifest_exists=true
        log_info "Using manifest: $manifest_file"
        while IFS= read -r name; do
            [[ -n "$name" ]] && expected_assets+=("$name")
        done < <(jq -r '.artifacts[]?.filename // empty' "$manifest_file" 2>/dev/null)
    else
        log_warn "No manifest found - cannot verify completeness"
    fi

    # Build verification report
    local missing_assets=()
    local present_assets=()
    local extra_assets=()
    local checksum_errors=()
    local verified_checksums=()

    # Get list of actual asset names from release
    local actual_assets=()
    while IFS= read -r name; do
        [[ -n "$name" ]] && actual_assets+=("$name")
    done < <(echo "$assets_json" | jq -r '.[].name')

    # Check for missing assets (in manifest but not in release)
    if $manifest_exists; then
        for expected in "${expected_assets[@]}"; do
            local found=false
            for actual in "${actual_assets[@]}"; do
                if [[ "$expected" == "$actual" ]]; then
                    found=true
                    present_assets+=("$expected")
                    break
                fi
            done
            if ! $found; then
                missing_assets+=("$expected")
            fi
        done
    fi

    # Check for extra assets (in release but not in manifest)
    if $manifest_exists; then
        for actual in "${actual_assets[@]}"; do
            local found=false
            for expected in "${expected_assets[@]}"; do
                if [[ "$expected" == "$actual" ]]; then
                    found=true
                    break
                fi
            done
            if ! $found; then
                extra_assets+=("$actual")
            fi
        done
    else
        # Without manifest, all assets are "present"
        present_assets=("${actual_assets[@]}")
    fi

    # Verify checksums if requested
    if $verify_checksums; then
        log_info "Verifying checksums..."

        # Find SHA256SUMS file in release
        local checksums_url=""
        local checksums_name=""
        for name in "${actual_assets[@]}"; do
            if [[ "$name" == *"SHA256"* ]] || [[ "$name" == *"sha256"* ]] || [[ "$name" == *"checksums"* ]]; then
                checksums_name="$name"
                checksums_url=$(echo "$assets_json" | jq -r --arg name "$name" '.[] | select(.name == $name) | .browser_download_url')
                break
            fi
        done

        if [[ -n "$checksums_url" ]]; then
            log_info "Found checksums file: $checksums_name"

            # Download checksums file
            local temp_dir
            temp_dir=$(mktemp -d)
            local checksums_file="$temp_dir/$checksums_name"

            if curl -sL "$checksums_url" -o "$checksums_file" 2>/dev/null; then
                # Verify a sample of assets
                local verify_count=0
                local verify_max=3  # Spot-check up to 3 assets

                for name in "${actual_assets[@]}"; do
                    # Skip checksums and signature files
                    [[ "$name" == *"SHA256"* ]] && continue
                    [[ "$name" == *"sha256"* ]] && continue
                    [[ "$name" == *".minisig" ]] && continue
                    [[ "$name" == *".sig" ]] && continue

                    if [[ $verify_count -ge $verify_max ]]; then
                        break
                    fi

                    # Get expected checksum from file (use awk for literal filename matching)
                    local expected_sum
                    expected_sum=$(awk -v fname="$name" '$2 == fname || $2 == "*" fname {print $1; exit}' "$checksums_file" 2>/dev/null)

                    if [[ -n "$expected_sum" ]]; then
                        log_info "  Verifying: $name"

                        # Download asset
                        local asset_url
                        asset_url=$(echo "$assets_json" | jq -r --arg name "$name" '.[] | select(.name == $name) | .browser_download_url')
                        local asset_file="$temp_dir/$name"

                        if curl -sL "$asset_url" -o "$asset_file" 2>/dev/null; then
                            local actual_sum
                            # Use sha256sum on Linux, shasum -a 256 on macOS
                            if command -v sha256sum &>/dev/null; then
                                actual_sum=$(sha256sum "$asset_file" | awk '{print $1}')
                            else
                                actual_sum=$(shasum -a 256 "$asset_file" | awk '{print $1}')
                            fi

                            if [[ "$expected_sum" == "$actual_sum" ]]; then
                                log_ok "    Checksum OK"
                                verified_checksums+=("$name")
                            else
                                log_error "    Checksum MISMATCH"
                                checksum_errors+=("$name")
                            fi
                        else
                            log_warn "    Failed to download for verification"
                        fi

                        ((verify_count++))
                    fi
                done
            else
                log_warn "Failed to download checksums file"
            fi

            # Cleanup
            rm -rf "$temp_dir"
        else
            log_warn "No checksums file found in release"
        fi
    fi

    # Fix missing assets if requested
    if $fix_missing && [[ ${#missing_assets[@]} -gt 0 ]]; then
        log_info "Attempting to re-upload ${#missing_assets[@]} missing asset(s)..."
        local artifacts_dir="$state_dir/artifacts/$tool_name/$version"

        for missing in "${missing_assets[@]}"; do
            local file_path="$artifacts_dir/$missing"
            if [[ -f "$file_path" ]]; then
                log_info "  Uploading: $missing"
                if gh release upload "$tag" "$file_path" --repo "$repo" --clobber 2>/dev/null; then
                    log_ok "    Uploaded"
                    # Move from missing to present
                    present_assets+=("$missing")
                else
                    log_error "    Upload failed"
                fi
            else
                log_warn "  Not found locally: $missing"
            fi
        done

        # Re-check missing assets
        missing_assets=()
        for expected in "${expected_assets[@]}"; do
            local found=false
            for present in "${present_assets[@]}"; do
                if [[ "$expected" == "$present" ]]; then
                    found=true
                    break
                fi
            done
            if ! $found; then
                missing_assets+=("$expected")
            fi
        done
    fi

    # Calculate duration
    local end_time duration
    end_time=$(date +%s)
    duration=$((end_time - start_time))

    # Determine status
    local status="success"
    local exit_code=0
    if [[ ${#missing_assets[@]} -gt 0 ]] || [[ ${#checksum_errors[@]} -gt 0 ]]; then
        status="incomplete"
        exit_code=1
    fi

    # Output
    if $JSON_MODE; then
        local details
        details=$(jq -nc \
            --arg repo "$repo" \
            --arg version "$version" \
            --arg tag "$tag" \
            --argjson release_id "$release_id" \
            --arg release_url "$release_url" \
            --argjson manifest_found "$manifest_exists" \
            --argjson expected_count "${#expected_assets[@]}" \
            --argjson present "$(printf '%s\n' "${present_assets[@]}" | jq -Rsc 'split("\n") | map(select(length > 0))')" \
            --argjson missing "$(printf '%s\n' "${missing_assets[@]}" | jq -Rsc 'split("\n") | map(select(length > 0))')" \
            --argjson extra "$(printf '%s\n' "${extra_assets[@]}" | jq -Rsc 'split("\n") | map(select(length > 0))')" \
            --argjson checksum_verified "$(printf '%s\n' "${verified_checksums[@]}" | jq -Rsc 'split("\n") | map(select(length > 0))')" \
            --argjson checksum_errors "$(printf '%s\n' "${checksum_errors[@]}" | jq -Rsc 'split("\n") | map(select(length > 0))')" \
            --argjson duration "$duration" \
            '{
                repo: $repo,
                version: $version,
                tag: $tag,
                release_id: $release_id,
                release_url: $release_url,
                manifest_found: $manifest_found,
                verification: {
                    expected: $expected_count,
                    present: ($present | length),
                    missing: ($missing | length),
                    extra: ($extra | length)
                },
                assets: {
                    present: $present,
                    missing: $missing,
                    extra: $extra
                },
                checksums: {
                    verified: $checksum_verified,
                    errors: $checksum_errors
                },
                duration_seconds: $duration
            }')
        json_envelope "release-verify" "$status" "$exit_code" "$details"
    else
        echo ""
        log_info "=== Verification Report ==="
        log_info "Tool:     $tool_name"
        log_info "Version:  $tag"
        log_info "Release:  $release_url"
        echo ""

        if $manifest_exists; then
            log_info "Expected: ${#expected_assets[@]} asset(s)"
        fi
        log_info "Present:  ${#present_assets[@]} asset(s)"

        if [[ ${#missing_assets[@]} -gt 0 ]]; then
            log_error "Missing:  ${#missing_assets[@]} asset(s)"
            for asset in "${missing_assets[@]}"; do
                log_error "  - $asset"
            done
        fi

        if [[ ${#extra_assets[@]} -gt 0 ]]; then
            log_warn "Extra:    ${#extra_assets[@]} asset(s) (not in manifest)"
            for asset in "${extra_assets[@]}"; do
                log_warn "  + $asset"
            done
        fi

        if $verify_checksums; then
            echo ""
            if [[ ${#verified_checksums[@]} -gt 0 ]]; then
                log_ok "Checksums verified: ${#verified_checksums[@]}"
            fi
            if [[ ${#checksum_errors[@]} -gt 0 ]]; then
                log_error "Checksum errors: ${#checksum_errors[@]}"
                for asset in "${checksum_errors[@]}"; do
                    log_error "  ! $asset"
                done
            fi
        fi

        echo ""
        if [[ $exit_code -eq 0 ]]; then
            log_ok "Verification: PASSED"
        else
            log_error "Verification: FAILED"
        fi
        log_info "Duration: ${duration}s"
    fi

    return $exit_code
}

cmd_fallback() {
    local tool_name=""
    local version=""
    local build_only=false
    local skip_checks=false
    local resume=false
    local output_dir=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tool|-t)
                tool_name="$2"
                shift 2
                ;;
            --version|-V)
                version="$2"
                shift 2
                ;;
            --build-only)
                build_only=true
                shift
                ;;
            --skip-checks)
                skip_checks=true
                shift
                ;;
            --resume|-r)
                resume=true
                log_warn "--resume is not yet implemented; proceeding with fresh build"
                shift
                ;;
            --output-dir|-o)
                output_dir="$2"
                shift 2
                ;;
            --help|-h)
                cat << 'EOF'
dsr fallback - Orchestrated build + release pipeline

USAGE:
    dsr fallback <tool>
    dsr fallback <tool> --version v1.2.3
    dsr fallback <tool> --build-only
    dsr fallback <tool> --skip-checks

OPTIONS:
    -t, --tool <name>      Tool to build/release
    -V, --version <ver>    Version to release (default: detect from version files)
    --build-only           Build artifacts but don't create release
    --skip-checks          Skip pre-release quality checks
    -r, --resume           Resume interrupted build
    -o, --output-dir <dir> Output directory for artifacts

DESCRIPTION:
    End-to-end fallback pipeline when GitHub Actions is throttled:
    1. Pre-release quality checks (unless --skip-checks)
    2. Build all targets using act + native hosts
    3. Generate manifest, checksums, signatures
    4. Verify artifacts match manifest
    5. Create GitHub release and upload assets

EXAMPLES:
    dsr fallback ntm                        Full pipeline
    dsr fallback ntm --version 1.2.3        Specific version
    dsr fallback ntm --build-only           Build without releasing
    dsr fallback ntm --skip-checks          Skip quality gates
    dsr --dry-run fallback ntm              Show plan without executing

EXIT CODES:
    0  - Pipeline completed successfully
    1  - Partial failure (some targets failed)
    2  - Lock conflict (build already in progress)
    4  - Invalid arguments
    6  - Build failed
    7  - Release failed
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr fallback --help' for usage"
                return 4
                ;;
            *)
                # First positional arg is tool name
                if [[ -z "$tool_name" ]]; then
                    tool_name="$1"
                fi
                shift
                ;;
        esac
    done

    # Validate tool name
    if [[ -z "$tool_name" ]]; then
        log_error "Tool name required"
        log_info "Run 'dsr fallback --help' for usage"
        return 4
    fi

    # Record start time
    local start_time run_id
    start_time=$(date +%s)
    run_id="${DSR_RUN_ID:-run-$start_time-$$}"
    export DSR_RUN_ID="$run_id"

    log_info "Starting fallback pipeline for $tool_name (run_id: $run_id)"
    log_set_tool "$tool_name"

    # Set output directory default
    local state_dir="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
    [[ -z "$output_dir" ]] && output_dir="$state_dir/artifacts"
    mkdir -p "$output_dir"

    # Load tool config
    if ! act_load_repo_config "$tool_name" 2>/dev/null; then
        log_error "Tool '$tool_name' not found in repos.d"
        if $JSON_MODE; then
            json_envelope "fallback" "error" 4 "$(jq -nc --arg tool "$tool_name" '{error: "Tool not found", tool: $tool}')"
        fi
        return 4
    fi

    # Get local path
    local local_path
    local_path=$(act_get_local_path "$tool_name")
    if [[ -z "$local_path" || ! -d "$local_path" ]]; then
        log_error "Local path not found for $tool_name: $local_path"
        return 4
    fi

    # Get GitHub repo
    local repo
    repo=$(act_get_repo "$tool_name")
    if [[ -z "$repo" ]]; then
        log_error "No GitHub repo configured for $tool_name"
        return 4
    fi
    [[ ! "$repo" =~ / ]] && repo="Dicklesworthstone/$repo"

    # Detect version if not specified
    if [[ -z "$version" ]]; then
        log_info "Detecting version from version files..."
        if version=$(version_detect "$local_path" 2>/dev/null); then
            log_info "Detected version: $version"
        else
            log_error "Cannot detect version. Specify with --version"
            return 4
        fi
    fi

    # Normalize version tag
    local tag
    tag=$(git_ops_version_to_tag "$version")
    local version_num="${tag#v}"

    if $DRY_RUN; then
        log_info "[dry-run] Would execute fallback pipeline:"
        log_info "  Tool:      $tool_name"
        log_info "  Version:   $tag"
        log_info "  Repo:      $repo"
        log_info "  Local:     $local_path"
        log_info "  Output:    $output_dir"
        log_info "  Skip checks: $skip_checks"
        log_info "  Build only: $build_only"
        if $JSON_MODE; then
            json_envelope "fallback" "dry_run" 0 "$(jq -nc \
                --arg tool "$tool_name" \
                --arg version "$tag" \
                --arg repo "$repo" \
                --argjson skip_checks "$skip_checks" \
                --argjson build_only "$build_only" \
                '{tool: $tool, version: $version, repo: $repo, skip_checks: $skip_checks, build_only: $build_only, mode: "dry_run"}')"
        fi
        return 0
    fi

    # Track status for summary
    local checks_status="skipped"
    local build_status="pending"
    local release_status="pending"
    local artifacts_count=0
    local exit_code=0

    # === Step 1: Pre-release checks ===
    if ! $skip_checks; then
        log_info "=== Step 1/4: Pre-release Checks ==="
        if quality_run_checks "$tool_name" --work-dir "$local_path" 2>/dev/null; then
            checks_status="passed"
            log_ok "Quality checks passed"
        else
            checks_status="failed"
            log_error "Quality checks failed"
            notify_event "fallback.checks_failed" "error" "Checks Failed" "$tool_name pre-release checks failed" "$run_id"
            if $JSON_MODE; then
                json_envelope "fallback" "error" 6 "$(jq -nc --arg tool "$tool_name" '{error: "Quality checks failed", tool: $tool, phase: "checks"}')"
            fi
            return 6
        fi
    else
        log_info "=== Step 1/4: Pre-release Checks (skipped) ==="
    fi

    # === Step 2: Acquire lock and build ===
    log_info "=== Step 2/4: Build Artifacts ==="

    # Initialize build state
    build_state_init

    # Acquire lock
    if ! build_lock_acquire "$tool_name" "$tag"; then
        log_error "Build already in progress for $tool_name $tag"
        if $JSON_MODE; then
            json_envelope "fallback" "error" 2 "$(jq -nc --arg tool "$tool_name" --arg version "$tag" '{error: "Lock conflict", tool: $tool, version: $version}')"
        fi
        return 2
    fi

    # Trap to release lock on exit
    trap 'build_lock_release "$tool_name" "$tag" 2>/dev/null' EXIT

    # Run build
    if cmd_build "$tool_name" --version "$version" --output-dir "$output_dir"; then
        build_status="success"
        log_ok "Build completed successfully"
    else
        local build_exit=$?
        if [[ $build_exit -eq 1 ]]; then
            build_status="partial"
            log_warn "Build partially succeeded"
        else
            build_status="failed"
            log_error "Build failed"
            notify_event "fallback.build_failed" "error" "Build Failed" "$tool_name build failed" "$run_id"
            exit_code=6
        fi
    fi

    # Count artifacts
    artifacts_count=$(find "$output_dir" -name "${tool_name}*" -type f 2>/dev/null | wc -l | tr -d ' ')

    if [[ "$build_status" == "failed" ]] || [[ "$artifacts_count" -eq 0 ]]; then
        build_lock_release "$tool_name" "$tag"
        trap - EXIT
        if $JSON_MODE; then
            json_envelope "fallback" "error" 6 "$(jq -nc --arg tool "$tool_name" '{error: "Build failed", tool: $tool, artifacts: 0}')"
        fi
        return 6
    fi

    # === Step 3: Verify artifacts ===
    log_info "=== Step 3/4: Verify Artifacts ==="
    log_info "Found $artifacts_count artifact(s) in $output_dir"

    # Generate checksums
    local checksums_file="$output_dir/${tool_name}-${version_num}-SHA256SUMS.txt"
    if command -v sha256sum &>/dev/null; then
        find "$output_dir" -maxdepth 1 -name "${tool_name}*" -type f ! -name "*SHA256*" ! -name "*manifest*" -exec sha256sum {} \; > "$checksums_file" 2>/dev/null || true
        log_ok "Generated checksums: $checksums_file"
    fi

    # Sign if enabled
    if signing_is_enabled 2>/dev/null; then
        log_info "Signing artifacts..."
        signing_sign_files "$output_dir" "${tool_name}*" 2>/dev/null || log_warn "Signing failed"
    fi

    # === Step 4: Release (unless --build-only) ===
    if $build_only; then
        log_info "=== Step 4/4: Release (skipped - build-only mode) ==="
        release_status="skipped"
    else
        log_info "=== Step 4/4: Create Release and Upload ==="

        # Create release
        if cmd_release "$tool_name" "$version" --artifacts "$output_dir"; then
            release_status="success"
            log_ok "Release created successfully"
            notify_event "fallback.success" "success" "Release Complete" "$tool_name $tag released successfully" "$run_id"
        else
            local release_exit=$?
            if [[ $release_exit -eq 1 ]]; then
                release_status="partial"
                log_warn "Release partially succeeded"
                exit_code=1
            else
                release_status="failed"
                log_error "Release failed"
                notify_event "fallback.release_failed" "error" "Release Failed" "$tool_name release upload failed" "$run_id"
                exit_code=7
            fi
        fi
    fi

    # Release lock
    build_lock_release "$tool_name" "$tag"
    trap - EXIT

    # Calculate duration
    local end_time duration
    end_time=$(date +%s)
    duration=$((end_time - start_time))

    # Determine overall status
    local overall_status="success"
    if [[ $exit_code -ne 0 ]]; then
        if [[ "$build_status" == "partial" ]] || [[ "$release_status" == "partial" ]]; then
            overall_status="partial"
        else
            overall_status="failed"
        fi
    fi

    # Output summary
    if $JSON_MODE; then
        json_envelope "fallback" "$overall_status" "$exit_code" "$(jq -nc \
            --arg tool "$tool_name" \
            --arg version "$tag" \
            --arg repo "$repo" \
            --arg run_id "$run_id" \
            --arg checks "$checks_status" \
            --arg build "$build_status" \
            --arg release "$release_status" \
            --argjson artifacts "$artifacts_count" \
            --argjson duration "$duration" \
            --arg output_dir "$output_dir" \
            '{
                tool: $tool,
                version: $version,
                repo: $repo,
                run_id: $run_id,
                phases: {
                    checks: $checks,
                    build: $build,
                    release: $release
                },
                artifacts_count: $artifacts,
                duration_seconds: $duration,
                output_dir: $output_dir
            }')"
    else
        echo ""
        log_info "=== Fallback Pipeline Summary ==="
        log_info "Tool:       $tool_name"
        log_info "Version:    $tag"
        log_info "Run ID:     $run_id"
        log_info "Duration:   ${duration}s"
        echo ""
        log_info "Phases:"
        case "$checks_status" in
            passed) log_ok "  Checks:   passed" ;;
            skipped) log_info "  Checks:   skipped" ;;
            *) log_error "  Checks:   $checks_status" ;;
        esac
        case "$build_status" in
            success) log_ok "  Build:    success ($artifacts_count artifacts)" ;;
            partial) log_warn "  Build:    partial ($artifacts_count artifacts)" ;;
            *) log_error "  Build:    $build_status" ;;
        esac
        case "$release_status" in
            success) log_ok "  Release:  success" ;;
            skipped) log_info "  Release:  skipped (build-only)" ;;
            partial) log_warn "  Release:  partial" ;;
            *) log_error "  Release:  $release_status" ;;
        esac
        echo ""
        log_info "Artifacts: $output_dir"
    fi

    return $exit_code
}

cmd_repos() {
    local subcmd="${1:-list}"
    shift 2>/dev/null || true

    case "$subcmd" in
        list)
            cmd_repos_list "$@"
            ;;
        add)
            cmd_repos_add "$@"
            ;;
        remove)
            cmd_repos_remove "$@"
            ;;
        info)
            cmd_repos_info "$@"
            ;;
        validate)
            cmd_repos_validate "$@"
            ;;
        discover)
            cmd_repos_discover "$@"
            ;;
        sync)
            cmd_repos_sync "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr repos - Manage repository registry

USAGE:
    dsr repos <subcommand> [options]

SUBCOMMANDS:
    list        List all registered repositories
    add         Add a repository to the registry
    remove      Remove a repository from the registry
    info        Show detailed info for a repository
    validate    Validate repository configurations
    discover    Discover repos that could benefit from dsr
    sync        Sync repository metadata from GitHub

OPTIONS:
    --json      Output in JSON format (global)

EXAMPLES:
    dsr repos list                          List all repos
    dsr repos add ntm --local-path /data/projects/ntm
    dsr repos add dicklesworthstone/bv
    dsr repos remove ntm
    dsr repos info ntm --json
    dsr repos validate
    dsr repos discover --path /data/projects

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            log_error "Unknown repos subcommand: $subcmd"
            log_info "Run 'dsr repos --help' for usage"
            return 4
            ;;
    esac
}

# List all registered repositories
cmd_repos_list() {
    local format="table"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format|-f)
                format="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Load repos config
    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found: $DSR_REPOS_FILE"
        log_info "Run: dsr config init"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 '{"action": "list", "repos": [], "errors": [{"code": "E052", "message": "repos file not found"}]}'
        fi
        return 4
    fi

    local repos_json="[]"
    if command -v yq &>/dev/null; then
        repos_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null | jq -c '
            to_entries | map({
                name: .key,
                repo: (.value.repo // ""),
                local_path: (.value.local_path // ""),
                language: (.value.language // ""),
                targets: (.value.targets // []),
                workflow: (.value.workflow // ""),
                enabled: (.value.enabled // true)
            })
        ' 2>/dev/null || echo "[]")
    else
        # Fallback: simple parsing without yq
        repos_json="[]"
        log_warn "yq not found. Install yq for full repos functionality."
    fi

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson repos "$repos_json" '{action: "list", repos: $repos}')"
    else
        local count
        count=$(echo "$repos_json" | jq 'length')

        if [[ "$count" -eq 0 ]]; then
            log_info "No repositories registered."
            log_info "Run: dsr repos add <owner/repo> --local-path <path>"
            return 0
        fi

        log_info "Registered repositories ($count):"
        echo ""

        if [[ "$format" == "table" ]]; then
            printf "%-12s %-30s %-10s %s\n" "NAME" "REPO" "LANGUAGE" "TARGETS"
            printf "%s\n" "$(printf '%.0s-' {1..80})"
            echo "$repos_json" | jq -r '.[] | [.name, .repo, .language, (.targets | join(","))] | @tsv' | \
                while IFS=$'\t' read -r name repo lang targets; do
                    printf "%-12s %-30s %-10s %s\n" "$name" "$repo" "${lang:-?}" "${targets:-all}"
                done
        else
            echo "$repos_json" | jq -r '.[] | "\(.name): \(.repo)"'
        fi
    fi
}

# Add a repository to the registry
cmd_repos_add() {
    local repo_input=""
    local local_path=""
    local language=""
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --local-path|-p)
                local_path="$2"
                shift 2
                ;;
            --language|-l)
                language="$2"
                shift 2
                ;;
            --name|-n)
                name="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                return 4
                ;;
            *)
                repo_input="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$repo_input" ]]; then
        log_error "Usage: dsr repos add <owner/repo|name> [--local-path <path>] [--language <lang>]"
        return 4
    fi

    # Parse repo input - could be "owner/repo" or just "name"
    local repo
    if [[ "$repo_input" =~ / ]]; then
        repo="$repo_input"
        [[ -z "$name" ]] && name="${repo_input#*/}"
    else
        name="$repo_input"
        repo=""
    fi

    # Validate local_path if provided
    if [[ -n "$local_path" ]]; then
        # Source guardrails for path resolution
        source "$SCRIPT_DIR/src/guardrails.sh"
        local_path=$(resolve_path "$local_path" 2>&1) || {
            log_error "Invalid local path: $local_path"
            if $JSON_MODE; then
                json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "add", repo: $name, errors: [{code: "E052", message: "invalid local path"}]}')"
            fi
            return 4
        }

        # Auto-detect language if not specified
        if [[ -z "$language" && -d "$local_path" ]]; then
            if [[ -f "$local_path/Cargo.toml" ]]; then
                language="rust"
            elif [[ -f "$local_path/go.mod" ]]; then
                language="go"
            elif [[ -f "$local_path/package.json" ]]; then
                if [[ -f "$local_path/bun.lockb" ]]; then
                    language="bun"
                else
                    language="node"
                fi
            elif [[ -f "$local_path/pyproject.toml" || -f "$local_path/setup.py" ]]; then
                language="python"
            fi
        fi

        # Auto-detect repo from git remote if not specified
        if [[ -z "$repo" && -d "$local_path/.git" ]]; then
            local remote_url
            remote_url=$(git -C "$local_path" remote get-url origin 2>/dev/null || true)
            if [[ -n "$remote_url" ]]; then
                # Parse owner/repo from git URL
                repo=$(echo "$remote_url" | sed -E 's#.*(github\.com[:/])([^/]+/[^/]+)(\.git)?$#\2#')
                repo="${repo%.git}"
            fi
        fi
    fi

    # Check if yq is available for writing
    if ! command -v yq &>/dev/null; then
        log_error "yq is required to add repositories"
        log_info "Install: brew install yq  OR  apt install yq"
        if $JSON_MODE; then
            json_envelope "repos" "error" 3 '{"action": "add", "errors": [{"code": "E041", "message": "yq required"}]}'
        fi
        return 3
    fi

    # Ensure repos file exists
    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_warn "Repos file not found, running config init..."
        config_init >/dev/null 2>&1
    fi

    # Check if already exists
    local existing
    existing=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    if [[ "$existing" != "null" && -n "$existing" ]]; then
        log_error "Repository '$name' already exists"
        log_info "Use 'dsr repos remove $name' first, or choose a different name"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "add", repo: $name, errors: [{code: "E052", message: "repo already exists"}]}')"
        fi
        return 4
    fi

    # Build the tool entry
    local tool_yaml=""
    tool_yaml+="repo: \"${repo:-}\""
    [[ -n "$local_path" ]] && tool_yaml+="\n    local_path: \"$local_path\""
    [[ -n "$language" ]] && tool_yaml+="\n    language: \"$language\""
    tool_yaml+="\n    targets:\n      - linux/amd64\n      - darwin/arm64\n      - windows/amd64"

    # Add to repos.yaml using yq
    yq -i ".tools.$name = {}" "$DSR_REPOS_FILE"
    [[ -n "$repo" ]] && yq -i ".tools.$name.repo = \"$repo\"" "$DSR_REPOS_FILE"
    [[ -n "$local_path" ]] && yq -i ".tools.$name.local_path = \"$local_path\"" "$DSR_REPOS_FILE"
    [[ -n "$language" ]] && yq -i ".tools.$name.language = \"$language\"" "$DSR_REPOS_FILE"
    yq -i ".tools.$name.targets = [\"linux/amd64\", \"darwin/arm64\", \"windows/amd64\"]" "$DSR_REPOS_FILE"

    if $JSON_MODE; then
        local added_json
        added_json=$(jq -nc \
            --arg name "$name" \
            --arg repo "${repo:-}" \
            --arg local_path "${local_path:-}" \
            --arg language "${language:-}" \
            '{name: $name, repo: $repo, local_path: $local_path, language: $language, targets: ["linux/amd64", "darwin/arm64", "windows/amd64"]}')
        json_envelope "repos" "success" 0 "$(jq -nc --argjson added "[$added_json]" '{action: "add", added: $added}')"
    else
        log_ok "Added repository: $name"
        [[ -n "$repo" ]] && log_info "  repo: $repo"
        [[ -n "$local_path" ]] && log_info "  local_path: $local_path"
        [[ -n "$language" ]] && log_info "  language: $language"
    fi
}

# Remove a repository from the registry
cmd_repos_remove() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: dsr repos remove <name>"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq is required to remove repositories"
        if $JSON_MODE; then
            json_envelope "repos" "error" 3 '{"action": "remove", "errors": [{"code": "E041", "message": "yq required"}]}'
        fi
        return 3
    fi

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    # Check if exists
    local existing
    existing=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    if [[ "$existing" == "null" || -z "$existing" ]]; then
        log_error "Repository '$name' not found"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "remove", repo: $name, errors: [{code: "E052", message: "repo not found"}]}')"
        fi
        return 4
    fi

    # Remove from repos.yaml
    yq -i "del(.tools.$name)" "$DSR_REPOS_FILE"

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --arg name "$name" '{action: "remove", removed: [{name: $name}]}')"
    else
        log_ok "Removed repository: $name"
    fi
}

# Show detailed info for a repository
cmd_repos_info() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        log_error "Usage: dsr repos info <name>"
        return 4
    fi

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    local tool_yaml
    if command -v yq &>/dev/null; then
        tool_yaml=$(yq ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null)
    else
        log_error "yq required for repos info"
        return 3
    fi

    if [[ "$tool_yaml" == "null" || -z "$tool_yaml" ]]; then
        log_error "Repository '$name' not found"
        if $JSON_MODE; then
            json_envelope "repos" "error" 4 "$(jq -nc --arg name "$name" '{action: "info", repo: $name, errors: [{code: "E052", message: "repo not found"}]}')"
        fi
        return 4
    fi

    local tool_json
    tool_json=$(yq -o=json ".tools.$name" "$DSR_REPOS_FILE" 2>/dev/null | jq -c --arg name "$name" '. + {name: $name}')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson repos "[$tool_json]" --arg name "$name" '{action: "info", repo: $name, repos: $repos}')"
    else
        log_info "Repository: $name"
        echo ""
        echo "$tool_json" | jq -r 'to_entries[] | "  \(.key): \(.value)"'
    fi
}

# ---------------------------------------------------------------------------
# GoReleaser compatibility validation helpers
# ---------------------------------------------------------------------------

_goreleaser_find_config() {
    local repo_path="$1"
    local candidates=(
        ".goreleaser.yaml"
        ".goreleaser.yml"
    )
    local candidate
    for candidate in "${candidates[@]}"; do
        if [[ -f "$repo_path/$candidate" ]]; then
            echo "$repo_path/$candidate"
            return 0
        fi
    done
    return 1
}

_goreleaser_extract_targets() {
    local gr_json="$1"
    printf '%s\n' "$gr_json" | jq -r '
        (.builds // []) as $builds
        | if ($builds | length) == 0 then empty else
            [ $builds[]
              | (.goos // []) as $os
              | (.goarch // []) as $arch
              | if ($os | length) == 0 or ($arch | length) == 0 then empty
                else $os[] as $o | $arch[] as $a | "\($o)/\($a)"
                end
            ] | unique | .[]
          end
    ' 2>/dev/null
}

_goreleaser_render_template() {
    local template="$1"
    local project_name="$2"
    local version="$3"
    local os="$4"
    local arch="$5"
    local ext="$6"
    local binary="$7"

    local rendered="$template"
    # Note: In sed -E, curly braces are special (quantifiers), so escape them
    rendered=$(echo "$rendered" | sed -E \
        -e "s/\{\{[^}]*\.ProjectName[^}]*\}\}/$project_name/g" \
        -e "s/\{\{[^}]*\.Binary[^}]*\}\}/$binary/g" \
        -e "s/\{\{[^}]*\.Version[^}]*\}\}/$version/g" \
        -e "s/\{\{[^}]*\.Os[^}]*\}\}/$os/g" \
        -e "s/\{\{[^}]*\.Arch[^}]*\}\}/$arch/g" \
        -e "s/\{\{[^}]*\.Arm[^}]*\}\}//g" \
        -e "s/\{\{[^}]*\.Ext[^}]*\}\}/$ext/g")

    echo "$rendered"
}

_dsr_render_artifact_name() {
    local pattern="$1"
    local name="$2"
    local version="$3"
    local os="$4"
    local arch="$5"
    local binary="$6"
    local ext="$7"

    local rendered="$pattern"
    rendered="${rendered//\$\{name\}/$name}"
    rendered="${rendered//\$\{binary\}/$binary}"
    rendered="${rendered//\$\{version\}/$version}"
    rendered="${rendered//\$\{os\}/$os}"
    rendered="${rendered//\$\{arch\}/$arch}"
    rendered="${rendered//\$\{ext\}/$ext}"

    echo "$rendered"
}

goreleaser_validate_tool() {
    local tool_name="$1"
    local tool_json="$2"
    local repo_path="$3"

    local messages=()
    local status="ok"

    if [[ -z "$repo_path" || ! -d "$repo_path" ]]; then
        echo "skip|"
        return 0
    fi

    local gr_config
    if ! gr_config=$(_goreleaser_find_config "$repo_path"); then
        echo "skip|"
        return 0
    fi

    if ! command -v jq &>/dev/null; then
        echo "warn|jq required for goreleaser validation"
        return 0
    fi

    local gr_json
    if ! gr_json=$(yq -o=json '.' "$gr_config" 2>/dev/null); then
        echo "warn|Unable to parse goreleaser config: $gr_config"
        return 0
    fi

    # Merge repos.yaml config with repos.d config if present (repos.d takes precedence)
    local merged_json="$tool_json"
    local dsr_config_file="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/repos.d/${tool_name}.yaml"
    if [[ -f "$dsr_config_file" ]]; then
        local dsr_json
        if dsr_json=$(yq -o=json '.' "$dsr_config_file" 2>/dev/null); then
            merged_json=$(jq -s '.[0] * .[1]' \
                <(printf '%s\n' "$tool_json") \
                <(printf '%s\n' "$dsr_json") 2>/dev/null) || merged_json="$tool_json"
        fi
    fi

    # Extract dsr targets
    local dsr_targets=()
    mapfile -t dsr_targets < <(printf '%s\n' "$merged_json" | jq -r '.targets[]?' 2>/dev/null)

    # Extract goreleaser targets
    local gr_targets=()
    mapfile -t gr_targets < <(_goreleaser_extract_targets "$gr_json")

    if [[ ${#dsr_targets[@]} -eq 0 ]]; then
        status="warn"
        messages+=("No dsr targets defined; cannot validate goreleaser targets")
    elif [[ ${#gr_targets[@]} -eq 0 ]]; then
        status="warn"
        messages+=("No goreleaser targets found in config")
    else
        local missing_in_dsr missing_in_gr
        missing_in_dsr=$(comm -23 \
            <(printf '%s\n' "${gr_targets[@]}" | sort -u) \
            <(printf '%s\n' "${dsr_targets[@]}" | sort -u) 2>/dev/null)
        missing_in_gr=$(comm -23 \
            <(printf '%s\n' "${dsr_targets[@]}" | sort -u) \
            <(printf '%s\n' "${gr_targets[@]}" | sort -u) 2>/dev/null)
        if [[ -n "$missing_in_dsr" ]]; then
            status="warn"
            messages+=("Targets missing in dsr config: $(echo "$missing_in_dsr" | paste -sd ',' -)")
        fi
        if [[ -n "$missing_in_gr" ]]; then
            status="warn"
            messages+=("Targets missing in goreleaser config: $(echo "$missing_in_gr" | paste -sd ',' -)")
        fi
    fi

    # Archive format comparison
    local gr_archive
    gr_archive=$(printf '%s\n' "$gr_json" | jq -c '.archives[0] // {}' 2>/dev/null)
    local gr_format_default
    gr_format_default=$(printf '%s\n' "$gr_archive" | jq -r '
        if .format then .format
        elif (.formats | type) == "array" and (.formats | length) > 0 then .formats[0]
        else "" end
    ' 2>/dev/null)

    if [[ -z "$gr_format_default" ]]; then
        status="warn"
        messages+=("No default archive format in goreleaser config")
    fi

    local target
    for target in "${dsr_targets[@]}"; do
        local os arch
        os="${target%%/*}"
        arch="${target##*/}"

        local dsr_format
        dsr_format=$(printf '%s\n' "$merged_json" | jq -r --arg os "$os" '
            if .archive_format == null then ""
            elif (.archive_format | type) == "string" then .archive_format
            elif (.archive_format | type) == "object" then .archive_format[$os] // ""
            else "" end
        ' 2>/dev/null)

        local gr_format
        gr_format=$(printf '%s\n' "$gr_archive" | jq -r --arg os "$os" '
            (.format_overrides // []) as $o
            | ($o[]? | select(.goos == $os) | .format) // empty
        ' 2>/dev/null | head -n1)
        [[ -z "$gr_format" ]] && gr_format="$gr_format_default"

        if [[ -n "$dsr_format" && -n "$gr_format" && "$dsr_format" != "$gr_format" ]]; then
            status="warn"
            messages+=("Archive format mismatch for $os/$arch: dsr=$dsr_format goreleaser=$gr_format")
        elif [[ -z "$dsr_format" ]]; then
            status="warn"
            messages+=("Archive format missing in dsr config for $os/$arch")
        fi
    done

    # Artifact naming template comparison (best-effort)
    local dsr_pattern
    dsr_pattern=$(printf '%s\n' "$merged_json" | jq -r '.artifact_naming // empty' 2>/dev/null)
    local gr_name_template
    gr_name_template=$(printf '%s\n' "$gr_archive" | jq -r '.name_template // empty' 2>/dev/null)

    local dsr_binary
    dsr_binary=$(printf '%s\n' "$merged_json" | jq -r '.binary_name // empty' 2>/dev/null)
    local gr_project_name
    gr_project_name=$(printf '%s\n' "$gr_json" | jq -r '.project_name // empty' 2>/dev/null)
    [[ -z "$gr_project_name" ]] && gr_project_name="$tool_name"

    if [[ -n "$dsr_pattern" && -n "$gr_name_template" ]]; then
        local sample_version="1.2.3"
        local name_mismatch=false
        for target in "${dsr_targets[@]}"; do
            local os arch dsr_format gr_format
            os="${target%%/*}"
            arch="${target##*/}"

            dsr_format=$(printf '%s\n' "$merged_json" | jq -r --arg os "$os" '
                if .archive_format == null then ""
                elif (.archive_format | type) == "string" then .archive_format
                elif (.archive_format | type) == "object" then .archive_format[$os] // ""
                else "" end
            ' 2>/dev/null)
            gr_format=$(printf '%s\n' "$gr_archive" | jq -r --arg os "$os" '
                (.format_overrides // []) as $o
                | ($o[]? | select(.goos == $os) | .format) // empty
            ' 2>/dev/null | head -n1)
            [[ -z "$gr_format" ]] && gr_format="$gr_format_default"

            local dsr_name gr_name
            dsr_name=$(_dsr_render_artifact_name "$dsr_pattern" "$tool_name" "$sample_version" "$os" "$arch" "$dsr_binary" "$dsr_format")
            gr_name=$(_goreleaser_render_template "$gr_name_template" "$gr_project_name" "$sample_version" "$os" "$arch" "$gr_format" "$dsr_binary")
            if [[ "$dsr_name" != "$gr_name" ]]; then
                name_mismatch=true
                messages+=("Artifact name mismatch for $os/$arch: dsr='$dsr_name' goreleaser='$gr_name'")
                break
            fi
        done
        if $name_mismatch; then
            status="warn"
        fi
    else
        status="warn"
        messages+=("Missing artifact_naming or goreleaser name_template")
    fi

    local msg_str=""
    [[ ${#messages[@]} -gt 0 ]] && msg_str=$(IFS='; '; echo "${messages[*]}")
    echo "$status|$msg_str"
}

# Validate repository configurations
cmd_repos_validate() {
    local repo_filter="${1:-}"

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq required for validation"
        return 3
    fi

    local tools_json
    tools_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null)

    local results=()
    local errors=0
    local warnings=0

    while IFS= read -r name; do
        [[ -z "$name" ]] && continue
        [[ -n "$repo_filter" && "$name" != "$repo_filter" ]] && continue

        local tool_json
        tool_json=$(echo "$tools_json" | jq -c --arg name "$name" '.[$name]')

        local status="ok"
        local messages=()

        # Check required fields
        local repo local_path
        repo=$(echo "$tool_json" | jq -r '.repo // ""')
        local_path=$(echo "$tool_json" | jq -r '.local_path // ""')

        if [[ -z "$repo" && -z "$local_path" ]]; then
            status="error"
            messages+=("Missing both 'repo' and 'local_path' - need at least one")
            ((errors++))
        fi

        local resolved_path=""
        # Check local_path exists
        if [[ -n "$local_path" ]]; then
            source "$SCRIPT_DIR/src/guardrails.sh"
            resolved_path=$(resolve_path "$local_path" 2>/dev/null) || {
                status="error"
                messages+=("Invalid local_path: $local_path")
                ((errors++))
            }
            if [[ -n "$resolved_path" && ! -d "$resolved_path" ]]; then
                status="warn"
                messages+=("local_path does not exist: $resolved_path")
                ((warnings++))
            fi
        fi

        # Check workflow file exists
        local workflow
        workflow=$(echo "$tool_json" | jq -r '.workflow // ""')
        if [[ -n "$workflow" && -n "$local_path" ]]; then
            source "$SCRIPT_DIR/src/guardrails.sh"
            local resolved_path
            resolved_path=$(resolve_path "$local_path" 2>/dev/null) || true
            if [[ -n "$resolved_path" && ! -f "$resolved_path/$workflow" ]]; then
                if [[ "$status" != "error" ]]; then
                    status="warn"
                fi
                messages+=("Workflow file not found: $workflow")
                ((warnings++))
            fi
        fi

        # GoReleaser compatibility validation (best-effort)
        local gr_result gr_status gr_message
        gr_result=$(goreleaser_validate_tool "$name" "$tool_json" "$resolved_path")
        gr_status="${gr_result%%|*}"
        gr_message="${gr_result#*|}"
        if [[ "$gr_status" == "warn" && -n "$gr_message" ]]; then
            if [[ "$status" != "error" ]]; then
                status="warn"
            fi
            messages+=("$gr_message")
            ((warnings++))
        elif [[ "$gr_status" == "error" && -n "$gr_message" ]]; then
            status="error"
            messages+=("$gr_message")
            ((errors++))
        fi

        local msg_str=""
        [[ ${#messages[@]} -gt 0 ]] && msg_str=$(IFS='; '; echo "${messages[*]}")

        results+=("$(jq -nc --arg repo "$name" --arg status "$status" --arg message "$msg_str" \
            '{repo: $repo, status: $status, message: $message}')")

        if ! $JSON_MODE; then
            if [[ "$status" == "ok" ]]; then
                log_ok "$name: OK"
            elif [[ "$status" == "warn" ]]; then
                log_warn "$name: $msg_str"
            else
                log_error "$name: $msg_str"
            fi
        fi

    done < <(echo "$tools_json" | jq -r 'keys[]')

    local results_json
    results_json=$(printf '%s\n' "${results[@]}" | jq -sc '.')

    if $JSON_MODE; then
        local status="success"
        local exit_code=0
        if [[ $errors -gt 0 ]]; then
            status="error"
            exit_code=1
        elif [[ $warnings -gt 0 ]]; then
            status="partial"
        fi
        json_envelope "repos" "$status" "$exit_code" "$(jq -nc --argjson validated "$results_json" '{action: "validate", validated: $validated}')"
    else
        echo ""
        if [[ $errors -gt 0 ]]; then
            log_error "Validation found $errors error(s), $warnings warning(s)"
            return 1
        elif [[ $warnings -gt 0 ]]; then
            log_warn "Validation found $warnings warning(s)"
        else
            log_ok "All repositories validated successfully"
        fi
    fi
}

# Discover repositories that could benefit from dsr
cmd_repos_discover() {
    local search_path="/data/projects"
    local apply=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --path|-p)
                search_path="$2"
                shift 2
                ;;
            --apply)
                apply=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Validate search path
    source "$SCRIPT_DIR/src/guardrails.sh"
    # shellcheck disable=SC2034 # Used by guardrails is_non_interactive
    [[ "$NON_INTERACTIVE" == "true" ]] && DSR_NON_INTERACTIVE=true
    search_path=$(resolve_path "$search_path" --must-exist 2>&1) || {
        log_error "Invalid search path: $search_path"
        return 4
    }

    log_info "Scanning $search_path for buildable projects..."

    local discovered=()

    # Find directories with build files
    while IFS= read -r dir; do
        local name
        name=$(basename "$dir")
        local language=""
        local repo=""

        # Detect language
        if [[ -f "$dir/Cargo.toml" ]]; then
            language="rust"
        elif [[ -f "$dir/go.mod" ]]; then
            language="go"
        elif [[ -f "$dir/package.json" ]]; then
            language="node"
        else
            continue
        fi

        # Get repo from git remote
        if [[ -d "$dir/.git" ]]; then
            local remote_url
            remote_url=$(git -C "$dir" remote get-url origin 2>/dev/null || true)
            if [[ -n "$remote_url" ]]; then
                repo=$(echo "$remote_url" | sed -E 's#.*(github\.com[:/])([^/]+/[^/]+)(\.git)?$#\2#')
                repo="${repo%.git}"
            fi
        fi

        # Check if has release workflow
        local has_workflow=false
        if [[ -d "$dir/.github/workflows" ]]; then
            if grep -l -E 'release|build' "$dir/.github/workflows/"*.yml "$dir/.github/workflows/"*.yaml 2>/dev/null | head -1 >/dev/null; then
                has_workflow=true
            fi
        fi

        local entry
        entry=$(jq -nc \
            --arg name "$name" \
            --arg repo "${repo:-}" \
            --arg local_path "$dir" \
            --arg language "$language" \
            --argjson has_workflow "$has_workflow" \
            '{name: $name, repo: $repo, local_path: $local_path, language: $language, has_workflow: $has_workflow}')

        discovered+=("$entry")

        if ! $JSON_MODE; then
            local workflow_indicator="  "
            $has_workflow && workflow_indicator="✓ "
            log_info "$workflow_indicator$name ($language) - $dir"
        fi

    done < <(find "$search_path" -maxdepth 2 -type f \( -name "Cargo.toml" -o -name "go.mod" -o -name "package.json" \) -print0 2>/dev/null | xargs -0 -I{} dirname {} | sort -u)

    local discovered_json
    discovered_json=$(printf '%s\n' "${discovered[@]}" | jq -sc '.')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson discovered "$discovered_json" '{action: "discover", discovered: $discovered}')"
    else
        echo ""
        local count
        count=$(echo "$discovered_json" | jq 'length')
        log_info "Discovered $count potential repositories"
        if [[ $count -gt 0 ]] && ! $apply; then
            log_info "Run with --apply to add them to the registry"
        fi
    fi

    # Apply if requested
    if $apply && [[ ${#discovered[@]} -gt 0 ]]; then
        log_info "Adding discovered repositories..."
        for entry in "${discovered[@]}"; do
            local name repo local_path language
            name=$(echo "$entry" | jq -r '.name')
            repo=$(echo "$entry" | jq -r '.repo // ""')
            local_path=$(echo "$entry" | jq -r '.local_path')
            language=$(echo "$entry" | jq -r '.language')

            cmd_repos_add "$name" --local-path "$local_path" --language "$language" 2>/dev/null || true
        done
    fi
}

# Sync repository metadata from GitHub
cmd_repos_sync() {
    log_info "Syncing repository metadata from GitHub..."

    if [[ ! -f "$DSR_REPOS_FILE" ]]; then
        log_error "Repos file not found"
        return 4
    fi

    if ! command -v yq &>/dev/null; then
        log_error "yq required for sync"
        return 3
    fi

    local tools_json
    tools_json=$(yq -o=json '.tools // {}' "$DSR_REPOS_FILE" 2>/dev/null)

    local synced=0
    local failed=0

    while IFS= read -r name; do
        [[ -z "$name" ]] && continue

        local repo
        repo=$(echo "$tools_json" | jq -r --arg name "$name" '.[$name].repo // ""')

        if [[ -z "$repo" ]]; then
            log_warn "$name: no repo configured, skipping"
            continue
        fi

        log_info "Syncing $name ($repo)..."

        # Fetch repo info from GitHub
        if gh_check 2>/dev/null || gh_check_token 2>/dev/null; then
            local repo_info
            repo_info=$(gh_repo "$repo" 2>/dev/null) || {
                log_warn "$name: failed to fetch repo info"
                ((failed++))
                continue
            }

            local default_branch
            default_branch=$(echo "$repo_info" | jq -r '.default_branch // "main"')

            # Update the entry with synced data
            yq -i ".tools.$name.default_branch = \"$default_branch\"" "$DSR_REPOS_FILE"
            ((synced++))
            log_ok "$name: synced (default_branch: $default_branch)"
        else
            log_warn "$name: GitHub auth not available"
            ((failed++))
        fi

    done < <(echo "$tools_json" | jq -r 'keys[]')

    if $JSON_MODE; then
        json_envelope "repos" "success" 0 "$(jq -nc --argjson synced "$synced" --argjson failed "$failed" '{action: "sync", synced: $synced, failed: $failed}')"
    else
        echo ""
        log_info "Sync complete: $synced synced, $failed failed"
    fi
}

# ============================================================================
# HEALTH SUBCOMMAND
# ============================================================================

cmd_health() {
    local subcmd="${1:-check}"
    shift 2>/dev/null || true

    case "$subcmd" in
        check)
            cmd_health_check "$@"
            ;;
        all)
            cmd_health_all "$@"
            ;;
        clear-cache)
            cmd_health_clear_cache "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr health - Check health of build hosts

USAGE:
    dsr health <subcommand> [options]

SUBCOMMANDS:
    check <host>    Check specific host health
    all             Check all configured hosts
    clear-cache     Clear health check cache

OPTIONS:
    --no-cache      Skip cache and perform fresh checks
    --json          Output in JSON format (global)

CHECKS PERFORMED:
    - SSH connectivity (short timeout + BatchMode)
    - Disk space threshold (warn >90%, error >95%)
    - Toolchain availability (rust/go/bun per host)
    - Docker/Colima for act runners
    - Clock drift detection

EXAMPLES:
    dsr health check trj            Check local Threadripper
    dsr health check mmini          Check Mac Mini via SSH
    dsr health all                  Check all build hosts
    dsr health all --no-cache       Force fresh checks
    dsr health clear-cache          Clear cached results

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            # Treat as hostname if not a subcommand
            cmd_health_check "$subcmd" "$@"
            ;;
    esac
}

cmd_health_check() {
    local hostname="${1:-}"
    shift 2>/dev/null || true
    local no_cache=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-cache) no_cache=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$hostname" ]]; then
        log_error "Usage: dsr health check <hostname>"
        return 4
    fi

    local flags=""
    $no_cache && flags+=" --no-cache"
    $JSON_MODE && flags+=" --json"

    # shellcheck disable=SC2086  # flags needs word splitting
    host_health_check "$hostname" $flags
}

cmd_health_all() {
    local no_cache=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-cache) no_cache=true; shift ;;
            *) shift ;;
        esac
    done

    local flags=""
    $no_cache && flags+=" --no-cache"
    $JSON_MODE && flags+=" --json"

    # shellcheck disable=SC2086  # flags needs word splitting
    host_health_check_all $flags
}

cmd_health_clear_cache() {
    local hostname="${1:-}"
    host_health_clear_cache "$hostname"

    if $JSON_MODE; then
        if [[ -n "$hostname" ]]; then
            json_envelope "health" "success" 0 "{\"action\": \"clear-cache\", \"host\": \"$hostname\"}"
        else
            json_envelope "health" "success" 0 '{"action": "clear-cache", "all": true}'
        fi
    else
        if [[ -n "$hostname" ]]; then
            log_ok "Cleared health cache for: $hostname"
        else
            log_ok "Cleared all health cache"
        fi
    fi
}

# ============================================================================
# PRUNE SUBCOMMAND
# ============================================================================

_prune_size_bytes() {
    local path="$1"
    if [[ -f "$path" ]]; then
        stat -c%s "$path" 2>/dev/null || stat -f%z "$path" 2>/dev/null || echo 0
        return 0
    fi
    if [[ -d "$path" ]]; then
        local kb
        kb=$(du -sk "$path" 2>/dev/null | awk '{print $1}' || echo 0)
        echo $((kb * 1024))
        return 0
    fi
    echo 0
}

_prune_mtime_epoch() {
    local path="$1"
    stat -c%Y "$path" 2>/dev/null || stat -f%m "$path" 2>/dev/null || echo 0
}

_prune_epoch_to_iso() {
    local epoch="$1"
    if date -u -d "@$epoch" +"%Y-%m-%dT%H:%M:%SZ" >/dev/null 2>&1; then
        date -u -d "@$epoch" +"%Y-%m-%dT%H:%M:%SZ"
        return 0
    fi
    date -u -r "$epoch" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo ""
}

_prune_log_file() {
    local msg="$1"
    local path="$2"
    local size_bytes="$3"
    local log_file="${LOG_FILE:-}"

    [[ -z "$log_file" ]] && return 0

    local ts escaped_msg escaped_path
    ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    escaped_msg=$(_json_escape "$msg")
    escaped_path=$(_json_escape "$path")

    cat >> "$log_file" << EOF
{"ts":"$ts","run_id":"$DSR_RUN_ID","level":"info","cmd":"prune","msg":"$escaped_msg","event":"prune","path":"$escaped_path","size_bytes":$size_bytes}
EOF
}

cmd_prune() {
    local dry_run=false
    local max_age_days=30
    local keep_last=5
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            --max-age|--cutoff-days)
                max_age_days="${2:-}"
                shift 2
                ;;
            --keep-last)
                keep_last="${2:-}"
                shift 2
                ;;
            --force|--yes|-y)
                force=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr prune - Clean up old artifacts, logs, and cache

USAGE:
    dsr prune [options]

OPTIONS:
    -n, --dry-run       Show what would be removed without deleting
        --max-age DAYS  Remove items older than DAYS (default: 30)
        --keep-last N   Keep the most recent N build runs per tool/version (default: 5)
        --force         Skip confirmation prompt

EXAMPLES:
    dsr prune --dry-run
    dsr prune --max-age 14 --keep-last 3
EOF
                return 0
                ;;
            *)
                log_error "Unknown option: $1"
                log_info "Run 'dsr prune --help' for usage"
                return 4
                ;;
        esac
    done

    if [[ -z "$max_age_days" || ! "$max_age_days" =~ ^[0-9]+$ ]]; then
        log_error "Invalid --max-age: $max_age_days"
        return 4
    fi
    if [[ -z "$keep_last" || ! "$keep_last" =~ ^[0-9]+$ ]]; then
        log_error "Invalid --keep-last: $keep_last"
        return 4
    fi

    source "$SCRIPT_DIR/src/guardrails.sh"

    local state_dir cache_dir
    state_dir=$(resolve_path "$DSR_STATE_DIR" 2>/dev/null || echo "$DSR_STATE_DIR")
    cache_dir=$(resolve_path "$DSR_CACHE_DIR" 2>/dev/null || echo "$DSR_CACHE_DIR")

    if [[ ! -d "$state_dir" ]]; then
        log_error "State directory not found: $state_dir"
        if $JSON_MODE; then
            json_envelope "prune" "error" 4 "{\"state_dir\": \"$state_dir\", \"dry_run\": $dry_run, \"pruned_count\": 0, \"bytes_freed\": 0}"
        fi
        return 4
    fi

    if [[ ! -d "$cache_dir" ]]; then
        if ! $JSON_MODE; then
            log_warn "Cache directory not found: $cache_dir (skipping cache cleanup)"
        fi
    fi

    if ! $dry_run && ! $force; then
        if ! confirm "Prune old artifacts and cache in $state_dir and $cache_dir?" "n"; then
            if $JSON_MODE; then
                json_envelope "prune" "error" 5 "{\"state_dir\": \"$state_dir\", \"dry_run\": $dry_run, \"pruned_count\": 0, \"bytes_freed\": 0}"
            fi
            return 5
        fi
    fi

    local now_epoch cutoff_epoch
    now_epoch=$(date +%s)
    cutoff_epoch=$((now_epoch - max_age_days * 86400))

    local pruned_count=0
    local bytes_freed=0
    local pruned_items=()
    local errors=()

    _prune_record() {
        local path="$1"
        local size_bytes="$2"
        local mtime_iso="$3"
        pruned_items+=("{\"path\":\"$(_json_escape "$path")\",\"size_bytes\":$size_bytes,\"mtime\":\"$mtime_iso\"}")
        pruned_count=$((pruned_count + 1))
        bytes_freed=$((bytes_freed + size_bytes))
        if ! $JSON_MODE; then
            echo "$path"
        fi
    }

    _prune_error() {
        local code="$1"
        local message="$2"
        local path="$3"
        errors+=("{\"code\":\"$code\",\"message\":\"$(_json_escape "$message")\",\"path\":\"$(_json_escape "$path")\"}")
        if ! $JSON_MODE; then
            log_warn "$message: $path"
        fi
    }

    _prune_consider() {
        local path="$1"
        [[ -z "$path" ]] && return 0

        local size_bytes mtime_epoch mtime_iso
        size_bytes=$(_prune_size_bytes "$path")
        mtime_epoch=$(_prune_mtime_epoch "$path")
        mtime_iso=$(_prune_epoch_to_iso "$mtime_epoch")

        if $dry_run; then
            _prune_record "$path" "$size_bytes" "$mtime_iso"
            return 0
        fi

        if safe_rm "$path" --force; then
            _prune_record "$path" "$size_bytes" "$mtime_iso"
            _prune_log_file "Pruned path" "$path" "$size_bytes"
            if ! $JSON_MODE; then
                log_info "Pruned: $path"
            fi
            return 0
        fi

        _prune_error "E051" "Failed to delete" "$path"
        return 1
    }

    if ! $JSON_MODE; then
        $dry_run && log_info "Dry run: scanning for items older than $max_age_days days..."
        $dry_run || log_info "Pruning items older than $max_age_days days..."
    fi

    # Prune old logs
    if [[ -d "$state_dir/logs" ]]; then
        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$state_dir/logs" -mindepth 1 -maxdepth 1 -type d -mtime +"$max_age_days" 2>/dev/null)

        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$state_dir/logs" -type f -mtime +"$max_age_days" 2>/dev/null)
    fi

    # Prune old manifests
    if [[ -d "$state_dir/manifests" ]]; then
        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$state_dir/manifests" -type f -mtime +"$max_age_days" 2>/dev/null)
    fi

    # Prune old artifacts (by version directories)
    if [[ -d "$state_dir/artifacts" ]]; then
        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$state_dir/artifacts" -mindepth 2 -maxdepth 2 -type d -mtime +"$max_age_days" 2>/dev/null)
    fi

    # Prune old build runs beyond keep_last
    if [[ -d "$state_dir/builds" ]]; then
        local tool_dir version_dir
        for tool_dir in "$state_dir/builds"/*; do
            [[ -d "$tool_dir" ]] || continue
            for version_dir in "$tool_dir"/*; do
                [[ -d "$version_dir" ]] || continue

                local run_dirs=()
                while IFS= read -r line; do
                    run_dirs+=("$line")
                done < <(
                    find "$version_dir" -maxdepth 1 -type d -name 'run-*' 2>/dev/null | while read -r dir; do
                        local mtime
                        mtime=$(_prune_mtime_epoch "$dir")
                        echo "$mtime $dir"
                    done | sort -rn | awk '{print $2}'
                )

                local idx=0
                for run_dir in "${run_dirs[@]}"; do
                    idx=$((idx + 1))
                    if [[ $idx -le $keep_last ]]; then
                        continue
                    fi
                    local run_mtime
                    run_mtime=$(_prune_mtime_epoch "$run_dir")
                    if [[ "$run_mtime" -le "$cutoff_epoch" ]]; then
                        _prune_consider "$run_dir"
                    fi
                done
            done
        done
    fi

    # Prune cache entries
    if [[ -d "$cache_dir" ]]; then
        while IFS= read -r path; do
            _prune_consider "$path"
        done < <(find "$cache_dir" -mindepth 1 -maxdepth 1 -mtime +"$max_age_days" 2>/dev/null)
    fi

    local pruned_json errors_json details_json
    pruned_json=$(printf '%s\n' "${pruned_items[@]}" | jq -sc '.' 2>/dev/null || echo "[]")
    errors_json=$(printf '%s\n' "${errors[@]}" | jq -sc '.' 2>/dev/null || echo "[]")

    local status="success"
    local exit_code=0
    if [[ "${#errors[@]}" -gt 0 ]]; then
        status="partial"
        exit_code=1
    fi

    if $JSON_MODE; then
        details_json=$(jq -nc \
            --arg state_dir "$state_dir" \
            --argjson dry_run "$dry_run" \
            --argjson cutoff_days "$max_age_days" \
            --argjson keep_last "$keep_last" \
            --argjson pruned_count "$pruned_count" \
            --argjson bytes_freed "$bytes_freed" \
            --argjson pruned_paths "$pruned_json" \
            --argjson errors "$errors_json" \
            '{state_dir: $state_dir, dry_run: $dry_run, cutoff_days: $cutoff_days, keep_last: $keep_last, pruned_count: $pruned_count, bytes_freed: $bytes_freed, pruned_paths: $pruned_paths, errors: $errors}')
        json_envelope "prune" "$status" "$exit_code" "$details_json"
    else
        if $dry_run; then
            log_info "Dry run complete: $pruned_count item(s) would be removed, ${bytes_freed} bytes freed"
        else
            log_info "Prune complete: $pruned_count item(s) removed, ${bytes_freed} bytes freed"
        fi
    fi

    return $exit_code
}

# ============================================================================
# STATUS SUBCOMMAND
# ============================================================================

# Get last run info from log directory
_status_get_last_run() {
    local state_dir="${DSR_STATE_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/dsr}"
    local log_dir="$state_dir/logs"
    local latest_link="$log_dir/latest"

    if [[ ! -L "$latest_link" ]]; then
        echo '{"run_id": null, "timestamp": null, "log_file": null}'
        return
    fi

    local latest_date
    latest_date=$(readlink "$latest_link" 2>/dev/null)
    local run_log="$log_dir/$latest_date/run.log"

    if [[ ! -f "$run_log" ]]; then
        echo '{"run_id": null, "timestamp": null, "log_file": null}'
        return
    fi

    # Extract run_id and timestamp from last session start
    local last_entry
    last_entry=$(grep '"msg":"Session started"' "$run_log" 2>/dev/null | tail -1)

    if [[ -n "$last_entry" ]]; then
        local run_id ts
        run_id=$(echo "$last_entry" | jq -r '.run_id // empty')
        ts=$(echo "$last_entry" | jq -r '.ts // empty')
        jq -nc --arg run_id "$run_id" --arg ts "$ts" --arg log "$run_log" \
            '{run_id: $run_id, timestamp: $ts, log_file: $log}'
    else
        echo '{"run_id": null, "timestamp": null, "log_file": null}'
    fi
}

# Get config summary
_status_get_config() {
    local config_file="${DSR_CONFIG_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/dsr}/config.yaml"

    if [[ ! -f "$config_file" ]]; then
        echo '{"valid": false, "path": null}'
        return
    fi

    echo "{\"valid\": true, \"path\": \"$config_file\"}"
}

# Get signing status
_status_get_signing() {
    local private_key="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/secrets/minisign.key"
    local public_key="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/minisign.pub"

    local configured=false
    if [[ -f "$private_key" && -f "$public_key" ]]; then
        configured=true
    fi

    echo "{\"configured\": $configured}"
}

# Status command
cmd_status() {
    local refresh=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --refresh|-r)
                refresh=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr status - System and last run summary

USAGE:
    dsr status [options]

OPTIONS:
    --refresh, -r    Refresh host health (makes network calls)
    --json           JSON output (global flag)

DESCRIPTION:
    Shows a quick summary of:
    - Last run information (run_id, timestamp)
    - Configuration status
    - Host health (from cache by default)
    - Signing configuration

    By default, status is read from local state only (<1s).
    Use --refresh to update host health checks.

EXAMPLES:
    dsr status                Show cached status
    dsr status --refresh      Refresh host health
    dsr status --json         Machine-readable output
EOF
                return 0
                ;;
            *)
                log_error "Unknown option: $1"
                return 4
                ;;
        esac
    done

    # Collect status information
    local last_run config_status signing_status hosts_status

    last_run=$(_status_get_last_run)
    config_status=$(_status_get_config)
    signing_status=$(_status_get_signing)

    # Get host health (refresh if requested)
    if $refresh; then
        log_info "Refreshing host health..."
        hosts_status=$(host_health_check_all 2>/dev/null | jq -c '.')
    else
        # Try to get from cache, fallback to empty
        local cache_dir="${DSR_CACHE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}/dsr}/health"
        if [[ -d "$cache_dir" ]] && ls "$cache_dir"/*.json &>/dev/null; then
            hosts_status=$(cat "$cache_dir"/*.json 2>/dev/null | jq -s 'map({(.hostname): .}) | add' 2>/dev/null) || hosts_status='{}'
        else
            hosts_status='{}'
        fi
    fi

    # Ensure hosts_status is valid JSON
    if [[ -z "$hosts_status" ]] || ! echo "$hosts_status" | jq -e . &>/dev/null; then
        hosts_status='{}'
    fi

    # Build JSON output
    local json_output
    json_output=$(jq -nc \
        --argjson last_run "$last_run" \
        --argjson config "$config_status" \
        --argjson signing "$signing_status" \
        --argjson hosts "$hosts_status" \
        '{
            last_run: $last_run,
            config: $config,
            signing: $signing,
            hosts: $hosts
        }' 2>/dev/null) || json_output='{}'

    if $JSON_MODE; then
        json_envelope "status" "success" 0 "$json_output"
    else
        # Human-readable output
        echo ""
        log_info "=== DSR Status ==="
        echo ""

        # Last run
        local run_id ts
        run_id=$(echo "$last_run" | jq -r '.run_id // "none"')
        ts=$(echo "$last_run" | jq -r '.timestamp // "never"')

        if [[ "$run_id" != "null" && "$run_id" != "none" ]]; then
            log_info "Last Run:"
            log_info "  Run ID:    $run_id"
            log_info "  Timestamp: $ts"
        else
            log_info "Last Run: no runs recorded"
        fi
        echo ""

        # Config
        local config_valid config_path
        config_valid=$(echo "$config_status" | jq -r '.valid')
        config_path=$(echo "$config_status" | jq -r '.path // "not found"')

        log_info "Configuration:"
        if [[ "$config_valid" == "true" ]]; then
            log_ok "  Config: valid ($config_path)"
        else
            log_warn "  Config: not found (run 'dsr config init')"
        fi
        echo ""

        # Signing
        local signing_configured
        signing_configured=$(echo "$signing_status" | jq -r '.configured')

        log_info "Signing:"
        if [[ "$signing_configured" == "true" ]]; then
            log_ok "  Keypair: configured"
        else
            log_warn "  Keypair: not configured (run 'dsr signing init')"
        fi
        echo ""

        # Hosts (if any cached)
        if [[ -n "$hosts_status" && "$hosts_status" != "{}" && "$hosts_status" != "null" ]]; then
            log_info "Build Hosts (cached):"
            echo "$hosts_status" | jq -r 'to_entries[] | "  \(.key): \(.value.status // "unknown")"' 2>/dev/null || true
        else
            log_info "Build Hosts: no cached status (use --refresh)"
        fi
        echo ""
    fi

    return 0
}

# ============================================================================
# VERSION SUBCOMMAND
# ============================================================================

cmd_version() {
    local subcmd="${1:-detect}"
    shift 2>/dev/null || true

    case "$subcmd" in
        detect)
            # dsr version detect <tool|path>
            local target="${1:-}"
            local repo_path=""

            if [[ -z "$target" ]]; then
                log_error "Usage: dsr version detect <tool|path>"
                return 4
            fi

            # Resolve target to repo path
            if [[ -d "$target" ]]; then
                repo_path="$target"
            else
                # Try to find tool in repos.d
                local config_file="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/repos.d/${target}.yaml"
                if [[ -f "$config_file" ]] && command -v yq &>/dev/null; then
                    repo_path=$(yq -r '.local_path // ""' "$config_file" 2>/dev/null)
                fi
            fi

            if [[ -z "$repo_path" || ! -d "$repo_path" ]]; then
                log_error "Cannot resolve target to repository: $target"
                return 4
            fi

            if $JSON_MODE; then
                local json_result
                json_result=$(version_info_json "$repo_path")
                json_envelope "version detect" "success" 0 "$json_result"
            else
                local version
                if version=$(version_detect "$repo_path"); then
                    log_ok "Version: $version (v$version)"
                    if version_needs_tag "$repo_path"; then
                        log_info "Tag v$version does not exist (create with: dsr version tag $target)"
                    else
                        log_info "Tag v$version already exists"
                    fi
                else
                    log_error "No version file found in $repo_path"
                    return 1
                fi
            fi
            ;;

        tag)
            # dsr version tag <tool|path> [--push] [--all]
            local target="${1:-}"
            local push=false
            local tag_all=false

            # Parse options
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --push) push=true; shift ;;
                    --all) tag_all=true; shift ;;
                    --dry-run|-n) shift ;;  # Already handled by global DRY_RUN
                    -*) shift ;;
                    *)
                        if [[ -z "$target" || "$target" == --* ]]; then
                            target="$1"
                        fi
                        shift
                        ;;
                esac
            done

            if $tag_all; then
                # Tag all configured tools
                local args=""
                $push && args+=" --push"
                $DRY_RUN && args+=" --dry-run"
                $JSON_MODE && args+=" --json"
                # shellcheck disable=SC2086
                version_tag_all $args
                return $?
            fi

            if [[ -z "$target" ]]; then
                log_error "Usage: dsr version tag <tool|path> [--push]"
                log_error "       dsr version tag --all [--push]"
                return 4
            fi

            # Resolve target to repo path
            local repo_path=""
            if [[ -d "$target" ]]; then
                repo_path="$target"
            else
                local config_file="${DSR_CONFIG_DIR:-$HOME/.config/dsr}/repos.d/${target}.yaml"
                if [[ -f "$config_file" ]] && command -v yq &>/dev/null; then
                    repo_path=$(yq -r '.local_path // ""' "$config_file" 2>/dev/null)
                fi
            fi

            if [[ -z "$repo_path" || ! -d "$repo_path" ]]; then
                log_error "Cannot resolve target to repository: $target"
                return 4
            fi

            local tag_args=""
            $push && tag_args+=" --push"
            $DRY_RUN && tag_args+=" --dry-run"

            # shellcheck disable=SC2086
            if version_create_tag "$repo_path" $tag_args; then
                if $JSON_MODE; then
                    local json_result
                    json_result=$(version_info_json "$repo_path")
                    json_envelope "version tag" "success" 0 "$json_result"
                fi
                return 0
            else
                return 1
            fi
            ;;

        --help|-h|help)
            cat << 'EOF'
dsr version - Detect and tag versions from version files

USAGE:
    dsr version <subcommand> [options]

SUBCOMMANDS:
    detect <tool|path>      Show version from version files
    tag <tool|path>         Create git tag for detected version
    tag --all               Tag all configured tools with new versions

OPTIONS:
    --push          Push tags to remote after creation
    --dry-run       Show planned actions without executing

VERSION SOURCES:
    Rust        Cargo.toml       version = "X.Y.Z"
    Go          VERSION, *.go    Version = "X.Y.Z"
    Node/Bun    package.json     "version": "X.Y.Z"
    Python      pyproject.toml   version = "X.Y.Z"

EXAMPLES:
    dsr version detect ntm          Show version for ntm tool
    dsr version detect /path/to/repo
    dsr version tag ntm --push      Create and push tag
    dsr version tag --all           Tag all tools needing tags
    dsr version tag --all --push    Tag and push all

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;

        *)
            log_error "Unknown version subcommand: $subcmd"
            log_info "Run 'dsr version --help' for usage"
            return 4
            ;;
    esac
}

# ============================================================================
# SIGNING SUBCOMMAND
# ============================================================================

cmd_signing() {
    local subcmd="${1:-check}"
    shift 2>/dev/null || true

    case "$subcmd" in
        init)
            signing_init "$@"
            ;;
        check)
            if $JSON_MODE; then
                signing_check --json
            else
                signing_check
            fi
            ;;
        sign)
            signing_sign "$@"
            ;;
        verify)
            signing_verify "$@"
            ;;
        fix)
            signing_fix_permissions
            ;;
        pubkey|public-key)
            signing_get_public_key "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr signing - Manage minisign keys and artifact signing

USAGE:
    dsr signing <subcommand> [options]

SUBCOMMANDS:
    init        Generate new keypair (interactive)
    check       Verify keypair is configured
    sign        Sign a file
    verify      Verify a file signature
    fix         Fix private key permissions
    pubkey      Display public key

EXAMPLES:
    dsr signing init              Generate new keypair
    dsr signing check             Check if keys are configured
    dsr signing sign artifact.tar.gz
    dsr signing verify artifact.tar.gz
    dsr signing pubkey --oneline  Get public key for embedding

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            log_error "Unknown signing subcommand: $subcmd"
            log_info "Run 'dsr signing --help' for usage"
            return 4
            ;;
    esac
}

# ============================================================================
# VERIFY SUBCOMMAND - Verification Commands
# ============================================================================

cmd_verify() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        upgrade)
            _verify_upgrade "$@"
            ;;
        --help|-h|help|"")
            cat << 'EOF'
dsr verify - Verification commands

USAGE:
    dsr verify upgrade <tool> [options]
    dsr verify upgrade --all

SUBCOMMANDS:
    upgrade     Verify tool upgrade commands work correctly after release

OPTIONS:
    --build-from-source   Build tool from source before testing
    --dry-run             Show what would be tested
    --all                 Verify all tools

DESCRIPTION:
    After releasing binaries, verify that each tool's `upgrade --check`
    command correctly finds and downloads the new release assets.
    Catches asset naming mismatches between code and build configs.

EXAMPLES:
    dsr verify upgrade ntm                    Verify ntm's upgrade command
    dsr verify upgrade --all                  Verify all tools
    dsr verify upgrade ntm --build-from-source  Build and verify

EXIT CODES:
    0  - All verifications passed
    1  - Some verifications failed
    4  - Invalid arguments
EOF
            return 0
            ;;
        *)
            log_error "Unknown verify subcommand: $subcmd"
            log_info "Run 'dsr verify --help' for usage"
            return 4
            ;;
    esac
}

_verify_upgrade() {
    local tool_name=""
    local all_tools=false
    local build_from_source=false
    local dry_run_flag=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all)
                all_tools=true
                shift
                ;;
            --build-from-source)
                build_from_source=true
                shift
                ;;
            --dry-run)
                dry_run_flag=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                return 4
                ;;
            *)
                tool_name="$1"
                shift
                ;;
        esac
    done

    local start_time
    start_time=$(date +%s)

    local args=""
    $build_from_source && args+=" --build-from-source"
    $dry_run_flag && args+=" --dry-run"

    if $all_tools; then
        log_info "Verifying upgrade command for all tools..."

        # shellcheck disable=SC2086
        if upgrade_verify_all $args; then
            local duration=$(($(date +%s) - start_time))
            if $JSON_MODE; then
                json_envelope "verify-upgrade" "ok" 0 "{\"mode\": \"all\", \"duration_seconds\": $duration}"
            else
                log_ok "All upgrade verifications passed"
            fi
            return 0
        else
            local duration=$(($(date +%s) - start_time))
            if $JSON_MODE; then
                json_envelope "verify-upgrade" "failed" 1 "{\"mode\": \"all\", \"duration_seconds\": $duration}"
            else
                log_error "Some upgrade verifications failed"
            fi
            return 1
        fi
    fi

    if [[ -z "$tool_name" ]]; then
        log_error "Tool name required (or use --all)"
        return 4
    fi

    # shellcheck disable=SC2086
    if upgrade_verify_tool "$tool_name" $args; then
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            local result
            result=$(upgrade_verify_json "$tool_name" 2>/dev/null || echo '{}')
            json_envelope "verify-upgrade" "ok" 0 "$(echo "$result" | jq --argjson duration "$duration" '. + {duration_seconds: $duration}')"
        else
            log_ok "Upgrade verification passed for $tool_name"
        fi
        return 0
    else
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            local result
            result=$(upgrade_verify_json "$tool_name" 2>/dev/null || echo '{}')
            json_envelope "verify-upgrade" "failed" 1 "$(echo "$result" | jq --argjson duration "$duration" '. + {duration_seconds: $duration}')"
        else
            log_error "Upgrade verification failed for $tool_name"
        fi
        return 1
    fi
}

# ============================================================================
# CANARY SUBCOMMAND - Installer Testing in Docker
# ============================================================================

cmd_canary() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        run)
            _canary_run "$@"
            ;;
        matrix)
            _canary_matrix "$@"
            ;;
        schedule)
            _canary_schedule "$@"
            ;;
        results)
            _canary_results "$@"
            ;;
        --help|-h|help|"")
            cat << 'EOF'
dsr canary - Test installers in Docker containers

USAGE:
    dsr canary run <tool> [--os <image>] [--mode <vibe|safe>]
    dsr canary run --all [--os <image>]
    dsr canary matrix [--tools <list>]
    dsr canary schedule [--cron <expr>]
    dsr canary results

SUBCOMMANDS:
    run         Run canary test for one or all tools
    matrix      Run full test matrix (all images/modes)
    schedule    Setup daily canary cron job
    results     Show latest canary results

OPTIONS:
    --os <image>    Docker image to test (default: ubuntu:24.04)
    --mode <mode>   Installation mode: vibe or safe (default: vibe)
    --all           Test all tools with installers
    --tools <list>  Comma-separated list of tools
    --cron <expr>   Cron schedule (default: "0 6 * * *")

EXAMPLES:
    dsr canary run ntm                      Test ntm on ubuntu:24.04
    dsr canary run ntm --os debian:12       Test on specific image
    dsr canary run --all                    Test all tools
    dsr canary matrix                       Full test matrix
    dsr canary schedule                     Setup daily cron
    dsr canary results                      Show latest results

EXIT CODES:
    0  - All tests passed
    1  - Some tests failed
    3  - Docker not available
    4  - Invalid arguments
EOF
            return 0
            ;;
        *)
            log_error "Unknown canary subcommand: $subcmd"
            log_info "Run 'dsr canary --help' for usage"
            return 4
            ;;
    esac
}

_canary_run() {
    local tool=""
    local image="ubuntu:24.04"
    local mode="vibe"
    local all_tools=false
    local verbose=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --os|--image)
                image="$2"
                shift 2
                ;;
            --mode)
                mode="$2"
                shift 2
                ;;
            --all)
                all_tools=true
                shift
                ;;
            --verbose|-v)
                verbose=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                return 4
                ;;
            *)
                tool="$1"
                shift
                ;;
        esac
    done

    # Check Docker
    if ! canary_check_docker; then
        if $JSON_MODE; then
            json_envelope "canary" "error" 3 '{"error": "Docker not available"}'
        fi
        return 3
    fi

    local start_time results
    start_time=$(date +%s)

    if $all_tools; then
        log_info "Running canary tests for all tools on $image ($mode mode)..."
        results=$(canary_run_image "$image" --mode "$mode" 2>&1)
        local status=$?

        if $JSON_MODE; then
            local duration=$(($(date +%s) - start_time))
            json_envelope "canary" "$([[ $status -eq 0 ]] && echo "ok" || echo "failed")" "$status" \
                "$(echo "$results" | jq --argjson duration "$duration" '. + {duration_seconds: $duration}')"
        else
            echo "$results" | jq -r '
                "Results for \(.image) (\(.mode) mode):",
                "  Passed: \(.passed)",
                "  Failed: \(.failed)",
                "",
                (.results[] | "  \(.tool): \(.status)")
            '
        fi

        # Save results
        canary_save_results "$results" 2>/dev/null || true

        return $status
    fi

    if [[ -z "$tool" ]]; then
        log_error "Tool name required (or use --all)"
        return 4
    fi

    log_info "Running canary test for $tool on $image ($mode mode)..."

    if canary_run_test "$tool" "$image" "$mode" "$verbose"; then
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "canary" "ok" 0 "$(jq -nc \
                --arg tool "$tool" \
                --arg image "$image" \
                --arg mode "$mode" \
                --argjson duration "$duration" \
                '{tool: $tool, image: $image, mode: $mode, status: "passed", duration_seconds: $duration}')"
        else
            log_ok "Canary test passed for $tool on $image"
        fi
        return 0
    else
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "canary" "failed" 1 "$(jq -nc \
                --arg tool "$tool" \
                --arg image "$image" \
                --arg mode "$mode" \
                --argjson duration "$duration" \
                '{tool: $tool, image: $image, mode: $mode, status: "failed", duration_seconds: $duration}')"
        else
            log_error "Canary test failed for $tool on $image"
        fi
        return 1
    fi
}

_canary_matrix() {
    local tools_arg=""
    local modes_arg=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tools)
                tools_arg="--tools $2"
                shift 2
                ;;
            --modes)
                modes_arg="--modes $2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Check Docker
    if ! canary_check_docker; then
        if $JSON_MODE; then
            json_envelope "canary-matrix" "error" 3 '{"error": "Docker not available"}'
        fi
        return 3
    fi

    log_info "Running full canary matrix..."

    local start_time
    start_time=$(date +%s)

    # shellcheck disable=SC2086  # Intentional word splitting
    if canary_run_matrix $tools_arg $modes_arg; then
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "canary-matrix" "ok" 0 "{\"duration_seconds\": $duration}"
        else
            log_ok "Matrix tests completed successfully"
        fi
        return 0
    else
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "canary-matrix" "failed" 1 "{\"duration_seconds\": $duration}"
        else
            log_error "Some matrix tests failed"
        fi
        return 1
    fi
}

_canary_schedule() {
    local cron_expr=""
    local unschedule=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --cron)
                cron_expr="$2"
                shift 2
                ;;
            --remove|--unschedule)
                unschedule=true
                shift
                ;;
            --show)
                canary_show_schedule
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    if $unschedule; then
        canary_unschedule
    elif [[ -n "$cron_expr" ]]; then
        canary_schedule "$cron_expr"
    else
        canary_schedule
    fi
}

_canary_results() {
    local results
    results=$(canary_get_latest)

    if $JSON_MODE; then
        echo "$results"
    else
        echo "$results" | jq -r '
            if .error then
                "No canary results found"
            else
                "Latest canary results (\(.timestamp // "unknown")):",
                "  Image: \(.image // "unknown")",
                "  Mode: \(.mode // "unknown")",
                "  Passed: \(.passed // 0)",
                "  Failed: \(.failed // 0)",
                "",
                "Results:",
                (.results // [] | .[] | "  \(.tool): \(.status)")
            end
        '
    fi
}

# ============================================================================
# SBOM SUBCOMMAND - Software Bill of Materials
# ============================================================================

cmd_sbom() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        generate)
            _sbom_generate "$@"
            ;;
        verify)
            _sbom_verify "$@"
            ;;
        --help|-h|help|"")
            cat << 'EOF'
dsr sbom - Software Bill of Materials (SBOM) generation

USAGE:
    dsr sbom generate <path> [options]
    dsr sbom verify <sbom-file>

SUBCOMMANDS:
    generate    Generate SBOM for a project or artifact
    verify      Verify an SBOM file is valid

OPTIONS:
    --format, -f <fmt>  Output format: spdx (default) or cyclonedx
    --output, -o <file> Output file (default: auto-generated)

DESCRIPTION:
    Generates Software Bill of Materials using syft for supply chain
    transparency. SBOMs can be attached to releases for compliance.

REQUIREMENTS:
    - syft must be installed: curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s

EXAMPLES:
    dsr sbom generate /path/to/project          # Generate SPDX SBOM
    dsr sbom generate /path/to/binary --format cyclonedx
    dsr sbom verify sbom.spdx.json              # Verify SBOM format

EXIT CODES:
    0  - Success
    1  - Error generating/verifying SBOM
    3  - syft not installed
    4  - Invalid arguments
EOF
            return 0
            ;;
        *)
            log_error "Unknown sbom subcommand: $subcmd"
            log_info "Run 'dsr sbom --help' for usage"
            return 4
            ;;
    esac
}

_sbom_generate() {
    local target=""
    local format="spdx"
    local output=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format|-f) format="$2"; shift 2 ;;
            --output|-o) output="$2"; shift 2 ;;
            -*) log_error "Unknown option: $1"; return 4 ;;
            *) target="$1"; shift ;;
        esac
    done

    if [[ -z "$target" ]]; then
        log_error "Target path required"
        return 4
    fi

    local start_time
    start_time=$(date +%s)

    local args=""
    [[ -n "$output" ]] && args+=" --output $output"

    # shellcheck disable=SC2086
    if result=$(sbom_generate "$target" --format "$format" $args 2>&1); then
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "sbom-generate" "ok" 0 "$(jq -nc \
                --arg target "$target" \
                --arg format "$format" \
                --arg output "$result" \
                --argjson duration "$duration" \
                '{target: $target, format: $format, output: $output, duration_seconds: $duration}')"
        else
            log_ok "SBOM generated: $result"
        fi
        return 0
    else
        local exit_code=$?
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "sbom-generate" "error" "$exit_code" "$(jq -nc \
                --arg error "$result" \
                --argjson duration "$duration" \
                '{error: $error, duration_seconds: $duration}')"
        fi
        return $exit_code
    fi
}

_sbom_verify() {
    local sbom_file="${1:-}"

    if [[ -z "$sbom_file" ]]; then
        log_error "SBOM file required"
        return 4
    fi

    if sbom_verify "$sbom_file"; then
        if $JSON_MODE; then
            json_envelope "sbom-verify" "ok" 0 "$(jq -nc --arg file "$sbom_file" '{file: $file, valid: true}')"
        fi
        return 0
    else
        local exit_code=$?
        if $JSON_MODE; then
            json_envelope "sbom-verify" "error" "$exit_code" "$(jq -nc --arg file "$sbom_file" '{file: $file, valid: false}')"
        fi
        return $exit_code
    fi
}

# ============================================================================
# SLSA SUBCOMMAND - Supply Chain Provenance
# ============================================================================

cmd_slsa() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        generate)
            _slsa_generate "$@"
            ;;
        verify)
            _slsa_verify "$@"
            ;;
        --help|-h|help|"")
            cat << 'EOF'
dsr slsa - SLSA provenance attestation

USAGE:
    dsr slsa generate <artifact> [options]
    dsr slsa verify <artifact> [provenance]

SUBCOMMANDS:
    generate    Generate SLSA v1 provenance for an artifact
    verify      Verify SLSA provenance matches artifact digest

OPTIONS:
    --builder, -b <id>  Builder identity URL
    --output, -o <file> Output file (default: <artifact>.intoto.jsonl)

DESCRIPTION:
    Generates SLSA v1 provenance (in-toto Statement) for release artifacts.
    Provides verifiable build provenance for supply chain security.

    The provenance includes:
    - Artifact name and SHA256 digest
    - Builder identity
    - Build timestamps
    - Git source info (if available)

EXAMPLES:
    dsr slsa generate ./build/ntm-linux-amd64
    dsr slsa generate ./build/ntm-darwin-arm64 --builder "https://github.com/Dicklesworthstone/dsr"
    dsr slsa verify ./build/ntm-linux-amd64

EXIT CODES:
    0  - Success
    1  - Verification failed / digest mismatch
    4  - Invalid arguments
EOF
            return 0
            ;;
        *)
            log_error "Unknown slsa subcommand: $subcmd"
            log_info "Run 'dsr slsa --help' for usage"
            return 4
            ;;
    esac
}

_slsa_generate() {
    local artifact=""
    local builder_id="$SLSA_BUILDER_ID"
    local output=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --builder|-b) builder_id="$2"; shift 2 ;;
            --output|-o) output="$2"; shift 2 ;;
            -*) log_error "Unknown option: $1"; return 4 ;;
            *) artifact="$1"; shift ;;
        esac
    done

    if [[ -z "$artifact" ]]; then
        log_error "Artifact path required"
        return 4
    fi

    local start_time
    start_time=$(date +%s)

    local args=""
    [[ -n "$output" ]] && args+=" --output $output"

    # shellcheck disable=SC2086
    if result=$(slsa_generate "$artifact" --builder "$builder_id" $args 2>&1); then
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "slsa-generate" "ok" 0 "$(jq -nc \
                --arg artifact "$artifact" \
                --arg builder "$builder_id" \
                --arg output "$result" \
                --argjson duration "$duration" \
                '{artifact: $artifact, builder: $builder, output: $output, duration_seconds: $duration}')"
        else
            log_ok "SLSA provenance generated: $result"
        fi
        return 0
    else
        local exit_code=$?
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "slsa-generate" "error" "$exit_code" "$(jq -nc \
                --arg error "$result" \
                --argjson duration "$duration" \
                '{error: $error, duration_seconds: $duration}')"
        fi
        return $exit_code
    fi
}

_slsa_verify() {
    local artifact="${1:-}"
    local provenance="${2:-}"

    if [[ -z "$artifact" ]]; then
        log_error "Artifact path required"
        return 4
    fi

    local start_time
    start_time=$(date +%s)

    if slsa_verify "$artifact" "$provenance"; then
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "slsa-verify" "ok" 0 "$(jq -nc \
                --arg artifact "$artifact" \
                --argjson duration "$duration" \
                '{artifact: $artifact, valid: true, duration_seconds: $duration}')"
        fi
        return 0
    else
        local exit_code=$?
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "slsa-verify" "error" "$exit_code" "$(jq -nc \
                --arg artifact "$artifact" \
                --argjson duration "$duration" \
                '{artifact: $artifact, valid: false, duration_seconds: $duration}')"
        fi
        return $exit_code
    fi
}

# ============================================================================
# DOCKER SUBCOMMAND
# ============================================================================

cmd_docker() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        build)
            _docker_build "$@"
            ;;
        release)
            _docker_release "$@"
            ;;
        sign)
            _docker_sign "$@"
            ;;
        setup)
            _docker_setup "$@"
            ;;
        --help|-h|help|"")
            cat << 'EOF'
dsr docker - Multi-arch Docker image building

USAGE:
    dsr docker build <tool> <version> [options]
    dsr docker release <tool> <version> [options]
    dsr docker sign <image>
    dsr docker setup

SUBCOMMANDS:
    build     Build multi-arch Docker image
    release   Build, push, sign, and attest image
    sign      Sign container with cosign (keyless)
    setup     Setup buildx builder

OPTIONS:
    --push              Push to GHCR after build
    --local             Build for local platform only
    -p, --platform      Platforms (default: linux/amd64,linux/arm64)
    --skip-sign         Skip cosign signing (release only)
    -n, --dry-run       Show what would be done

DESCRIPTION:
    Builds and publishes multi-architecture Docker images for tools
    that support containerization. Uses docker buildx for cross-platform
    builds and cosign for keyless signing.

    Containerized tools: ubs, mcp_agent_mail, process_triage

EXAMPLES:
    dsr docker build ubs v1.2.3              # Build multi-arch
    dsr docker build ubs v1.2.3 --push       # Build and push
    dsr docker release ubs v1.2.3            # Full release workflow
    dsr docker sign ghcr.io/dicklesworthstone/ubs:v1.2.3

EXIT CODES:
    0  - Success
    1  - Build/operation failed
    3  - Dependency error (docker/buildx/cosign)
    4  - Invalid arguments
    7  - No Dockerfile found
EOF
            return 0
            ;;
        *)
            log_error "Unknown docker subcommand: $subcmd"
            log_info "Run 'dsr docker --help' for usage"
            return 4
            ;;
    esac
}

_docker_build() {
    local tool=""
    local version=""
    local push=false
    local local_only=false
    local platforms=""
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --push) push=true; shift ;;
            --local) local_only=true; shift ;;
            --platform|-p) platforms="$2"; shift 2 ;;
            --dry-run|-n) dry_run=true; shift ;;
            --help|-h) docker_build --help; return 0 ;;
            -*) log_error "Unknown option: $1"; return 4 ;;
            *)
                if [[ -z "$tool" ]]; then
                    tool="$1"
                elif [[ -z "$version" ]]; then
                    version="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$tool" || -z "$version" ]]; then
        log_error "Tool and version required"
        log_info "Usage: dsr docker build <tool> <version>"
        return 4
    fi

    local start_time
    start_time=$(date +%s)

    local args=(--tool "$tool" --version "$version")
    $push && args+=(--push)
    $local_only && args+=(--local)
    [[ -n "$platforms" ]] && args+=(--platform "$platforms")
    $dry_run && args+=(--dry-run)

    if docker_build "${args[@]}"; then
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            local image="$DOCKER_REGISTRY/$tool:v${version#v}"
            json_envelope "docker-build" "ok" 0 "$(jq -nc \
                --arg tool "$tool" \
                --arg version "$version" \
                --arg image "$image" \
                --argjson pushed "$push" \
                --argjson duration "$duration" \
                '{tool: $tool, version: $version, image: $image, pushed: $pushed, duration_seconds: $duration}')"
        fi
        return 0
    else
        local exit_code=$?
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "docker-build" "error" "$exit_code" "$(jq -nc \
                --arg tool "$tool" \
                --arg version "$version" \
                --argjson duration "$duration" \
                '{tool: $tool, version: $version, duration_seconds: $duration}')"
        fi
        return $exit_code
    fi
}

_docker_release() {
    local tool=""
    local version=""
    local skip_sign=false
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --skip-sign) skip_sign=true; shift ;;
            --dry-run|-n) dry_run=true; shift ;;
            --help|-h) docker_release --help; return 0 ;;
            -*) log_error "Unknown option: $1"; return 4 ;;
            *)
                if [[ -z "$tool" ]]; then
                    tool="$1"
                elif [[ -z "$version" ]]; then
                    version="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$tool" || -z "$version" ]]; then
        log_error "Tool and version required"
        log_info "Usage: dsr docker release <tool> <version>"
        return 4
    fi

    local start_time
    start_time=$(date +%s)

    local args=(--tool "$tool" --version "$version")
    $skip_sign && args+=(--skip-sign)
    $dry_run && args+=(--dry-run)

    if docker_release "${args[@]}"; then
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            local image="$DOCKER_REGISTRY/$tool:v${version#v}"
            json_envelope "docker-release" "ok" 0 "$(jq -nc \
                --arg tool "$tool" \
                --arg version "$version" \
                --arg image "$image" \
                --argjson duration "$duration" \
                '{tool: $tool, version: $version, image: $image, duration_seconds: $duration}')"
        fi
        return 0
    else
        local exit_code=$?
        local duration=$(($(date +%s) - start_time))
        if $JSON_MODE; then
            json_envelope "docker-release" "error" "$exit_code" "$(jq -nc \
                --arg tool "$tool" \
                --arg version "$version" \
                --argjson duration "$duration" \
                '{tool: $tool, version: $version, duration_seconds: $duration}')"
        fi
        return $exit_code
    fi
}

_docker_sign() {
    local image=""
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-n) dry_run=true; shift ;;
            --help|-h) docker_sign --help; return 0 ;;
            -*)
                log_error "Unknown option: $1"
                return 4
                ;;
            *)
                [[ -z "$image" ]] && image="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$image" ]]; then
        log_error "Image reference required"
        log_info "Usage: dsr docker sign <image>"
        return 4
    fi

    local args=("$image")
    $dry_run && args+=(--dry-run)

    if docker_sign "${args[@]}"; then
        if $JSON_MODE; then
            json_envelope "docker-sign" "ok" 0 "$(jq -nc --arg image "$image" '{image: $image, signed: true}')"
        fi
        return 0
    else
        local exit_code=$?
        if $JSON_MODE; then
            json_envelope "docker-sign" "error" "$exit_code" "$(jq -nc --arg image "$image" '{image: $image, signed: false}')"
        fi
        return $exit_code
    fi
}

_docker_setup() {
    if docker_setup_buildx; then
        if $JSON_MODE; then
            json_envelope "docker-setup" "ok" 0 "$(jq -nc --arg builder "$DOCKER_BUILDER_NAME" '{builder: $builder, ready: true}')"
        fi
        return 0
    else
        local exit_code=$?
        if $JSON_MODE; then
            json_envelope "docker-setup" "error" "$exit_code" '{"ready": false}'
        fi
        return $exit_code
    fi
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    # shellcheck disable=SC2034  # DRY_RUN/NON_INTERACTIVE reserved for future use
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json|-j)
                JSON_MODE=true
                shift
                ;;
            --dry-run|-n)
                DRY_RUN=true
                shift
                ;;
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            --quiet|-q)
                QUIET=true
                shift
                ;;
            --non-interactive|-y)
                NON_INTERACTIVE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -*)
                # Unknown option - might be command-specific
                break
                ;;
            *)
                # Not an option - must be command
                break
                ;;
        esac
    done

    # Initialize logging with appropriate level
    log_set_level_from_flags "$VERBOSE" "$QUIET"
    log_init

    # Get command
    local command="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$command" ]]; then
        show_help
        exit 0
    fi

    # Set command context for logging
    log_set_command "$command"

    # Dispatch to command handler
    case "$command" in
        config)
            cmd_config "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        check)
            cmd_check "$@"
            ;;
        watch)
            cmd_watch "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        release)
            # Check for subcommand
            case "${1:-}" in
                verify)
                    shift
                    cmd_release_verify "$@"
                    ;;
                formulas)
                    shift
                    cmd_release_formulas "$@"
                    ;;
                *)
                    cmd_release "$@"
                    ;;
            esac
            ;;
        fallback)
            cmd_fallback "$@"
            ;;
        quality)
            cmd_quality "$@"
            ;;
        repos)
            cmd_repos "$@"
            ;;
        health)
            cmd_health "$@"
            ;;
        prune)
            cmd_prune "$@"
            ;;
        signing)
            cmd_signing "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        version)
            cmd_version "$@"
            ;;
        canary)
            cmd_canary "$@"
            ;;
        sbom)
            cmd_sbom "$@"
            ;;
        slsa)
            cmd_slsa "$@"
            ;;
        docker)
            cmd_docker "$@"
            ;;
        verify)
            cmd_verify "$@"
            ;;
        help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown command: $command"
            log_info "Run 'dsr --help' for usage"
            exit 4
            ;;
    esac
}

main "$@"
